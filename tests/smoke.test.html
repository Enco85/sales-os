<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Smoke Tests — Enterprise RC 2026</title>
    <style>
        :root {
            color-scheme: light dark;
            font-family: system-ui, -apple-system, "SF Pro Text", "Segoe UI", Arial, sans-serif;
            background: #0B0B0D;
            color: #F8FAFC;
        }
        body {
            margin: 0;
            padding: 24px;
            display: grid;
            gap: 16px;
        }
        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }
        h1 {
            font-size: 18px;
            margin: 0;
        }
        .controls {
            display: flex;
            gap: 8px;
        }
        button {
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.08);
            color: inherit;
            cursor: pointer;
        }
        .grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 16px;
        }
        .panel {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 12px;
            padding: 12px;
        }
        iframe {
            width: 100%;
            height: 75vh;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            background: #0B0B0D;
        }
        .result {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            padding: 8px 10px;
            border-radius: 8px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.04);
        }
        .status {
            font-weight: 700;
            min-width: 60px;
            text-align: right;
        }
        .PASS { color: #34D399; }
        .FAIL { color: #F87171; }
        .WARN { color: #FBBF24; }
        .summary {
            font-size: 13px;
            opacity: 0.8;
        }
        .log {
            white-space: pre-wrap;
            font-size: 12px;
            opacity: 0.75;
            margin-top: 8px;
        }
    </style>
</head>
<body>
    <header>
        <h1>Enterprise RC 2026 — Smoke Tests</h1>
        <div class="controls">
            <button id="runBtn" type="button">Run Tests</button>
            <button id="reloadBtn" type="button">Reload App</button>
        </div>
    </header>
    <div class="grid">
        <div class="panel">
            <div id="results"></div>
            <div class="summary" id="summary">Idle.</div>
            <div class="log" id="log"></div>
        </div>
        <iframe id="appFrame" title="App Under Test" src="../index.html"></iframe>
    </div>

    <script>
        const resultsEl = document.getElementById("results");
        const summaryEl = document.getElementById("summary");
        const logEl = document.getElementById("log");
        const runBtn = document.getElementById("runBtn");
        const reloadBtn = document.getElementById("reloadBtn");
        const iframe = document.getElementById("appFrame");

        let logLines = [];

        function log(message) {
            logLines.push(message);
            logEl.textContent = logLines.join("\n");
        }

        function addResult(name, status, detail) {
            const row = document.createElement("div");
            row.className = "result";
            row.innerHTML = `<div>${name}</div><div class="status ${status}">${status}</div>`;
            if (detail) {
                row.title = detail;
            }
            resultsEl.appendChild(row);
        }

        function resetResults() {
            resultsEl.innerHTML = "";
            logLines = [];
            logEl.textContent = "";
        }

        function waitFor(predicate, timeout = 3000, interval = 50) {
            return new Promise((resolve, reject) => {
                const start = Date.now();
                const timer = setInterval(() => {
                    if (predicate()) {
                        clearInterval(timer);
                        resolve(true);
                        return;
                    }
                    if (Date.now() - start > timeout) {
                        clearInterval(timer);
                        reject(new Error("Timeout"));
                    }
                }, interval);
            });
        }

        function safeParseJSON(raw) {
            if (!raw) return null;
            try {
                return JSON.parse(raw);
            } catch {
                return null;
            }
        }

        async function readSettings(win) {
            try {
                if (!("indexedDB" in win)) return null;
                return await new Promise(resolve => {
                    const req = win.indexedDB.open("MehicSalesOS_DB", 2);
                    req.onerror = () => resolve(null);
                    req.onupgradeneeded = () => resolve(null);
                    req.onsuccess = () => {
                        const db = req.result;
                        if (!db.objectStoreNames.contains("settings")) {
                            resolve(null);
                            return;
                        }
                        const tx = db.transaction("settings", "readonly");
                        const getReq = tx.objectStore("settings").get("main");
                        getReq.onsuccess = () => resolve(getReq.result || null);
                        getReq.onerror = () => resolve(null);
                    };
                });
            } catch (error) {
                return null;
            }
        }

        async function getSetting(win, key) {
            const settings = await readSettings(win);
            if (settings && key in settings) return settings[key];
            const raw = win.localStorage.getItem("msos_settings");
            const local = safeParseJSON(raw);
            return local ? local[key] : null;
        }

        async function runTest(name, fn) {
            try {
                await fn();
                addResult(name, "PASS");
                return true;
            } catch (error) {
                if (error && error.warn) {
                    addResult(name, "WARN", error.message);
                    log(`${name} — WARN: ${error.message}`);
                    return false;
                }
                addResult(name, "FAIL", error.message);
                log(`${name} — FAIL: ${error.message}`);
                return false;
            }
        }

        async function runTests() {
            resetResults();
            summaryEl.textContent = "Running...";
            const win = iframe.contentWindow;
            const doc = win.document;

            await waitFor(() => doc.getElementById("buildInfo") && doc.getElementById("buildInfo").textContent.trim().length > 0, 5000);

            let passCount = 0;
            let failCount = 0;

            const themeCycle = await runTest("Theme cycle + persist", async () => {
                const toggle = doc.getElementById("themeToggleBtn");
                const before = await getSetting(win, "themeMode") || "auto";
                const cycle = ["auto", "light", "dark"];
                const expected = cycle[(cycle.indexOf(before) + 1) % cycle.length];
                toggle.click();
                await waitFor(() => doc.documentElement.getAttribute("data-theme"), 1500);
                const after = await getSetting(win, "themeMode");
                if (after !== expected) {
                    throw new Error(`Expected ${expected}, got ${after}`);
                }
            });
            themeCycle ? passCount++ : failCount++;

            const densityTest = await runTest("Density toggle + persist", async () => {
                const toggle = doc.getElementById("densityToggleBtn");
                const before = await getSetting(win, "densityMode") || doc.documentElement.getAttribute("data-density");
                const expected = before === "compact" ? "comfortable" : "compact";
                toggle.click();
                await waitFor(() => doc.documentElement.getAttribute("data-density") === expected, 1500);
                const after = await getSetting(win, "densityMode");
                if (after && after !== expected) {
                    throw new Error(`Expected ${expected}, got ${after}`);
                }
            });
            densityTest ? passCount++ : failCount++;

            const modalTest = await runTest("Modal open/close via button + Esc", async () => {
                const settingsBtn = doc.getElementById("settingsBtn");
                const modal = doc.getElementById("settingsModal");
                settingsBtn.click();
                await waitFor(() => modal.classList.contains("open"), 1500);
                doc.dispatchEvent(new win.KeyboardEvent("keydown", { key: "Escape" }));
                await waitFor(() => !modal.classList.contains("open"), 1500);
            });
            modalTest ? passCount++ : failCount++;

            const focusTest = await runTest("Focus returns to trigger", async () => {
                const settingsBtn = doc.getElementById("settingsBtn");
                const modal = doc.getElementById("settingsModal");
                settingsBtn.focus();
                settingsBtn.click();
                await waitFor(() => modal.classList.contains("open"), 1500);
                doc.dispatchEvent(new win.KeyboardEvent("keydown", { key: "Escape" }));
                await waitFor(() => !modal.classList.contains("open"), 1500);
                await waitFor(() => doc.activeElement === settingsBtn, 1500);
            });
            focusTest ? passCount++ : failCount++;

            const backTest = await runTest("Back button closes modal", async () => {
                const settingsBtn = doc.getElementById("settingsBtn");
                const modal = doc.getElementById("settingsModal");
                const initialLength = win.history.length;
                settingsBtn.click();
                await waitFor(() => modal.classList.contains("open"), 1500);
                const afterOpenLength = win.history.length;
                win.history.back();
                await waitFor(() => !modal.classList.contains("open"), 1500);
                const afterCloseLength = win.history.length;
                if (afterOpenLength > initialLength + 1) {
                    throw new Error("History spam detected");
                }
                if (afterCloseLength > afterOpenLength) {
                    throw new Error("History length increased after close");
                }
            });
            backTest ? passCount++ : failCount++;

            const offlineTest = await runTest("Offline indicator toggles", async () => {
                const banner = doc.getElementById("offlineBanner");
                let mockOk = false;
                try {
                    Object.defineProperty(win.navigator, "onLine", { value: false, configurable: true });
                    mockOk = win.navigator.onLine === false;
                } catch (error) {
                    mockOk = false;
                }
                if (!mockOk) {
                    const warn = new Error("navigator.onLine not overridable in this browser");
                    warn.warn = true;
                    throw warn;
                }
                win.dispatchEvent(new win.Event("offline"));
                await waitFor(() => banner.classList.contains("show"), 1500);
                Object.defineProperty(win.navigator, "onLine", { value: true, configurable: true });
                win.dispatchEvent(new win.Event("online"));
                await waitFor(() => !banner.classList.contains("show"), 1500);
            });
            offlineTest ? passCount++ : failCount++;

            const importTest = await runTest("Import rejects invalid JSON", async () => {
                const settingsBtn = doc.getElementById("settingsBtn");
                const modal = doc.getElementById("settingsModal");
                const input = doc.getElementById("importFile");
                const toast = doc.getElementById("toast");

                if (!modal.classList.contains("open")) {
                    settingsBtn.click();
                    await waitFor(() => modal.classList.contains("open"), 1500);
                }

                const file = new win.File(['{ "bad": '], "invalid.json", { type: "application/json" });
                if (win.DataTransfer) {
                    const dt = new win.DataTransfer();
                    dt.items.add(file);
                    input.files = dt.files;
                } else {
                    Object.defineProperty(input, "files", { value: [file], configurable: true });
                }
                input.dispatchEvent(new win.Event("change", { bubbles: true }));

                const confirmModal = doc.getElementById("confirmModal");
                await waitFor(() => confirmModal.classList.contains("open"), 1500);
                const confirmBtn = doc.getElementById("confirmConfirmBtn");
                confirmBtn.click();
                await waitFor(() => toast.textContent.includes("Import fehlgeschlagen"), 2000);
            });
            importTest ? passCount++ : failCount++;

            summaryEl.textContent = `Done. PASS: ${passCount}, FAIL: ${failCount}.`;
        }

        runBtn.addEventListener("click", () => {
            runTests().catch(error => {
                summaryEl.textContent = `Runner error: ${error.message}`;
            });
        });

        reloadBtn.addEventListener("click", () => {
            iframe.src = "../index.html";
        });
    </script>
</body>
</html>
