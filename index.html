<!DOCTYPE html>
<html lang="de" data-theme="auto" data-density="comfortable">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="color-scheme" content="light dark">
    <meta name="theme-color" content="#F3F4F6" id="themeColorMeta">
    <meta name="referrer" content="no-referrer">
    <title>MEHIC SALES OS ENTERPRISE v2.0 (2026)</title>
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self';
        base-uri 'self';
        object-src 'none';
        form-action 'self';
        frame-ancestors 'none';
        upgrade-insecure-requests;
        img-src 'self' data:;
        font-src 'self' https://fonts.gstatic.com;
        style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
        script-src 'self' 'unsafe-inline';
        connect-src 'self' https:;
    ">
    <!--
        CSP Strategie (2026):
        Level 1 (lokal, Single-File): Die Meta-CSP oben nutzt 'unsafe-inline' für <style> und <script>.
        Level 2 (Enterprise Deploy): 'unsafe-inline' entfernen und Hashes der Inline-Blöcke verwenden.
        Hash-Prozess (exakt):
        1) Inhalt des <style> Blocks in style.txt speichern (ohne <style> Tags).
        2) openssl dgst -sha256 -binary style.txt | openssl base64 -A
        3) Ergebnis als 'sha256-...' in style-src aufnehmen.
        4) Inhalt des <script> Blocks in script.txt speichern (ohne <script> Tags).
        5) openssl dgst -sha256 -binary script.txt | openssl base64 -A
        6) Ergebnis als 'sha256-...' in script-src aufnehmen.
        Beispiel (Server-Header): Content-Security-Policy: default-src 'self'; ...; style-src 'self' 'sha256-...'; script-src 'self' 'sha256-...';
        Proxy Hinweis: Bei Proxy-Nutzung den konkreten Proxy-Host in connect-src erlauben.
        Hinweis: frame-ancestors wirkt nur als HTTP-Header, nicht als Meta-Tag.
    -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        :root {
            --font-family-base: "Inter", -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --font-family-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, "Courier New", monospace;
            --font-feature-settings: "tnum" 1, "ss01" 1;
            --motion-ease-standard: cubic-bezier(0.22, 1, 0.36, 1);
            --motion-fast: 120ms;
            --motion-medium: 220ms;
            --motion-slow: 360ms;
            --radius-sm: 10px;
            --radius-md: 14px;
            --radius-lg: 20px;
            --radius-xl: 26px;
            --density-scale: 1;
            --safe-top: env(safe-area-inset-top, 0px);
            --safe-right: env(safe-area-inset-right, 0px);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
            --safe-left: env(safe-area-inset-left, 0px);
            --space-1: calc(6px * var(--density-scale));
            --space-2: calc(8px * var(--density-scale));
            --space-3: calc(12px * var(--density-scale));
            --space-4: calc(16px * var(--density-scale));
            --space-5: calc(20px * var(--density-scale));
            --space-6: calc(24px * var(--density-scale));
            --space-7: calc(28px * var(--density-scale));
            --space-8: calc(32px * var(--density-scale));
            --tap-size: 48px;
            --control-height: 48px;
            --card-padding: 28px;
            --keyboard-offset: 0px;
            --control-bar-height: 200px;
            --color-bg: #F3F4F6;
            --color-surface: #FFFFFF;
            --color-elevated: #FFFFFF;
            --color-border: rgba(0, 0, 0, 0.06);
            --color-divider: rgba(17, 24, 39, 0.08);
            --color-text: #111827;
            --color-text-secondary: #6B7280;
            --color-text-muted: #9CA3AF;
            --color-accent: #E3000F;
            --color-danger: #DC2626;
            --color-warning: #F59E0B;
            --color-success: #10B981;
            --color-glass: rgba(255, 255, 255, 0.72);
            --color-glass-border: rgba(0, 0, 0, 0.08);
            --color-modal-backdrop: rgba(3, 7, 18, 0.45);
            --color-toast-bg: #111827;
            --color-toast-text: #FFFFFF;
            --color-on-accent: #FFFFFF;
            --color-selection: rgba(227, 0, 15, 0.18);
            --color-hover: rgba(0, 0, 0, 0.04);
            --color-pressed: rgba(0, 0, 0, 0.08);
            --color-scrollbar-thumb: rgba(17, 24, 39, 0.2);
            --color-scrollbar-track: rgba(17, 24, 39, 0.06);
            --color-chip-bg: #FFFFFF;
            --color-chip-border: rgba(0, 0, 0, 0.08);
            --color-chip-active-text: #FFFFFF;
            --color-input-bg: #FFFFFF;
            --color-input-border: rgba(0, 0, 0, 0.08);
            --color-skeleton-base: #E5E7EB;
            --color-skeleton-shine: #F3F4F6;
            --color-stealth-bg: rgba(0, 0, 0, 0.92);
            --color-stealth-icon: #444;
            --color-stealth-text: #666;
            --gradient-accent: linear-gradient(135deg, #E3000F, #C70010);
            --gradient-success: linear-gradient(135deg, #10B981, #059669);
            --gradient-warning: linear-gradient(135deg, #F59E0B, #D97706);
            --shadow-1: 0 8px 24px rgba(0, 0, 0, 0.12);
            --shadow-2: 0 16px 40px rgba(0, 0, 0, 0.14);
            --shadow-3: 0 24px 60px rgba(0, 0, 0, 0.16);
            --focus-ring: 0 0 0 3px rgba(227, 0, 15, 0.35);
            --focus-ring-offset: 2px;
        }

        :root[data-density="compact"] {
            --density-scale: 0.92;
            --tap-size: 44px;
            --control-height: 44px;
            --card-padding: 22px;
        }

        :root[data-density="comfortable"] {
            --density-scale: 1.05;
            --tap-size: 48px;
            --control-height: 48px;
            --card-padding: 28px;
        }

        :root[data-theme="dark"] {
            --color-bg: #09090B;
            --color-surface: #18181B;
            --color-elevated: #1F1F23;
            --color-border: #27272A;
            --color-divider: #2F2F35;
            --color-text: #FAFAFA;
            --color-text-secondary: #A1A1AA;
            --color-text-muted: #71717A;
            --color-accent: #E3000F;
            --color-danger: #EF4444;
            --color-warning: #FBBF24;
            --color-success: #34D399;
            --color-glass: rgba(24, 24, 27, 0.7);
            --color-glass-border: rgba(255, 255, 255, 0.08);
            --color-modal-backdrop: rgba(2, 2, 4, 0.6);
            --color-toast-bg: #0B0B0F;
            --color-toast-text: #FAFAFA;
            --color-on-accent: #FFFFFF;
            --color-selection: rgba(227, 0, 15, 0.3);
            --color-hover: rgba(255, 255, 255, 0.06);
            --color-pressed: rgba(255, 255, 255, 0.12);
            --color-scrollbar-thumb: rgba(250, 250, 250, 0.2);
            --color-scrollbar-track: rgba(250, 250, 250, 0.05);
            --color-chip-bg: #18181B;
            --color-chip-border: #27272A;
            --color-chip-active-text: #FAFAFA;
            --color-input-bg: #18181B;
            --color-input-border: #2F2F35;
            --color-skeleton-base: #27272A;
            --color-skeleton-shine: #3F3F46;
            --color-stealth-icon: #3F3F46;
            --color-stealth-text: #71717A;
            --shadow-1: 0 8px 20px rgba(0, 0, 0, 0.45);
            --shadow-2: 0 16px 40px rgba(0, 0, 0, 0.55);
            --shadow-3: 0 24px 60px rgba(0, 0, 0, 0.65);
            --focus-ring: 0 0 0 3px rgba(227, 0, 15, 0.45);
        }

        @media (prefers-color-scheme: dark) {
            :root[data-theme="auto"] {
                --color-bg: #09090B;
                --color-surface: #18181B;
                --color-elevated: #1F1F23;
                --color-border: #27272A;
                --color-divider: #2F2F35;
                --color-text: #FAFAFA;
                --color-text-secondary: #A1A1AA;
                --color-text-muted: #71717A;
                --color-accent: #E3000F;
                --color-danger: #EF4444;
                --color-warning: #FBBF24;
                --color-success: #34D399;
                --color-glass: rgba(24, 24, 27, 0.7);
                --color-glass-border: rgba(255, 255, 255, 0.08);
                --color-modal-backdrop: rgba(2, 2, 4, 0.6);
                --color-toast-bg: #0B0B0F;
                --color-toast-text: #FAFAFA;
                --color-on-accent: #FFFFFF;
                --color-selection: rgba(227, 0, 15, 0.3);
                --color-hover: rgba(255, 255, 255, 0.06);
                --color-pressed: rgba(255, 255, 255, 0.12);
                --color-scrollbar-thumb: rgba(250, 250, 250, 0.2);
                --color-scrollbar-track: rgba(250, 250, 250, 0.05);
                --color-chip-bg: #18181B;
                --color-chip-border: #27272A;
                --color-chip-active-text: #FAFAFA;
                --color-input-bg: #18181B;
                --color-input-border: #2F2F35;
                --color-skeleton-base: #27272A;
                --color-skeleton-shine: #3F3F46;
                --color-stealth-icon: #3F3F46;
                --color-stealth-text: #71717A;
                --shadow-1: 0 8px 20px rgba(0, 0, 0, 0.45);
                --shadow-2: 0 16px 40px rgba(0, 0, 0, 0.55);
                --shadow-3: 0 24px 60px rgba(0, 0, 0, 0.65);
                --focus-ring: 0 0 0 3px rgba(227, 0, 15, 0.45);
            }
        }

        html, body { height: 100%; }
        body {
            font-family: var(--font-family-base);
            font-feature-settings: var(--font-feature-settings);
            font-variant-numeric: tabular-nums;
            background: var(--color-bg);
            color: var(--color-text);
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overflow-x: hidden;
            overscroll-behavior-y: contain;
            min-height: 100vh;
            height: 100dvh;
            display: flex;
            flex-direction: column;
        }

        ::selection { background: var(--color-selection); color: var(--color-text); }
        button, input, select, textarea { font-family: inherit; color: inherit; }
        button { background: none; border: none; cursor: pointer; }
        button:disabled { cursor: not-allowed; opacity: 0.6; }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        :focus-visible {
            outline: 2px solid transparent;
            outline-offset: var(--focus-ring-offset);
            box-shadow: var(--focus-ring);
        }

        .header {
            position: sticky;
            top: 0;
            z-index: 100;
            background: var(--color-glass);
            border-bottom: 1px solid var(--color-glass-border);
            backdrop-filter: blur(16px) saturate(140%);
            -webkit-backdrop-filter: blur(16px) saturate(140%);
            padding: calc(var(--space-4) + var(--safe-top)) calc(var(--space-4) + var(--safe-right)) var(--space-3) calc(var(--space-4) + var(--safe-left));
            user-select: none;
        }

        .header-inner {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--space-4);
            max-width: 1320px;
            margin: 0 auto;
        }

        .logo-container {
            display: flex;
            align-items: center;
            gap: var(--space-3);
        }

        .logo-svg { width: 44px; height: 44px; color: var(--color-accent); }

        .logo-text {
            font-size: 20px;
            font-weight: 800;
            letter-spacing: -0.5px;
            color: var(--color-text);
        }

        .logo-text span { font-weight: 300; color: var(--color-text-secondary); }

        .header-right {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .status-pill {
            display: inline-flex;
            align-items: center;
            gap: var(--space-2);
            min-height: var(--tap-size);
            padding: 0 var(--space-3);
            border-radius: 999px;
            border: 1px solid var(--color-border);
            background: var(--color-elevated);
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.6px;
            color: var(--color-text-secondary);
        }

        .status-pill::before {
            content: "";
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--color-success);
        }

        .status-pill[data-status="offline"]::before { background: var(--color-danger); }
        .status-pill[data-status="syncing"]::before { background: var(--color-warning); }

        .dept-badge {
            padding: 0 var(--space-3);
            min-height: var(--tap-size);
            display: inline-flex;
            align-items: center;
            background: var(--gradient-accent);
            color: var(--color-on-accent);
            border-radius: 999px;
            font-size: 12px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: var(--shadow-1);
        }

        .toggle-btn {
            display: inline-flex;
            align-items: center;
            gap: var(--space-2);
            min-height: var(--tap-size);
            padding: 0 var(--space-3);
            border-radius: 999px;
            border: 1px solid var(--color-border);
            background: var(--color-elevated);
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.6px;
            color: var(--color-text-secondary);
            transition: background var(--motion-medium) var(--motion-ease-standard);
        }

        .toggle-icon {
            width: 16px;
            height: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .toggle-icon svg {
            width: 16px;
            height: 16px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2.2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .icon-btn {
            width: var(--tap-size);
            height: var(--tap-size);
            border-radius: 12px;
            border: 1px solid var(--color-border);
            background: var(--color-elevated);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: transform var(--motion-medium) var(--motion-ease-standard), background var(--motion-medium) var(--motion-ease-standard);
        }

        .icon-btn svg {
            width: 20px;
            height: 20px;
            stroke: var(--color-text);
            fill: none;
            stroke-width: 2.2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .stealth-overlay {
            position: fixed;
            inset: 0;
            background: var(--color-stealth-bg);
            z-index: 9999;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: var(--space-4);
            backdrop-filter: blur(12px);
        }

        .stealth-overlay.active { display: flex; }

        .stealth-icon {
            width: 80px;
            height: 80px;
            stroke: var(--color-stealth-icon);
            stroke-width: 1.5;
            animation: pulse 2s infinite;
        }

        .stealth-text {
            font-size: 18px;
            font-weight: 700;
            color: var(--color-stealth-text);
            letter-spacing: 1px;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.6; }
        }

        .stage {
            flex: 1;
            overflow-y: auto;
            padding: var(--space-6) calc(var(--space-4) + var(--safe-right)) calc(var(--control-bar-height) + var(--keyboard-offset)) calc(var(--space-4) + var(--safe-left));
            overscroll-behavior: contain;
        }

        .stage-inner {
            max-width: 1320px;
            margin: 0 auto;
        }

        .stage::-webkit-scrollbar { width: 10px; }
        .stage::-webkit-scrollbar-track { background: var(--color-scrollbar-track); }
        .stage::-webkit-scrollbar-thumb { background: var(--color-scrollbar-thumb); border-radius: 999px; }
        .stage { scrollbar-color: var(--color-scrollbar-thumb) var(--color-scrollbar-track); }

        .cards-grid {
            display: grid;
            grid-template-columns: repeat(1, minmax(0, 1fr));
            gap: var(--space-4);
            grid-auto-flow: dense;
        }

        @media (min-width: 640px) {
            .cards-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
        }

        @media (min-width: 1024px) {
            .cards-grid { grid-template-columns: repeat(3, minmax(0, 1fr)); }
            .card.bento-hero { grid-column: span 2; }
            .card.bento-tall { grid-row: span 2; }
        }

        @media (min-width: 1280px) {
            .cards-grid { grid-template-columns: repeat(4, minmax(0, 1fr)); }
        }

        .card {
            background: var(--color-surface);
            border-radius: var(--radius-lg);
            padding: var(--card-padding);
            box-shadow: var(--shadow-2);
            border: 1px solid var(--color-border);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            gap: var(--space-4);
            animation: cardAppear var(--motion-slow) var(--motion-ease-standard);
        }

        .card::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 5px;
            height: 100%;
            background: var(--gradient-accent);
        }

        .card.success::before { background: var(--gradient-success); }
        .card.warning::before { background: var(--gradient-warning); }
        .card.error::before { background: var(--gradient-accent); }

        @keyframes cardAppear {
            from { opacity: 0; transform: translateY(18px) scale(0.98); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        .card-header {
            display: flex;
            align-items: center;
            gap: var(--space-3);
        }

        .card-icon {
            width: 28px;
            height: 28px;
            stroke: var(--color-accent);
            fill: none;
            stroke-width: 2;
        }

        .card-title {
            font-size: 14px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            color: var(--color-text-secondary);
        }

        .quick-cues {
            display: grid;
            gap: var(--space-3);
        }

        .card-badge {
            margin-left: auto;
            padding: 4px 10px;
            background: var(--color-bg);
            border-radius: 999px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            color: var(--color-text-secondary);
            border: 1px solid var(--color-border);
        }

        .cue-block { display: flex; flex-direction: column; gap: var(--space-2); }
        .cue-label {
            font-size: 11px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            color: var(--color-text-secondary);
        }

        .cue-text {
            font-size: 15px;
            line-height: 1.7;
            color: var(--color-text);
            font-weight: 500;
        }

        .cue-text.anchor { font-weight: 800; }
        .cue-text.question { font-style: italic; font-weight: 600; }
        .cue-text.bridge { color: var(--color-text-secondary); font-weight: 600; }
        .cue-text.close { color: var(--color-text-secondary); font-weight: 600; }

        .expandable {
            border-top: 1px solid var(--color-divider);
            padding-top: var(--space-3);
            display: flex;
            flex-direction: column;
            gap: var(--space-2);
        }

        .expand-trigger {
            display: flex;
            align-items: center;
            justify-content: space-between;
            min-height: var(--tap-size);
            padding: 0;
            background: transparent;
            color: var(--color-text);
            font-weight: 700;
        }

        .expand-label {
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.6px;
        }

        .expand-icon {
            width: 20px;
            height: 20px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2.2;
            transition: transform var(--motion-medium) var(--motion-ease-standard);
        }

        .expand-icon.open { transform: rotate(180deg); }

        .expand-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height var(--motion-slow) var(--motion-ease-standard);
        }

        .expand-content.open { padding-top: var(--space-3); }

        .coach-block { display: flex; flex-direction: column; gap: var(--space-1); }
        .coach-label {
            font-size: 12px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 0.6px;
            color: var(--color-accent);
        }

        .coach-text { font-size: 14px; line-height: 1.6; color: var(--color-text); }
        .drill-list { padding-left: 18px; font-size: 14px; line-height: 1.6; color: var(--color-text); }
        .drill-list li { margin-bottom: 6px; }

        .card-actions {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: var(--space-3);
            margin-top: var(--space-2);
            padding-top: var(--space-3);
            border-top: 1px solid var(--color-divider);
        }

        .feedback-btn {
            min-height: var(--tap-size);
            border-radius: 12px;
            border: 1px solid var(--color-border);
            background: transparent;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-2);
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.6px;
            color: var(--color-text-secondary);
            transition: transform var(--motion-medium) var(--motion-ease-standard), background var(--motion-medium) var(--motion-ease-standard);
        }

        .feedback-btn.success { border-color: var(--color-success); color: var(--color-success); }
        .feedback-btn.error { border-color: var(--color-accent); color: var(--color-accent); }

        .feedback-btn svg {
            width: 16px;
            height: 16px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2.2;
        }

        .control-bar {
            position: fixed;
            bottom: var(--keyboard-offset);
            left: 0;
            right: 0;
            z-index: 200;
            background: var(--color-glass);
            border-top: 1px solid var(--color-glass-border);
            backdrop-filter: blur(18px) saturate(140%);
            -webkit-backdrop-filter: blur(18px) saturate(140%);
            padding: var(--space-4) calc(var(--space-4) + var(--safe-right)) calc(var(--space-4) + var(--safe-bottom)) calc(var(--space-4) + var(--safe-left));
            box-shadow: var(--shadow-2);
            transition: bottom var(--motion-fast) var(--motion-ease-standard);
        }

        .control-inner {
            max-width: 1320px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: var(--space-3);
        }

        .context-chips {
            display: flex;
            gap: var(--space-2);
            overflow-x: auto;
            padding-bottom: var(--space-1);
            scrollbar-width: none;
        }

        .offline-hint {
            font-size: 12px;
            font-weight: 700;
            color: var(--color-warning);
            text-transform: uppercase;
            letter-spacing: 0.6px;
        }

        .context-chips::-webkit-scrollbar { display: none; }

        .chip {
            min-height: var(--tap-size);
            padding: 0 var(--space-4);
            border-radius: 999px;
            border: 2px solid var(--color-chip-border);
            background: var(--color-chip-bg);
            font-size: 13px;
            font-weight: 700;
            display: inline-flex;
            align-items: center;
            gap: var(--space-2);
            white-space: nowrap;
            transition: background var(--motion-medium) var(--motion-ease-standard), transform var(--motion-medium) var(--motion-ease-standard);
            color: var(--color-text);
        }

        .chip svg {
            width: 16px;
            height: 16px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2.2;
        }

        .chip.active {
            background: var(--gradient-accent);
            border-color: transparent;
            color: var(--color-chip-active-text);
        }

        .input-area {
            display: flex;
            gap: var(--space-3);
            align-items: center;
        }

        .input-field {
            flex: 1;
            min-height: var(--tap-size);
            padding: 0 var(--space-4);
            background: var(--color-input-bg);
            border: 2px solid var(--color-input-border);
            border-radius: var(--radius-md);
            font-size: 16px;
            font-weight: 500;
            transition: border var(--motion-medium) var(--motion-ease-standard);
        }

        .input-field::placeholder { color: var(--color-text-muted); }

        .mic-fab {
            width: calc(var(--tap-size) + 8px);
            height: calc(var(--tap-size) + 8px);
            border-radius: 50%;
            background: var(--gradient-accent);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow-2);
            transition: transform var(--motion-medium) var(--motion-ease-standard);
        }

        .mic-fab.processing {
            background: var(--gradient-warning);
            animation: pulse 1s infinite;
        }

        .mic-fab svg {
            width: 22px;
            height: 22px;
            stroke: var(--color-on-accent);
            fill: none;
            stroke-width: 2.2;
        }

        body.modal-open #appShell { pointer-events: none; }
        body.modal-open { overflow: hidden; }

        .modal {
            display: none;
            position: fixed;
            inset: 0;
            background: var(--color-modal-backdrop);
            backdrop-filter: blur(8px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: var(--space-4);
        }

        .modal.open { display: flex; }

        .modal-content {
            background: var(--color-elevated);
            border-radius: var(--radius-lg);
            padding: var(--space-6);
            width: 100%;
            max-width: 560px;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: var(--shadow-3);
            border: 1px solid var(--color-border);
        }

        .confirm-message {
            font-size: 14px;
            color: var(--color-text-secondary);
            margin-bottom: var(--space-4);
        }

        .lock-panel {
            border: 1px solid var(--color-border);
            background: var(--color-surface);
            border-radius: var(--radius-md);
            padding: var(--space-4);
            margin-bottom: var(--space-4);
        }

        .lock-panel[hidden] { display: none; }

        .lock-text {
            font-size: 14px;
            font-weight: 600;
            color: var(--color-text);
            margin-bottom: var(--space-2);
        }

        .settings-body[aria-hidden="true"] {
            opacity: 0.4;
            pointer-events: none;
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--space-3);
            margin-bottom: var(--space-4);
        }

        .modal-title { font-size: 22px; font-weight: 800; }

        .form-group { margin-bottom: var(--space-4); }
        .form-label {
            display: block;
            font-size: 12px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 0.7px;
            margin-bottom: var(--space-2);
            color: var(--color-text-secondary);
        }

        .form-input, .form-select, .form-textarea {
            width: 100%;
            min-height: var(--tap-size);
            padding: 0 var(--space-3);
            background: var(--color-input-bg);
            border: 2px solid var(--color-input-border);
            border-radius: var(--radius-md);
            font-size: 15px;
            outline: none;
            transition: border var(--motion-medium) var(--motion-ease-standard);
        }

        .form-textarea {
            min-height: 92px;
            padding: var(--space-3);
            resize: vertical;
        }

        .field-hint {
            margin-top: var(--space-2);
            font-size: 12px;
            color: var(--color-text-muted);
        }

        .btn-group { display: flex; gap: var(--space-3); flex-wrap: wrap; }

        .btn {
            flex: 1;
            min-height: var(--tap-size);
            padding: 0 var(--space-4);
            border-radius: 12px;
            font-size: 13px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 0.6px;
            border: 1px solid var(--color-border);
            transition: transform var(--motion-medium) var(--motion-ease-standard), background var(--motion-medium) var(--motion-ease-standard);
        }

        .btn-primary { background: var(--gradient-accent); color: var(--color-on-accent); border: none; }
        .btn-secondary { background: var(--color-surface); color: var(--color-text); }
        .btn-danger { background: var(--color-danger); color: var(--color-on-accent); border: none; }

        #clearBtn.active { transform: scale(0.98); filter: brightness(0.96); }

        .toast {
            position: fixed;
            bottom: calc(var(--control-bar-height) + var(--space-4));
            left: 50%;
            transform: translateX(-50%) translateY(16px);
            background: var(--color-toast-bg);
            color: var(--color-toast-text);
            padding: var(--space-3) var(--space-4);
            border-radius: 14px;
            opacity: 0;
            pointer-events: none;
            transition: opacity var(--motion-medium) var(--motion-ease-standard), transform var(--motion-medium) var(--motion-ease-standard);
            z-index: 3000;
            font-weight: 700;
            box-shadow: var(--shadow-3);
        }

        .toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }

        .loading {
            display: grid;
            gap: var(--space-3);
        }

        .skeleton {
            background: var(--color-skeleton-base);
            border-radius: var(--radius-lg);
            padding: var(--card-padding);
            position: relative;
            overflow: hidden;
            min-height: 200px;
        }

        .skeleton::after {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(120deg, transparent, var(--color-skeleton-shine), transparent);
            transform: translateX(-100%);
            animation: shine 1.2s infinite;
        }

        @keyframes shine {
            from { transform: translateX(-100%); }
            to { transform: translateX(100%); }
        }

        .empty-state, .error-state {
            text-align: center;
            padding: 80px var(--space-4);
            color: var(--color-text-secondary);
        }

        .empty-state h3, .error-state h3 {
            font-size: 22px;
            font-weight: 800;
            color: var(--color-text);
            margin-bottom: var(--space-2);
        }

        .footer {
            text-align: center;
            padding: var(--space-4);
            font-size: 12px;
            color: var(--color-text-muted);
            background: var(--color-surface);
            border-top: 1px solid var(--color-divider);
        }

        .build-info { margin-top: var(--space-1); font-size: 10px; font-family: var(--font-family-mono); opacity: 0.7; }

        @media (hover: hover) {
            .icon-btn:hover, .toggle-btn:hover, .chip:hover, .btn:not(.btn-primary):not(.btn-danger):hover, .feedback-btn:hover {
                transform: translateY(-1px);
                background: var(--color-hover);
            }
            .mic-fab:hover { transform: translateY(-1px); filter: brightness(1.05); }
            .btn-primary:hover, .btn-danger:hover { filter: brightness(1.05); }
        }

        .icon-btn:active, .toggle-btn:active, .chip:active, .feedback-btn:active, .btn-secondary:active {
            background: var(--color-pressed);
            transform: translateY(0);
        }

        .btn-primary:active, .btn-danger:active, .mic-fab:active { transform: translateY(0) scale(0.98); filter: brightness(0.98); }

        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.001ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.001ms !important;
                scroll-behavior: auto !important;
            }
        }
    </style>
</head>
<body>
    <div id="appShell">
        <div class="stealth-overlay" id="stealthOverlay" aria-hidden="true">
            <svg class="stealth-icon" viewBox="0 0 24 24" fill="none">
                <rect x="2" y="2" width="20" height="20" rx="2"/>
                <line x1="7" y1="12" x2="17" y2="12"/>
            </svg>
            <div class="stealth-text">SYSTEM STANDBY</div>
        </div>

        <header class="header" id="header">
            <div class="header-inner">
                <div class="logo-container">
                    <svg class="logo-svg" viewBox="0 0 100 100" fill="none">
                        <path d="M20 80 L20 20 L50 50 L80 20 L80 80" stroke="currentColor" stroke-width="8" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    <div class="logo-text">MEHIC SALES <span>OS</span></div>
                </div>
                <div class="header-right">
                    <div class="status-pill" id="statusPill" role="status" aria-live="polite" data-status="online">Online</div>
                    <div class="dept-badge" id="deptBadge">TV</div>
                    <button class="toggle-btn" id="themeToggle" type="button" aria-live="polite" aria-label="Theme: Auto">
                        <span class="toggle-icon">
                            <svg viewBox="0 0 24 24"><path d="M12 3a9 9 0 1 0 9 9"/><path d="M12 3v6"/></svg>
                        </span>
                        <span class="toggle-label" id="themeLabel">Auto</span>
                    </button>
                    <button class="toggle-btn" id="densityToggle" type="button" aria-live="polite" aria-label="Dichte: Komfortabel">
                        <span class="toggle-icon">
                            <svg viewBox="0 0 24 24"><path d="M4 7h16M4 12h16M4 17h16"/></svg>
                        </span>
                        <span class="toggle-label" id="densityLabel">Komfortabel</span>
                    </button>
                    <button class="icon-btn" id="resetBtn" type="button" aria-label="Zurücksetzen">
                        <svg viewBox="0 0 24 24"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/></svg>
                    </button>
                    <button class="icon-btn" id="settingsBtn" type="button" aria-label="Einstellungen">
                        <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="3"/><path d="M12 1v6m0 6v6"/></svg>
                    </button>
                </div>
            </div>
        </header>

        <main class="stage" id="stage">
            <div class="stage-inner">
                <div id="cardsContainer"></div>
            </div>
        </main>

        <div class="control-bar" id="controlBar">
            <div class="control-inner">
                <div class="context-chips" id="contextChips" role="group" aria-label="Kontextchips">
                    <button class="chip" data-context="hurry" type="button" aria-pressed="false">
                        <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>Eilig
                    </button>
                    <button class="chip" data-context="duo" type="button" aria-pressed="false">
                        <svg viewBox="0 0 24 24"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/></svg>Paar
                    </button>
                    <button class="chip" data-context="easy" type="button" aria-pressed="false">
                        <svg viewBox="0 0 24 24"><path d="M12 2v20M2 12h20"/></svg>Einfach
                    </button>
                    <button class="chip" data-context="techie" type="button" aria-pressed="false">
                        <svg viewBox="0 0 24 24"><rect x="2" y="3" width="20" height="14" rx="2"/><path d="M8 21h8"/></svg>Techie
                    </button>
                </div>
                <div class="offline-hint" id="offlineHint" role="status" aria-live="polite" hidden>Offline: Nur lokale Daten</div>
                <div class="input-area">
                    <label class="sr-only" for="objectionInput">Einwand</label>
                    <input type="text" class="input-field" id="objectionInput" placeholder="Einwand eingeben..." autocomplete="off" inputmode="text" />
                    <button class="mic-fab" id="micBtn" type="button" aria-label="Mikrofon starten">
                        <svg viewBox="0 0 24 24"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/></svg>
                    </button>
                </div>
            </div>
        </div>
        <div class="footer">
            © 2026 Enes Mehic. <div class="build-info" id="buildInfo"></div>
        </div>
    </div>

    <div class="toast" id="toast" role="alert" aria-live="polite"></div>

    <div class="modal" id="settingsModal" role="dialog" aria-modal="true" aria-labelledby="settingsTitle" aria-hidden="true">
        <div class="modal-content" role="document">
            <div class="modal-header">
                <h2 id="settingsTitle" class="modal-title">Einstellungen</h2>
                <button class="icon-btn" id="closeSettingsBtn" type="button" aria-label="Schließen">
                    <svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                </button>
            </div>
            <div class="lock-panel" id="lockPanel" hidden>
                <div class="lock-text">Session gesperrt. Passphrase eingeben.</div>
                <div class="form-group">
                    <label class="form-label" for="unlockPassphrase">Passphrase</label>
                    <input type="password" class="form-input" id="unlockPassphrase" placeholder="••••••" autocomplete="current-password" />
                </div>
                <div class="btn-group">
                    <button class="btn btn-secondary" id="unlockCancelBtn" type="button">Abbrechen</button>
                    <button class="btn btn-primary" id="unlockBtn" type="button">Entsperren</button>
                </div>
            </div>
            <div class="settings-body" id="settingsBody">
                <div class="form-group">
                    <label class="form-label" for="themeSelect">Theme</label>
                    <select class="form-select" id="themeSelect">
                        <option value="auto">Auto</option>
                        <option value="light">Hell</option>
                        <option value="dark">Dunkel</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label" for="densitySelect">Dichte</label>
                    <select class="form-select" id="densitySelect">
                        <option value="compact">Kompakt</option>
                        <option value="comfortable">Komfortabel</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label" for="apiProvider">API Provider</label>
                    <select class="form-select" id="apiProvider">
                        <option value="openai">OpenAI</option>
                        <option value="groq">Groq</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label" for="apiKey">API Key (RAM only)</label>
                    <input type="password" class="form-input" id="apiKey" placeholder="Wird nicht gespeichert..." autocomplete="off" />
                    <div class="field-hint">Schlüssel wird nur im RAM gehalten und nie gespeichert.</div>
                </div>
                <div class="form-group">
                    <label class="form-label" for="modelName">Model</label>
                    <input type="text" class="form-input" id="modelName" placeholder="gpt-4o-mini" />
                </div>
                <div class="form-group">
                    <label class="form-label" for="proxyUrl">Proxy URL (Optional)</label>
                    <input type="url" class="form-input" id="proxyUrl" placeholder="https://..." />
                    <div class="field-hint">Nur https erlaubt. Keine lokalen oder internen Hosts.</div>
                </div>
                <div class="form-group">
                    <label class="form-label" for="masterHash">Master Hash (Supply Chain Lock)</label>
                    <input type="text" class="form-input" id="masterHash" placeholder="SHA-256 Hex" autocomplete="off" />
                    <div class="field-hint">Ohne Hash ist Master Sync deaktiviert.</div>
                </div>
                <div class="form-group">
                    <label class="form-label" for="department">Abteilung</label>
                    <select class="form-select" id="department">
                        <option value="TV">TV &amp; Audio</option>
                        <option value="Mobile">Mobile</option>
                        <option value="IT">IT</option>
                        <option value="Weiß">Weiße Ware</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label" for="storePolicy">Store Policy</label>
                    <textarea class="form-textarea" id="storePolicy" placeholder="z.B. Winteraktion -10% bis 31.01.2026"></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Session Lock (Optional)</label>
                    <input type="password" class="form-input" id="lockPassphrase" placeholder="Passphrase setzen" autocomplete="new-password" />
                    <div style="height: var(--space-2);"></div>
                    <input type="password" class="form-input" id="lockPassphraseConfirm" placeholder="Passphrase bestätigen" autocomplete="new-password" />
                    <div style="height: var(--space-2);"></div>
                    <input type="number" class="form-input" id="lockTimeout" min="5" max="240" step="5" placeholder="Timeout in Minuten (z.B. 30)" />
                    <div class="field-hint">Sperrt API-Funktion und Settings-Zugriff, wenn nicht entsperrt.</div>
                    <div class="btn-group" style="margin-top: var(--space-3);">
                        <button class="btn btn-secondary" id="lockRemoveBtn" type="button">Lock entfernen</button>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Datenmanagement</label>
                    <div class="btn-group">
                        <button class="btn btn-secondary" id="exportBtn" type="button">Export</button>
                        <button class="btn btn-secondary" id="importBtn" type="button">Import</button>
                    </div>
                    <input type="file" id="importFile" accept=".json" class="sr-only" />
                    <div class="btn-group" style="margin-top: var(--space-3);">
                        <button class="btn btn-danger" id="clearBtn" type="button">Reset DB (Halten)</button>
                    </div>
                    <div class="field-hint">Export enthält keine API Keys.</div>
                </div>
                <div class="btn-group">
                    <button class="btn btn-secondary" id="cancelSettingsBtn" type="button">Abbrechen</button>
                    <button class="btn btn-primary" id="saveSettingsBtn" type="button">Speichern</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal" id="confirmModal" role="alertdialog" aria-modal="true" aria-labelledby="confirmTitle" aria-describedby="confirmMessage" aria-hidden="true">
        <div class="modal-content" role="document">
            <div class="modal-header">
                <h2 id="confirmTitle" class="modal-title">Bestätigung</h2>
                <button class="icon-btn" id="confirmCloseBtn" type="button" aria-label="Schließen">
                    <svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                </button>
            </div>
            <p class="confirm-message" id="confirmMessage"></p>
            <div class="btn-group">
                <button class="btn btn-secondary" id="confirmCancelBtn" type="button">Abbrechen</button>
                <button class="btn btn-danger" id="confirmOkBtn" type="button">Bestätigen</button>
            </div>
        </div>
    </div>

    <script>
        const BUILD_SIGNATURE = "MEHIC_SALES_OS_ENTERPRISE_v2.0.0_2026";
        const DB_NAME = "MehicSalesOS_DB";
        const DB_VERSION = 2;
        const MASTER_URL = "https://raw.githubusercontent.com/Enco85/sales-os/main/library.json";
        const EXPECTED_MASTER_SHA256 = "";
        const STORAGE_KEYS = {
            settings: "mehic_sales_settings_v2",
            cases: "mehic_sales_cases_v2",
            logs: "mehic_sales_logs_v2"
        };
        const STORAGE_LIMITS = { logs: 500, cases: 1000 };
        const THEME_ORDER = ["auto", "light", "dark"];
        const DENSITY_ORDER = ["compact", "comfortable"];
        const THEME_LABELS = { auto: "Auto", light: "Hell", dark: "Dunkel" };
        const DENSITY_LABELS = { compact: "Kompakt", comfortable: "Komfortabel" };
        const SOURCE_LABELS = { seed: "Seed", local: "Lokal", ai: "AI", master: "Master", fallback: "Fallback" };

        let db = null;
        let dbInitPromise = null;
        let dbWarned = false;
        let dbClosing = false;
        let casesCache = null;
        let syncRunning = false;
        let micRunning = false;
        let recognition = null;
        let micStartWatchdog = null;
        let pendingObjection = null;
        let lastFocus = null;
        let modalClosing = false;
        let uiInertApplied = false;
        let modalHistoryActive = false;
        let ignoreNextPop = false;
        let layoutRaf = null;
        let densityRaf = null;
        let lastAutoDensity = null;
        let storageMode = "idb";
        let localStorageAvailable = false;
        let sessionUnlockedUntil = 0;
        let toastQueue = [];
        let toastActive = false;
        let confirmResolver = null;
        let confirmPreviousFocus = null;
        let confirmSettingsHidden = false;
        const reducedMotionQuery = window.matchMedia("(prefers-reduced-motion: reduce)");
        let reducedMotion = reducedMotionQuery.matches;

        const appState = {
            objection: "",
            contexts: [],
            cards: [],
            loading: false,
            error: null,
            settings: {
                apiProvider: "openai",
                apiKey: "",
                modelName: "gpt-4o-mini",
                proxyUrl: "",
                department: "TV",
                storePolicy: "",
                theme: "auto",
                density: "compact",
                densityLocked: false,
                lockHash: "",
                lockTimeoutMin: 30,
                masterHash: ""
            },
            stealthMode: false
        };

        const dom = {};

        function bindDom() {
            dom.themeToggle = document.getElementById("themeToggle");
            dom.themeLabel = document.getElementById("themeLabel");
            dom.densityToggle = document.getElementById("densityToggle");
            dom.densityLabel = document.getElementById("densityLabel");
            dom.statusPill = document.getElementById("statusPill");
            dom.deptBadge = document.getElementById("deptBadge");
            dom.cardsContainer = document.getElementById("cardsContainer");
            dom.objectionInput = document.getElementById("objectionInput");
            dom.micBtn = document.getElementById("micBtn");
            dom.controlBar = document.getElementById("controlBar");
            dom.offlineHint = document.getElementById("offlineHint");
            dom.settingsModal = document.getElementById("settingsModal");
            dom.appShell = document.getElementById("appShell");
            dom.stealthOverlay = document.getElementById("stealthOverlay");
            dom.themeSelect = document.getElementById("themeSelect");
            dom.densitySelect = document.getElementById("densitySelect");
            dom.apiProvider = document.getElementById("apiProvider");
            dom.apiKey = document.getElementById("apiKey");
            dom.modelName = document.getElementById("modelName");
            dom.proxyUrl = document.getElementById("proxyUrl");
            dom.department = document.getElementById("department");
            dom.storePolicy = document.getElementById("storePolicy");
            dom.masterHash = document.getElementById("masterHash");
            dom.lockPanel = document.getElementById("lockPanel");
            dom.settingsBody = document.getElementById("settingsBody");
            dom.unlockPassphrase = document.getElementById("unlockPassphrase");
            dom.unlockBtn = document.getElementById("unlockBtn");
            dom.unlockCancelBtn = document.getElementById("unlockCancelBtn");
            dom.lockPassphrase = document.getElementById("lockPassphrase");
            dom.lockPassphraseConfirm = document.getElementById("lockPassphraseConfirm");
            dom.lockTimeout = document.getElementById("lockTimeout");
            dom.lockRemoveBtn = document.getElementById("lockRemoveBtn");
            dom.confirmModal = document.getElementById("confirmModal");
            dom.confirmMessage = document.getElementById("confirmMessage");
            dom.confirmTitle = document.getElementById("confirmTitle");
            dom.confirmOkBtn = document.getElementById("confirmOkBtn");
            dom.confirmCancelBtn = document.getElementById("confirmCancelBtn");
            dom.confirmCloseBtn = document.getElementById("confirmCloseBtn");
            dom.toast = document.getElementById("toast");
        }

        function toFiniteNumber(v, fallback = 0) {
            const n = Number(v);
            return Number.isFinite(n) ? n : fallback;
        }

        function isLocalStorageAvailable() {
            try {
                const key = "__mehic_test__";
                localStorage.setItem(key, "1");
                localStorage.removeItem(key);
                return true;
            } catch (_) { return false; }
        }

        function loadLocalJSON(key, fallback) {
            if (!localStorageAvailable) return fallback;
            try {
                const raw = localStorage.getItem(key);
                if (!raw) return fallback;
                const data = JSON.parse(raw);
                return data ?? fallback;
            } catch (_) { return fallback; }
        }

        function saveLocalJSON(key, value) {
            if (!localStorageAvailable) return false;
            try {
                localStorage.setItem(key, JSON.stringify(value));
                return true;
            } catch (_) { return false; }
        }

        function sanitizeSettings(input, fallback = appState.settings) {
            const s = input && typeof input === "object" ? input : {};
            return {
                apiProvider: s.apiProvider === "groq" ? "groq" : "openai",
                apiKey: "",
                modelName: String(s.modelName || fallback.modelName || "gpt-4o-mini").slice(0, 80),
                proxyUrl: validateProxyUrl(s.proxyUrl || ""),
                department: ["TV", "Mobile", "IT", "Weiß"].includes(s.department) ? s.department : (fallback.department || "TV"),
                storePolicy: String(s.storePolicy || fallback.storePolicy || "").slice(0, 200),
                theme: THEME_ORDER.includes(s.theme) ? s.theme : (fallback.theme || "auto"),
                density: DENSITY_ORDER.includes(s.density) ? s.density : (fallback.density || "compact"),
                densityLocked: typeof s.densityLocked === "boolean" ? s.densityLocked : (fallback.densityLocked || false),
                lockHash: typeof s.lockHash === "string" ? s.lockHash : (fallback.lockHash || ""),
                lockTimeoutMin: Math.min(240, Math.max(5, toFiniteNumber(s.lockTimeoutMin, fallback.lockTimeoutMin || 30))),
                masterHash: typeof s.masterHash === "string" ? s.masterHash.trim().toLowerCase() : (fallback.masterHash || "")
            };
        }

        function sanitizeLog(log) {
            const safe = log && typeof log === "object" ? log : {};
            return {
                timestamp: String(safe.timestamp || new Date().toISOString()).slice(0, 40),
                type: String(safe.type || "event").slice(0, 40),
                objection: String(safe.objection || "").slice(0, 200),
                contexts: Array.isArray(safe.contexts) ? safe.contexts.map(c => String(c).slice(0, 20)) : [],
                data: safe.data && typeof safe.data === "object" ? safe.data : {}
            };
        }

        function sanitizeCases(list) {
            if (!Array.isArray(list)) return [];
            const out = [];
            for (const item of list) {
                const cloned = safeClone(item, "import.case");
                if (!cloned) continue;
                const norm = normalizeCard(cloned);
                if (!validateCardShape(norm)) continue;
                out.push(norm);
            }
            return out.slice(0, STORAGE_LIMITS.cases);
        }

        function sanitizeImportData(raw) {
            const data = raw && typeof raw === "object" ? raw : {};
            const settings = sanitizeSettings(data.settings || {});
            const cases = sanitizeCases(data.cases || []);
            const logs = Array.isArray(data.logs) ? data.logs.map(sanitizeLog).slice(0, STORAGE_LIMITS.logs) : [];
            return { settings, cases, logs };
        }

        function isSessionUnlocked() {
            if (!appState.settings.lockHash) return true;
            return Date.now() < sessionUnlockedUntil;
        }

        function lockSession() {
            sessionUnlockedUntil = 0;
        }

        async function unlockSession(passphrase) {
            if (!appState.settings.lockHash) return true;
            const hash = await hashPassphrase(passphrase);
            if (hash === appState.settings.lockHash) {
                sessionUnlockedUntil = Date.now() + (appState.settings.lockTimeoutMin * 60 * 1000);
                return true;
            }
            return false;
        }

        function deepClone(obj) {
            if (typeof structuredClone === "function") return structuredClone(obj);
            return JSON.parse(JSON.stringify(obj));
        }

        function safeClone(obj, contextLabel = "clone") {
            try { return deepClone(obj); }
            catch (e) {
                console.warn(contextLabel + " failed", e);
                showToast("Datensatz defekt, wird übersprungen");
                return null;
            }
        }

        function canonicalize(obj) {
            if (obj === undefined) return null;
            if (typeof obj !== "object" || obj === null) return obj;
            if (Array.isArray(obj)) return obj.map(v => canonicalize(v));
            const keys = Object.keys(obj).sort();
            const result = {};
            keys.forEach(key => result[key] = canonicalize(obj[key]));
            return result;
        }

        function getFingerprint(item) {
            return JSON.stringify(canonicalize({ meta: item.meta, ui: item.ui, content: item.content }));
        }

        const ALLOW2 = new Set(["tv", "4k", "8k", "pc", "it", "ps", "vr", "ai", "5g", "os", "hd"]);
        const STOP_WORDS = new Set(["und", "aber", "oder", "ist", "ein", "eine", "der", "die", "das", "für", "von", "mit", "bei", "den", "dem", "dass", "was", "wie"]);

        function cleanKeywords(text) {
            return String(text || "").toLowerCase()
                .replace(/-/g, " ")
                .replace(/[^a-z0-9äöüß\s]/gi, " ")
                .replace(/\b\d{7,}\b/g, "")
                .split(/\s+/)
                .filter(w => (w.length >= 3) || ALLOW2.has(w))
                .filter(w => !STOP_WORDS.has(w));
        }

        async function sha256Hex(text){
            const enc = new TextEncoder().encode(text);
            const hash = await crypto.subtle.digest("SHA-256", enc);
            return [...new Uint8Array(hash)].map(b => b.toString(16).padStart(2,"0")).join("");
        }

        async function hashPassphrase(passphrase) {
            return sha256Hex("mehic_lock_v1:" + String(passphrase || ""));
        }

        function extractJSON(text) {
            if (typeof text !== "string") throw new Error("No JSON found");
            const s = text;
            let start = -1;
            let depth = 0;
            let inStr = false;
            let esc = false;
            for (let i = 0; i < s.length; i++) {
                const ch = s[i];
                if (inStr) {
                    if (esc) { esc = false; continue; }
                    if (ch === "\\") { esc = true; continue; }
                    if (ch === '"') { inStr = false; continue; }
                    continue;
                }
                if (ch === '"') { inStr = true; continue; }
                if (ch === "{") {
                    if (start === -1) start = i;
                    depth++;
                    continue;
                }
                if (ch === "}") {
                    if (start !== -1) depth--;
                    if (start !== -1 && depth === 0) return s.slice(start, i + 1);
                }
            }
            throw new Error("No JSON found");
        }

        function genId(prefix="gen") {
            try { return prefix + "_" + crypto.randomUUID(); }
            catch(e) { return prefix + "_" + Date.now() + "_" + Math.random().toString(36).slice(2); }
        }

        function showToast(msg, ms = 2400) {
            const t = dom.toast;
            if (!t) return;
            toastQueue.push({ msg: String(msg || ""), ms });
            if (!toastActive) {
                toastActive = true;
                const run = () => {
                    const next = toastQueue.shift();
                    if (!next) { toastActive = false; return; }
                    t.textContent = next.msg;
                    t.classList.add("show");
                    if (showToast._timer) clearTimeout(showToast._timer);
                    showToast._timer = setTimeout(() => {
                        t.classList.remove("show");
                        setTimeout(run, 200);
                    }, next.ms);
                };
                run();
            }
        }

        function showConfirm({ title, message, confirmText } = {}) {
            return new Promise((resolve) => {
                if (!dom.confirmModal) { resolve(false); return; }
                confirmResolver = resolve;
                confirmPreviousFocus = document.activeElement;
                const inSettings = dom.settingsModal.classList.contains("open");
                confirmSettingsHidden = inSettings;
                if (inSettings) dom.settingsModal.setAttribute("aria-hidden", "true");
                disableAppShellA11y();
                document.body.classList.add("modal-open");
                dom.confirmTitle.textContent = title || "Bestätigung";
                dom.confirmMessage.textContent = message || "Sind Sie sicher?";
                dom.confirmOkBtn.textContent = confirmText || "Bestätigen";
                dom.confirmModal.classList.add("open");
                dom.confirmModal.setAttribute("aria-hidden", "false");
                setTimeout(() => dom.confirmOkBtn.focus(), 0);
            });
        }

        function closeConfirm(result) {
            if (!dom.confirmModal.classList.contains("open")) return;
            dom.confirmModal.classList.remove("open");
            dom.confirmModal.setAttribute("aria-hidden", "true");
            if (confirmSettingsHidden) dom.settingsModal.setAttribute("aria-hidden", "false");
            if (!dom.settingsModal.classList.contains("open")) {
                restoreAppShellA11y();
                document.body.classList.remove("modal-open");
            }
            if (confirmPreviousFocus && isFocusable(confirmPreviousFocus)) confirmPreviousFocus.focus();
            confirmPreviousFocus = null;
            if (confirmResolver) confirmResolver(!!result);
            confirmResolver = null;
            confirmSettingsHidden = false;
        }

        function normalizeCard(card) {
            const c = card || {};
            c.id = String(c.id || genId("card"));
            c.meta = c.meta || {};
            c.meta.pattern = String(c.meta.pattern || "general").slice(0,50);
            c.meta.source = String(c.meta.source || "");
            c.ui = c.ui || {};
            c.ui.color = ["success", "warning", "error"].includes(c.ui.color) ? c.ui.color : "success";
            c.ui.icon = ["info", "tag", "shield", "clock"].includes(c.ui.icon) ? c.ui.icon : "info";
            c.content = c.content || {};
            c.content.quick = c.content.quick || {};
            c.content.quick.entry = String(c.content.quick.entry || "Moment...").slice(0,500);
            c.content.quick.anchor = String(c.content.quick.anchor || "").slice(0,500);
            c.content.quick.question = String(c.content.quick.question || "").slice(0,500);
            c.content.quick.bridge = String(c.content.quick.bridge || "").slice(0,500);
            c.content.quick.close = String(c.content.quick.close || "").slice(0,500);
            c.content.smart = c.content.smart || {};
            c.content.smart.text = String(c.content.smart.text || "Lade...").slice(0,1000);
            c.content.smart.closing = String(c.content.smart.closing || "").slice(0,500);
            c.content.coach = c.content.coach || {};
            c.content.coach.diagnosis = String(c.content.coach.diagnosis || "").slice(0,500);
            c.content.coach.strategy = String(c.content.coach.strategy || "").slice(0,500);
            c.content.coach.behavioral_fix = String(c.content.coach.behavioral_fix || "").slice(0,500);
            c.content.coach.drill = Array.isArray(c.content.coach.drill) ? c.content.coach.drill : [];
            c.keywords = Array.isArray(c.keywords) ? c.keywords : [];
            return c;
        }

        function validateCardShape(c) {
            if (!c || !c.content || !c.content.quick || !c.content.smart || !c.content.coach) return false;
            return typeof c.content.quick.entry === "string" && typeof c.content.smart.text === "string" && Array.isArray(c.content.coach.drill);
        }

        const SEED_DATA = [
            {
                id: "seed_1",
                objection: "zu teuer",
                keywords: ["teuer", "preis", "kostet", "viel", "hoch", "expensive"],
                meta: { status: "success", pattern: "price", safety: "clean" },
                ui: { color: "success", icon: "tag" },
                content: {
                    quick: {
                        entry: "Ich verstehe, dass der Preis im ersten Moment hoch erscheint.",
                        anchor: "Viele Kundinnen und Kunden haben anfangs dieselbe Reaktion und sind dann sehr zufrieden mit ihrer Entscheidung.",
                        question: "Darf ich Ihnen kurz zeigen, was dieses Gerät von günstigeren Modellen unterscheidet?",
                        bridge: "Langfristig gesehen investieren Sie hier in Qualität, die sich rechnet.",
                        close: "Wenn wir gemeinsam schauen, welche Features Sie wirklich brauchen, finden wir das beste Preis-Leistungs-Verhältnis für Sie."
                    },
                    smart: {
                        text: "Verstehe ich absolut. Preis ist wichtig. Lassen Sie uns kurz vergleichen: Das günstigere Modell hat X, unser Modell bietet zusätzlich Y und Z. Das bedeutet für Sie konkret [Vorteile]. Viele Kundinnen und Kunden entscheiden sich letztlich für die höhere Investition, weil sie langfristig profitieren.",
                        closing: "Möchten Sie beide Modelle nebeneinander sehen, damit Sie selbst entscheiden können?"
                    },
                    coach: {
                        diagnosis: "Preiseinwand ist oft ein Kontrolleinwand. Kunde sucht Rechtfertigung für Investition.",
                        strategy: "Nicht verteidigen, sondern Wert aufbauen. Von Preis auf Wert shiften.",
                        behavioral_fix: "Anchor-Technik: 'Viele Kundinnen und Kunden...' schafft Social Proof. Frage am Ende gibt Kontrolle zurück.",
                        drill: [
                            "Üben: 'Verstehe ich. Darf ich fragen, was Ihnen an diesem Modell gefällt?' (Commitment verstärken)",
                            "Üben: Preisvergleich immer mit konkretem Mehrwert verknüpfen, nie nur Zahlen nennen"
                        ]
                    }
                }
            },
            {
                id: "seed_2",
                objection: "keine versicherung",
                keywords: ["versicherung", "garantie", "schutz", "abo", "absicherung"],
                meta: { status: "success", pattern: "subscription_aversion", safety: "transparency_required" },
                ui: { color: "warning", icon: "shield" },
                content: {
                    quick: {
                        entry: "Verstehe ich vollkommen, Versicherungen sind nicht jedermanns Sache.",
                        anchor: "Viele Kundinnen und Kunden denken anfangs ähnlich, bis sie die erste Reparatur brauchen.",
                        question: "Darf ich Ihnen transparent zeigen, was genau abgedeckt wäre und wie sich das rechnet?",
                        bridge: "Wichtig: Sie entscheiden natürlich selbst. Mir geht es nur darum, dass Sie alle Infos haben.",
                        close: "Wenn wir einmal durchrechnen, können Sie in Ruhe entscheiden, ob es sich für Sie lohnt."
                    },
                    smart: {
                        text: "Alles klar, kein Problem. Viele verzichten darauf und kommen dann doch zurück. Die Versicherung deckt [konkrete Leistungen] ab. Das bedeutet: [Beispiel Schadensfall]. Hinweis: Alle Konditionen stehen transparent im Vertrag, keine versteckten Kosten.",
                        closing: "Möchten Sie die Unterlagen mitnehmen und in Ruhe entscheiden?"
                    },
                    coach: {
                        diagnosis: "Versicherungs-Aversion ist häufig. Oft fehlt Vertrauen oder Transparenz.",
                        strategy: "Transparenz vor Verkauf. Konkrete Beispiele statt Angstmache.",
                        behavioral_fix: "Niemals Druck aufbauen. 'Sie entscheiden' gibt Kontrolle zurück und baut Vertrauen auf.",
                        drill: [
                            "Üben: Schadensfall-Beispiel parat haben (konkret, realistisch, keine Übertreibung)",
                            "Üben: Kosten transparent darstellen (monatlich UND jährlich nennen)"
                        ]
                    }
                }
            },
            {
                id: "seed_3",
                objection: "muss überlegen",
                keywords: ["überlegen", "bedenkzeit", "später", "nachdenken", "warten"],
                meta: { status: "success", pattern: "uncertainty", safety: "clean" },
                ui: { color: "success", icon: "clock" },
                content: {
                    quick: {
                        entry: "Natürlich, das ist eine wichtige Entscheidung. Nehmen Sie sich ruhig Zeit.",
                        anchor: "Viele Kundinnen und Kunden gehen das genauso an und überlegen in Ruhe.",
                        question: "Darf ich fragen, worüber Sie noch nachdenken möchten? Vielleicht kann ich noch etwas klären?",
                        bridge: "Mir ist wichtig, dass Sie sich sicher fühlen mit Ihrer Entscheidung.",
                        close: "Wenn Sie mögen, reserviere ich das Gerät für Sie, damit Sie in Ruhe überlegen können, ohne dass es weg ist."
                    },
                    smart: {
                        text: "Absolut verständlich. Ist eine Investition und die sollte gut überlegt sein. Viele vergleichen erst noch online oder besprechen es zu Hause. Gibt es noch einen speziellen Punkt, den ich klären kann?",
                        closing: "Möchten Sie, dass ich das Gerät für 24 Stunden reserviere?"
                    },
                    coach: {
                        diagnosis: "Bedenkzeit ist legitim, aber oft versteckt sich ein ungelöster Einwand dahinter.",
                        strategy: "Respektieren, aber nachfragen. Offene Frage stellen, um echten Grund zu finden.",
                        behavioral_fix: "Reservierungs-Offer gibt Kontrolle und schafft sanften Commitment-Anker ohne Druck.",
                        drill: [
                            "Üben: 'Worüber möchten Sie noch nachdenken?' (offene Frage, kein Druck)",
                            "Üben: Reservierungsangebot als Service-Geste positionieren, nicht als Druck"
                        ]
                    }
                }
            }
        ];

        const JOKER_CARD = normalizeCard({
            id: "joker_fallback",
            meta: { pattern: "fallback", safety: "clean", source: "fallback" },
            ui: { color: "warning", icon: "info" },
            content: {
                quick: { entry: "Verstehe ich gut.", anchor: "Das ist ein wichtiger Punkt.", question: "Können wir das kurz klären?" },
                smart: { text: "Entschuldigung, Verbindungsproblem. Nutzen Sie Ihre Standard-Technik.", closing: "Alles klar?" },
                coach: { diagnosis: "", strategy: "", behavioral_fix: "", drill: [] }
            }
        });

        function isPrivateHost(host) {
            const h = host.toLowerCase();
            if (h === "localhost" || h === "127.0.0.1" || h === "::1") return true;
            if (h.endsWith(".local") || h.endsWith(".internal") || h.endsWith(".lan")) return true;
            if (/^\d{1,3}(\.\d{1,3}){3}$/.test(h)) {
                const parts = h.split(".").map(Number);
                if (parts.some(n => n < 0 || n > 255)) return true;
                if (parts[0] === 0 || parts[0] === 255) return true;
                if (parts[0] === 10) return true;
                if (parts[0] === 127) return true;
                if (parts[0] === 169 && parts[1] === 254) return true;
                if (parts[0] === 172 && parts[1] >= 16 && parts[1] <= 31) return true;
                if (parts[0] === 192 && parts[1] === 168) return true;
                return false;
            }
            if (h.includes(":")) return true;
            return false;
        }

        function validateProxyUrl(raw) {
            if (!raw) return "";
            try {
                const url = new URL(raw);
                if (url.protocol !== "https:") return "";
                if (url.username || url.password) return "";
                if (isPrivateHost(url.hostname)) return "";
                return url.toString();
            } catch (_) { return ""; }
        }

        function applyTheme(theme) {
            const safe = THEME_ORDER.includes(theme) ? theme : "auto";
            document.documentElement.setAttribute("data-theme", safe);
            if (dom.themeLabel) dom.themeLabel.textContent = THEME_LABELS[safe] || "Auto";
            if (dom.themeToggle) dom.themeToggle.setAttribute("aria-label", "Theme: " + (THEME_LABELS[safe] || "Auto"));
            if (dom.themeSelect) dom.themeSelect.value = safe;
            updateThemeColorMeta();
        }

        function applyDensity(density) {
            const safe = DENSITY_ORDER.includes(density) ? density : "compact";
            document.documentElement.setAttribute("data-density", safe);
            if (dom.densityLabel) dom.densityLabel.textContent = DENSITY_LABELS[safe] || "Kompakt";
            if (dom.densityToggle) dom.densityToggle.setAttribute("aria-label", "Dichte: " + (DENSITY_LABELS[safe] || "Kompakt"));
            if (dom.densitySelect) dom.densitySelect.value = safe;
            scheduleLayoutMetrics();
        }

        function getAutoDensity() {
            const isCoarse = window.matchMedia("(pointer: coarse)").matches;
            const width = window.innerWidth || document.documentElement.clientWidth;
            if (isCoarse || width < 768) return "comfortable";
            return "compact";
        }

        function applyAutoDensityIfNeeded() {
            if (appState.settings.densityLocked) return;
            if (densityRaf) cancelAnimationFrame(densityRaf);
            densityRaf = requestAnimationFrame(() => {
                const target = getAutoDensity();
                if (target !== lastAutoDensity) {
                    lastAutoDensity = target;
                    appState.settings.density = target;
                    applyDensity(target);
                    saveSettings(appState.settings);
                    render();
                }
                densityRaf = null;
            });
        }

        function updateThemeColorMeta() {
            const meta = document.getElementById("themeColorMeta");
            if (!meta) return;
            const bg = getComputedStyle(document.documentElement).getPropertyValue("--color-bg").trim();
            if (bg) meta.setAttribute("content", bg);
        }

        function haptic(pattern = [50]) {
            if (navigator.vibrate && !reducedMotion) navigator.vibrate(pattern);
        }

        function isFocusable(el) {
            if (!el) return false;
            return typeof el.focus === "function" &&
                !el.disabled &&
                el.tabIndex >= 0 &&
                el.getClientRects().length > 0 &&
                getComputedStyle(el).visibility !== "hidden" &&
                getComputedStyle(el).display !== "none";
        }

        function getFirstFocusable(root) {
            const all = root.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
            return Array.from(all).find(el => isFocusable(el));
        }

        function disableAppShellA11y() {
            if (uiInertApplied) return;
            uiInertApplied = true;
            try { dom.appShell.setAttribute("inert", ""); } catch(_){}
            dom.appShell.setAttribute("aria-hidden", "true");
            const nodes = dom.appShell.querySelectorAll('a,button,input,select,textarea,[tabindex]');
            dom._a11yRestores = [];
            nodes.forEach(el => {
                const prev = el.getAttribute("tabindex");
                if (prev !== null && prev !== "-1") dom._a11yRestores.push([el, prev]);
                else if (prev === null) dom._a11yRestores.push([el, null]);
                el.setAttribute("tabindex", "-1");
            });
        }

        function restoreAppShellA11y() {
            if (!uiInertApplied) return;
            uiInertApplied = false;
            try { dom.appShell.removeAttribute("inert"); } catch(_){}
            dom.appShell.removeAttribute("aria-hidden");
            (dom._a11yRestores || []).forEach(([el, prev]) => {
                if (prev === null) el.removeAttribute("tabindex");
                else el.setAttribute("tabindex", prev);
            });
            dom._a11yRestores = [];
        }

        function showLockPanel() {
            if (!dom.lockPanel || !dom.settingsBody) return;
            dom.lockPanel.hidden = false;
            dom.settingsBody.setAttribute("aria-hidden", "true");
            try { dom.settingsBody.setAttribute("inert", ""); } catch(_){}
            setTimeout(() => { if (dom.unlockPassphrase) dom.unlockPassphrase.focus(); }, 50);
        }

        function hideLockPanel() {
            if (!dom.lockPanel || !dom.settingsBody) return;
            dom.lockPanel.hidden = true;
            dom.settingsBody.removeAttribute("aria-hidden");
            try { dom.settingsBody.removeAttribute("inert"); } catch(_){}
        }

        function openSettingsModal() {
            lastFocus = document.activeElement;
            disableAppShellA11y();
            document.body.classList.add("modal-open");
            dom.settingsModal.classList.add("open");
            dom.settingsModal.setAttribute("aria-hidden", "false");
            dom.themeSelect.value = appState.settings.theme;
            dom.densitySelect.value = appState.settings.density;
            dom.apiProvider.value = appState.settings.apiProvider;
            dom.apiKey.value = "";
            dom.modelName.value = appState.settings.modelName;
            dom.proxyUrl.value = appState.settings.proxyUrl;
            dom.masterHash.value = appState.settings.masterHash || EXPECTED_MASTER_SHA256 || "";
            dom.department.value = appState.settings.department;
            dom.storePolicy.value = appState.settings.storePolicy;
            dom.lockPassphrase.value = "";
            dom.lockPassphraseConfirm.value = "";
            dom.lockTimeout.value = String(appState.settings.lockTimeoutMin || 30);
            if (!modalHistoryActive && !(history.state && history.state.settingsOpen)) {
                history.pushState({ settingsOpen: true }, "", location.href);
                modalHistoryActive = true;
            }
            if (appState.settings.lockHash && !isSessionUnlocked()) {
                showLockPanel();
            } else {
                hideLockPanel();
                setTimeout(() => {
                    const first = getFirstFocusable(dom.settingsModal);
                    if (first) first.focus();
                }, 50);
            }
        }

        function closeSettingsModal({ skipHistory = false } = {}) {
            if (!dom.settingsModal.classList.contains("open")) return;
            modalClosing = true;
            dom.settingsModal.classList.remove("open");
            dom.settingsModal.setAttribute("aria-hidden", "true");
            hideLockPanel();
            if (dom.unlockPassphrase) dom.unlockPassphrase.value = "";
            restoreAppShellA11y();
            document.body.classList.remove("modal-open");
            if (lastFocus && isFocusable(lastFocus) && document.body.contains(lastFocus)) {
                lastFocus.focus();
            } else {
                document.getElementById("settingsBtn").focus();
            }
            lastFocus = null;
            setTimeout(() => { modalClosing = false; }, 0);
            if (modalHistoryActive && !skipHistory) {
                ignoreNextPop = true;
                history.back();
            }
            modalHistoryActive = false;
        }

        function updateStatusPill() {
            if (!dom.statusPill) return;
            let status = "online";
            if (!navigator.onLine) status = "offline";
            else if (syncRunning) status = "syncing";
            dom.statusPill.dataset.status = status;
            const base = status === "offline" ? "Offline" : status === "syncing" ? "Sync" : "Online";
            dom.statusPill.textContent = storageMode === "local" ? base + " • Local" : base;
            if (dom.offlineHint) dom.offlineHint.hidden = navigator.onLine;
        }

        function scheduleLayoutMetrics() {
            if (layoutRaf) cancelAnimationFrame(layoutRaf);
            layoutRaf = requestAnimationFrame(() => {
                if (dom.controlBar) {
                    document.documentElement.style.setProperty("--control-bar-height", dom.controlBar.offsetHeight + "px");
                }
                layoutRaf = null;
            });
        }

        function initDB() {
            if (dbInitPromise) return dbInitPromise;
            dbInitPromise = new Promise((resolve) => {
                try {
                    dbClosing = false;
                    const req = indexedDB.open(DB_NAME, DB_VERSION);
                    req.onerror = () => {
                        storageMode = localStorageAvailable ? "local" : "none";
                        resolve(null);
                    };
                    req.onsuccess = () => {
                        db = req.result;
                        storageMode = "idb";
                        dbClosing = false;
                        dbWarned = false;
                        db.onversionchange = () => {
                            dbClosing = true;
                            try { db.close(); } catch(_){}
                            db = null;
                            dbInitPromise = null;
                            showToast("Update verfügbar. Neu laden.");
                        };
                        resolve(db);
                    };
                    req.onupgradeneeded = (e) => {
                        const d = e.target.result;
                        if (!d.objectStoreNames.contains("settings")) d.createObjectStore("settings", { keyPath: "id" });
                        if (!d.objectStoreNames.contains("cases")) d.createObjectStore("cases", { keyPath: "id" });
                        if (!d.objectStoreNames.contains("logs")) d.createObjectStore("logs", { keyPath: "id", autoIncrement: true });
                    };
                } catch (e) { resolve(null); }
            });
            return dbInitPromise;
        }

        async function waitForDB(timeoutMs = 8000) {
            if (dbClosing) { dbClosing = false; dbInitPromise = null; }
            const timeout = new Promise(resolve => setTimeout(() => resolve(null), timeoutMs));
            const res = await Promise.race([initDB(), timeout]);
            if (!res) {
                storageMode = localStorageAvailable ? "local" : "none";
                if (!dbWarned) { dbWarned = true; showToast(localStorageAvailable ? "DB nicht verfügbar, Fallback aktiv" : "DB nicht verfügbar"); }
            } else {
                storageMode = "idb";
            }
            updateStatusPill();
            return res;
        }

        async function saveSettings(s) {
            await waitForDB();
            const safe = sanitizeSettings(s);
            if (!db) {
                return saveLocalJSON(STORAGE_KEYS.settings, safe);
            }
            return new Promise(resolve => {
                let done = false;
                const tx = db.transaction("settings", "readwrite");
                tx.oncomplete = () => { if (!done) { done = true; resolve(true); } };
                tx.onerror = () => { if (!done) { done = true; resolve(false); } };
                try {
                    tx.objectStore("settings").put({ id: "main", ...safe });
                } catch (e) {
                    tx.abort();
                    if (!done) { done = true; resolve(false); }
                }
            });
        }

        async function loadSettings() {
            await waitForDB();
            if (!db) {
                const local = loadLocalJSON(STORAGE_KEYS.settings, null);
                return local ? sanitizeSettings(local) : null;
            }
            return new Promise(r => {
                const req = db.transaction("settings", "readonly").objectStore("settings").get("main");
                req.onsuccess = () => r(req.result ? sanitizeSettings(req.result) : null);
                req.onerror = () => r(null);
            });
        }

        async function logEvent(type, data) {
            await waitForDB();
            if (!db) {
                const logs = loadLocalJSON(STORAGE_KEYS.logs, []);
                logs.push(sanitizeLog({
                    timestamp: new Date().toISOString(),
                    type,
                    objection: appState.objection,
                    contexts: [...appState.contexts],
                    data
                }));
                const trimmed = logs.slice(-STORAGE_LIMITS.logs);
                return saveLocalJSON(STORAGE_KEYS.logs, trimmed);
            }
            return new Promise(resolve => {
                let done = false;
                const tx = db.transaction("logs", "readwrite");
                tx.oncomplete = () => { if (!done) { done = true; resolve(true); } };
                tx.onerror = () => { if (!done) { done = true; resolve(false); } };
                try {
                    tx.objectStore("logs").add({
                        timestamp: new Date().toISOString(),
                        type,
                        objection: appState.objection,
                        contexts: [...appState.contexts],
                        data
                    });
                } catch (e) {
                    tx.abort();
                    if (!done) { done = true; resolve(false); }
                }
            });
        }

        async function loadCasesCache() {
            await waitForDB();
            if (!db) {
                const local = loadLocalJSON(STORAGE_KEYS.cases, []);
                casesCache = sanitizeCases(local);
                return casesCache;
            }
            casesCache = await new Promise(r => {
                const req = db.transaction("cases", "readonly").objectStore("cases").getAll();
                req.onsuccess = () => r(req.result || []);
                req.onerror = () => r([]);
            });
            return casesCache;
        }

        async function saveCase(c, rawText) {
            await waitForDB();
            if (!db) {
                const cloned = safeClone(c, "saveCase.localClone");
                if (!cloned) return false;
                const norm = normalizeCard(cloned);
                if (!validateCardShape(norm)) return false;
                const newKw = cleanKeywords(rawText);
                const merged = [...new Set([...(norm.keywords || []), ...newKw])];
                norm.keywords = merged.slice(0, 60);
                if (!casesCache) casesCache = [];
                const idx = casesCache.findIndex(x => x.id === norm.id);
                if (idx > -1) casesCache[idx] = norm; else casesCache.push(norm);
                casesCache = casesCache.slice(-STORAGE_LIMITS.cases);
                return saveLocalJSON(STORAGE_KEYS.cases, casesCache);
            }
            return new Promise((resolve) => {
                const cloned = safeClone(c, "saveCase.deepClone");
                if (!cloned) { resolve(false); return; }
                const norm = normalizeCard(cloned);
                if (!validateCardShape(norm)) { resolve(false); return; }
                let done = false;
                const tx = db.transaction("cases", "readwrite");
                tx.oncomplete = () => {
                    if (!done) {
                        done = true;
                        if (casesCache) {
                            const idx = casesCache.findIndex(x => x.id === norm.id);
                            if (idx > -1) casesCache[idx] = norm;
                            else casesCache.push(norm);
                        }
                        resolve(true);
                    }
                };
                tx.onerror = () => { if (!done) { done = true; resolve(false); } };
                try {
                    const store = tx.objectStore("cases");
                    const newKw = cleanKeywords(rawText);
                    const merged = [...new Set([...(norm.keywords || []), ...newKw])];
                    norm.keywords = merged.slice(0, 60);
                    store.put(norm);
                } catch (e) {
                    tx.abort();
                    if (!done) { done = true; resolve(false); }
                }
            });
        }

        async function searchLocal(query) {
            if (!casesCache) await loadCasesCache();
            if (!casesCache || casesCache.length === 0) return null;
            const qWords = cleanKeywords(query);
            if (qWords.length === 0) return null;
            let best = null;
            let bestScore = 0;
            for (const item of casesCache) {
                if (!item || !Array.isArray(item.keywords)) continue;
                const kw = item.keywords.map(x => String(x).toLowerCase());
                let score = 0;
                for (const qw of qWords) {
                    const isMatch = (k, q) => q.length < 4 ? k === q : (k === q || k.startsWith(q));
                    score += kw.some(k => isMatch(k, qw)) ? 1 : 0;
                }
                if (score > bestScore) { bestScore = score; best = item; }
            }
            const minScore = Math.max(1, Math.ceil(qWords.length * 0.4));
            if (best && bestScore >= minScore) {
                const cloned = safeClone(best, "searchLocal.deepClone");
                if (!cloned) return null;
                return normalizeCard(cloned);
            }
            return null;
        }

        function searchSeeds(query) {
            const qWords = cleanKeywords(query);
            if (qWords.length === 0) return null;
            let best = null;
            let bestScore = 0;
            for (const seed of SEED_DATA) {
                const kw = (seed.keywords || []).map(x => String(x).toLowerCase());
                let score = 0;
                for (const qw of qWords) {
                    const isMatch = (k, q) => q.length < 4 ? k === q : (k === q || k.startsWith(q));
                    score += kw.some(k => isMatch(k, qw)) ? 1 : 0;
                }
                if (score > bestScore) { bestScore = score; best = seed; }
            }
            const minScore = Math.max(1, Math.ceil(qWords.length * 0.4));
            if (best && bestScore >= minScore) return best;
            return null;
        }

        async function fetchWithTimeout(url, options = {}, timeoutMs = 8000, retry = 1) {
            let attempt = 0;
            while (true) {
                const controller = new AbortController();
                const id = setTimeout(() => controller.abort(), timeoutMs);
                try {
                    const res = await fetch(url, { ...options, signal: controller.signal });
                    if (!res.ok && attempt < retry && (res.status >= 500 || res.status === 429)) {
                        attempt++;
                        continue;
                    }
                    return res;
                } catch (e) {
                    if (attempt < retry && (e.name === "AbortError" || e.name === "TypeError")) {
                        attempt++;
                        continue;
                    }
                    throw e;
                } finally {
                    clearTimeout(id);
                }
            }
        }

        async function callAI(objection, contexts) {
            const { apiProvider, apiKey, modelName, proxyUrl, department, storePolicy } = appState.settings;
            if (!apiKey && !proxyUrl) throw new Error("Kein API Key");
            if (!isSessionUnlocked()) throw new Error("Session gesperrt");
            if (!navigator.onLine) throw new Error("Offline");
            const contextMods = [];
            if (contexts.includes("hurry")) contextMods.push("Kunde ist eilig: Ultra-kurz, max 2 Sätze pro Abschnitt.");
            if (contexts.includes("duo")) contextMods.push("Kunde ist Paar/Gruppe: Inkludiere beide Personen (\"Sie beide\").");
            if (contexts.includes("easy")) contextMods.push("Einfache Sprache, Nutzen statt Features.");
            if (contexts.includes("techie")) contextMods.push("Technikaffin: Specs erlaubt, immer mit Nutzen verknüpfen.");
            const baseSystemPrompt = `ROLE: Sales Expert (Austria). Dept: ${department}. Policy: ${storePolicy || "keine Aktionen definiert"}.
OUTPUT: JSON ONLY. NO markdown. NO text before or after JSON.
CONTEXTS: ${contextMods.join(" ")}
SCHEMA: {"meta":{"pattern":"str"},"ui":{"color":"success|warning|error","icon":"tag|shield|clock|info"},"content":{"quick":{"entry":"str","anchor":"str","question":"str","bridge":"str","close":"str"},"smart":{"text":"str","closing":"str"},"coach":{"diagnosis":"str","strategy":"str","behavioral_fix":"str","drill":["str"]}}}`;

            async function doRequest(extraStrict = false) {
                const systemPrompt = extraStrict ? baseSystemPrompt + "\nSTRICT: Return ONLY JSON. No text." : baseSystemPrompt;
                const messages = [{ role: "system", content: systemPrompt }, { role: "user", content: objection }];
                let url, headers, body;
                if (proxyUrl) {
                    const safeProxy = validateProxyUrl(proxyUrl);
                    if (!safeProxy) throw new Error("Proxy URL ungültig");
                    url = safeProxy;
                    headers = { "Content-Type": "application/json" };
                    body = JSON.stringify({
                        provider: apiProvider,
                        model: modelName || "gpt-4o-mini",
                        prompt: systemPrompt,
                        objection,
                        messages,
                        temperature: 0.7
                    });
                } else if (apiProvider === "openai") {
                    url = "https://api.openai.com/v1/chat/completions";
                    headers = { "Content-Type": "application/json", "Authorization": `Bearer ${apiKey}` };
                    body = JSON.stringify({ model: modelName || "gpt-4o-mini", messages, temperature: 0.7 });
                } else if (apiProvider === "groq") {
                    url = "https://api.groq.com/openai/v1/chat/completions";
                    headers = { "Content-Type": "application/json", "Authorization": `Bearer ${apiKey}` };
                    body = JSON.stringify({ model: modelName || "llama-3.3-70b-versatile", messages, temperature: 0.7 });
                } else { throw new Error("Unknown Provider"); }

                const res = await fetchWithTimeout(url, { method: "POST", headers, body, cache: "no-store" }, 8000, 1);
                if (!res.ok) throw new Error("API Error " + res.status);
                const data = await res.json();
                const content = data?.choices?.[0]?.message?.content || data?.content || data?.response || "";
                const obj = normalizeCard(JSON.parse(extractJSON(content)));
                if (!validateCardShape(obj)) throw new Error("JSON shape invalid");
                return obj;
            }

            let firstError = null;
            try { return await doRequest(false); } catch (e) {
                firstError = e;
                const msg = (e && e.message) ? String(e.message) : "";
                const isParse = msg.includes("No JSON") || msg.toLowerCase().includes("token") || msg.toLowerCase().includes("json") || msg.includes("shape");
                if (!isParse) throw firstError;
                return await doRequest(true);
            }
        }

        function snapshotOpenPanels() {
            const openIds = new Set();
            document.querySelectorAll(".expand-content.open").forEach((el) => {
                if (el.dataset.panelId) openIds.add(el.dataset.panelId);
            });
            return openIds;
        }

        function restoreOpenPanels(openIds) {
            if (!openIds || openIds.size === 0) return;
            document.querySelectorAll(".expand-content").forEach((el) => {
                if (!el.dataset.panelId || !openIds.has(el.dataset.panelId)) return;
                el.classList.add("open");
                el.style.maxHeight = el.scrollHeight + "px";
                requestAnimationFrame(() => { el.style.maxHeight = "none"; });
                const trigger = el.previousElementSibling;
                if (trigger) trigger.setAttribute("aria-expanded", "true");
                const icon = trigger?.querySelector(".expand-icon");
                if (icon) icon.classList.add("open");
            });
        }

        function createIconSvg(name, className) {
            const icons = {
                shield: '<path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/>',
                clock: '<circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/>',
                tag: '<path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/>',
                info: '<circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/>'
            };
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.setAttribute("viewBox", "0 0 24 24");
            svg.classList.add(className);
            svg.innerHTML = icons[name] || icons.info;
            return svg;
        }

        function createCueBlock(label, text, extraClass) {
            if (!text) return null;
            const block = document.createElement("div");
            block.className = "cue-block";
            const labelEl = document.createElement("div");
            labelEl.className = "cue-label";
            labelEl.textContent = label;
            const textEl = document.createElement("div");
            textEl.className = "cue-text" + (extraClass ? " " + extraClass : "");
            textEl.textContent = text;
            block.append(labelEl, textEl);
            return block;
        }

        function createCoachBlock(label, text) {
            if (!text) return null;
            const block = document.createElement("div");
            block.className = "coach-block";
            const labelEl = document.createElement("div");
            labelEl.className = "coach-label";
            labelEl.textContent = label;
            const textEl = document.createElement("div");
            textEl.className = "coach-text";
            textEl.textContent = text;
            block.append(labelEl, textEl);
            return block;
        }

        function createExpandable(title, contentBuilder, panelId) {
            const wrapper = document.createElement("div");
            wrapper.className = "expandable";
            const trigger = document.createElement("button");
            trigger.type = "button";
            trigger.className = "expand-trigger";
            trigger.dataset.action = "toggle";
            trigger.setAttribute("aria-expanded", "false");
            trigger.setAttribute("aria-controls", panelId);
            const label = document.createElement("div");
            label.className = "expand-label";
            label.textContent = title;
            const icon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            icon.setAttribute("viewBox", "0 0 24 24");
            icon.classList.add("expand-icon");
            icon.innerHTML = '<path d="M6 9l6 6 6-6"/>';
            trigger.append(label, icon);
            const content = document.createElement("div");
            content.className = "expand-content";
            content.id = panelId;
            content.dataset.panelId = panelId;
            contentBuilder(content);
            wrapper.append(trigger, content);
            return wrapper;
        }

        function createCardElement(card, index) {
            const cardEl = document.createElement("article");
            cardEl.className = `card ${card.ui.color}`;
            if (index === 0) cardEl.classList.add("bento-hero");
            if (index === 1) cardEl.classList.add("bento-tall");
            cardEl.dataset.cardId = card.id;

            const header = document.createElement("div");
            header.className = "card-header";
            const icon = createIconSvg(card.ui.icon, "card-icon");
            const title = document.createElement("div");
            title.className = "card-title";
            title.textContent = card.meta.pattern || "Einwand";
            const badge = document.createElement("div");
            badge.className = "card-badge";
            badge.textContent = SOURCE_LABELS[card.meta.source] || "AI";
            header.append(icon, title, badge);
            cardEl.appendChild(header);

            const quick = document.createElement("div");
            quick.className = "quick-cues";
            const entry = createCueBlock("Einstieg", card.content.quick.entry, "");
            const anchor = createCueBlock("Anker", card.content.quick.anchor, "anchor");
            const question = createCueBlock("Frage", card.content.quick.question, "question");
            const bridge = createCueBlock("Brücke", card.content.quick.bridge, "bridge");
            const close = createCueBlock("Abschluss", card.content.quick.close, "close");
            [entry, anchor, question, bridge, close].forEach(block => { if (block) quick.appendChild(block); });
            cardEl.appendChild(quick);

            const smartPanel = createExpandable("Smart Script", (content) => {
                const main = document.createElement("div");
                main.className = "cue-text";
                main.textContent = card.content.smart.text || "";
                content.appendChild(main);
                if (card.content.smart.closing) {
                    const closingLabel = document.createElement("div");
                    closingLabel.className = "cue-label";
                    closingLabel.textContent = "Abschlussfrage";
                    const closingText = document.createElement("div");
                    closingText.className = "cue-text";
                    closingText.textContent = card.content.smart.closing;
                    content.append(closingLabel, closingText);
                }
            }, `smart_${card.id}`);

            const coachPanel = createExpandable("Coach Mode", (content) => {
                const diag = createCoachBlock("Diagnose", card.content.coach.diagnosis);
                const strat = createCoachBlock("Strategie", card.content.coach.strategy);
                const fix = createCoachBlock("Verhaltensfix", card.content.coach.behavioral_fix);
                [diag, strat, fix].forEach(block => { if (block) content.appendChild(block); });
                if (Array.isArray(card.content.coach.drill) && card.content.coach.drill.length > 0) {
                    const drillLabel = document.createElement("div");
                    drillLabel.className = "coach-label";
                    drillLabel.textContent = "Übungen";
                    const list = document.createElement("ul");
                    list.className = "drill-list";
                    card.content.coach.drill.forEach((d) => {
                        const li = document.createElement("li");
                        li.textContent = String(d);
                        list.appendChild(li);
                    });
                    content.append(drillLabel, list);
                }
            }, `coach_${card.id}`);

            cardEl.appendChild(smartPanel);
            cardEl.appendChild(coachPanel);

            const actions = document.createElement("div");
            actions.className = "card-actions";
            const positive = document.createElement("button");
            positive.type = "button";
            positive.className = "feedback-btn success";
            positive.dataset.feedback = "success";
            positive.dataset.card = card.id;
            positive.innerHTML = '<svg viewBox="0 0 24 24"><path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"/></svg>Erfolgreich';
            const negative = document.createElement("button");
            negative.type = "button";
            negative.className = "feedback-btn error";
            negative.dataset.feedback = "fail";
            negative.dataset.card = card.id;
            negative.innerHTML = '<svg viewBox="0 0 24 24"><path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17"/></svg>Nicht hilfreich';
            actions.append(positive, negative);
            cardEl.appendChild(actions);

            return cardEl;
        }

        function render() {
            const openIds = snapshotOpenPanels();
            dom.deptBadge.textContent = appState.settings.department;
            dom.objectionInput.setAttribute("aria-busy", appState.loading ? "true" : "false");
            dom.micBtn.disabled = appState.loading;
            dom.cardsContainer.replaceChildren();
            if (appState.loading) {
                const wrap = document.createElement("div");
                wrap.className = "loading";
                const skeleton = document.createElement("div");
                skeleton.className = "skeleton";
                wrap.appendChild(skeleton);
                dom.cardsContainer.appendChild(wrap);
                scheduleLayoutMetrics();
                return;
            }
            if (appState.error && appState.cards.length === 0) {
                const error = document.createElement("div");
                error.className = "error-state";
                const title = document.createElement("h3");
                title.textContent = "Fehler";
                const text = document.createElement("p");
                text.textContent = appState.error;
                error.append(title, text);
                dom.cardsContainer.appendChild(error);
                scheduleLayoutMetrics();
                return;
            }
            if (appState.cards.length === 0) {
                const empty = document.createElement("div");
                empty.className = "empty-state";
                const title = document.createElement("h3");
                title.textContent = "Bereit";
                const text = document.createElement("p");
                text.textContent = "Warte auf Einwand...";
                empty.append(title, text);
                dom.cardsContainer.appendChild(empty);
                scheduleLayoutMetrics();
                return;
            }
            const grid = document.createElement("div");
            grid.className = "cards-grid";
            const fragment = document.createDocumentFragment();
            appState.cards.forEach((c, idx) => fragment.appendChild(createCardElement(c, idx)));
            grid.appendChild(fragment);
            dom.cardsContainer.appendChild(grid);
            restoreOpenPanels(openIds);
            scheduleLayoutMetrics();
        }

        async function handleObjection() {
            if (appState.loading) {
                if (pendingObjection !== appState.objection) pendingObjection = appState.objection;
                return;
            }
            const text = appState.objection.trim();
            if (!text) { showToast("Bitte Einwand eingeben"); return; }
            appState.loading = true;
            appState.error = null;
            render();
            try {
                let card = null;
                const seed = searchSeeds(text);
                if (seed) {
                    card = normalizeCard(safeClone(seed, "seedClone") || seed);
                    card.meta.source = "seed";
                    await logEvent("seed_match", { cardId: card.id });
                } else {
                    const local = await searchLocal(text);
                    if (local) {
                        local.meta.source = "local";
                        card = local;
                        await logEvent("local_match", { cardId: local.id });
                    } else {
                        const aiCard = await callAI(text, appState.contexts);
                        aiCard.meta.source = "ai";
                        card = aiCard;
                        await saveCase(card, text);
                        await logEvent("api_call", { provider: appState.settings.apiProvider, proxy: !!appState.settings.proxyUrl });
                    }
                }
                appState.cards = [card || JOKER_CARD];
                haptic([50]);
            } catch (e) {
                console.warn("Fallback", e);
                const msg = String(e?.message || e);
                if (msg.includes("Session gesperrt")) {
                    appState.loading = false;
                    showToast("Session gesperrt");
                    render();
                    return;
                }
                appState.cards = [JOKER_CARD];
                appState.error = navigator.onLine ? "Fallback Modus aktiv" : "Offline: Nur lokale Daten verfügbar";
                showToast(appState.error);
                await logEvent("error_fallback", { message: msg });
                haptic([100, 50, 100]);
            }
            appState.loading = false;
            render();
            if (pendingObjection && pendingObjection !== text) {
                appState.objection = pendingObjection;
                pendingObjection = null;
                setTimeout(() => handleObjection(), 0);
            } else {
                pendingObjection = null;
            }
        }

        function toggleExpandable(trigger) {
            const content = trigger.nextElementSibling;
            if (!content) return;
            const icon = trigger.querySelector(".expand-icon");
            const isOpening = !content.classList.contains("open");
            if (reducedMotion) {
                content.classList.toggle("open", isOpening);
                content.style.maxHeight = isOpening ? "none" : "0px";
                trigger.setAttribute("aria-expanded", isOpening ? "true" : "false");
                if (icon) icon.classList.toggle("open", isOpening);
                return;
            }
            const currentToken = (Number(content.dataset.animToken || 0) + 1);
            content.dataset.animToken = currentToken;
            if (isOpening) {
                content.classList.add("open");
                if (icon) icon.classList.add("open");
                trigger.setAttribute("aria-expanded", "true");
                content.style.maxHeight = content.scrollHeight + "px";
                const onOpenEnd = () => {
                    if (Number(content.dataset.animToken) !== currentToken) return;
                    content.style.maxHeight = "none";
                    content.removeEventListener("transitionend", onOpenEnd);
                };
                content.addEventListener("transitionend", onOpenEnd);
                setTimeout(onOpenEnd, 500);
            } else {
                if (content.style.maxHeight === "none") content.style.maxHeight = content.scrollHeight + "px";
                requestAnimationFrame(() => {
                    if (Number(content.dataset.animToken) !== currentToken) return;
                    content.style.maxHeight = content.scrollHeight + "px";
                    requestAnimationFrame(() => {
                        if (Number(content.dataset.animToken) !== currentToken) return;
                        content.style.maxHeight = "0px";
                        if (icon) icon.classList.remove("open");
                        trigger.setAttribute("aria-expanded", "false");
                    });
                });
                const onEnd = (ev) => {
                    if (ev && ev.target !== content) return;
                    if (Number(content.dataset.animToken) !== currentToken) return;
                    content.classList.remove("open");
                    content.removeEventListener("transitionend", onEnd);
                };
                content.addEventListener("transitionend", onEnd);
                setTimeout(() => {
                    if (Number(content.dataset.animToken) !== currentToken) return;
                    if (content.style.maxHeight === "0px") content.classList.remove("open");
                    content.removeEventListener("transitionend", onEnd);
                }, 650);
            }
        }

        function setupViewportHandling() {
            const onResize = () => {
                if (!window.visualViewport) return;
                const vv = window.visualViewport;
                const base = document.documentElement.clientHeight;
                const kb = Math.max(0, (base - vv.height - vv.offsetTop));
                document.documentElement.style.setProperty("--keyboard-offset", kb + "px");
                scheduleLayoutMetrics();
            };
            if (window.visualViewport) {
                window.visualViewport.addEventListener("resize", onResize);
                window.visualViewport.addEventListener("scroll", onResize);
                onResize();
            }
            window.addEventListener("resize", () => {
                scheduleLayoutMetrics();
                applyAutoDensityIfNeeded();
                if (window.visualViewport) onResize();
            });
        }

        async function initWakeLock() {
            if (!("wakeLock" in navigator)) return;
            let wakeLock = null;
            async function request() {
                try {
                    wakeLock = await navigator.wakeLock.request("screen");
                    wakeLock.addEventListener("release", () => { wakeLock = null; });
                } catch (_) { wakeLock = null; }
            }
            await request();
            document.addEventListener("visibilitychange", async () => {
                if (document.visibilityState === "visible" && wakeLock === null) await request();
            });
            window.addEventListener("pagehide", async () => {
                try { if (wakeLock) await wakeLock.release(); } catch(_){}
                wakeLock = null;
            });
        }

        function mergeIncomingCases(existingList, incomingList) {
            const map = new Map();
            existingList.forEach(item => { if (item && item.id) map.set(item.id, item); });
            let errorCount = 0;
            let successCount = 0;
            for (const item of incomingList) {
                if (!item || typeof item !== "object") continue;
                const incomingCloned = safeClone({ ...item, id: (item.id != null ? String(item.id) : genId()), isMaster: true }, "syncMaster.incomingClone");
                if (!incomingCloned) continue;
                incomingCloned.meta = incomingCloned.meta || {};
                incomingCloned.meta.source = "master";
                const rawId = incomingCloned.id;
                const id = rawId.startsWith("master_") ? rawId : ("master_" + rawId);
                incomingCloned.id = id;
                const existing = map.get(id);
                const incomingTime = toFiniteNumber(incomingCloned.updatedAt, 0);
                const existingTime = toFiniteNumber(existing?.updatedAt, 0);
                const normNew = normalizeCard(incomingCloned);
                if (existing) {
                    if (incomingTime && existingTime && incomingTime < existingTime) continue;
                    if (incomingTime === existingTime || !incomingTime) {
                        const fpA = getFingerprint(normNew);
                        const existingCloned = safeClone(existing, "syncMaster.existingClone");
                        if (existingCloned) {
                            const fpB = getFingerprint(normalizeCard(existingCloned));
                            if (fpA === fpB) continue;
                        }
                    }
                }
                normNew.updatedAt = incomingTime || 0;
                if (!validateCardShape(normNew)) { errorCount++; continue; }
                if (existing && Array.isArray(existing.keywords)) {
                    normNew.keywords = [...new Set([...(existing.keywords || []), ...(normNew.keywords || [])])];
                }
                map.set(id, normNew);
                successCount++;
            }
            return { list: Array.from(map.values()).slice(-STORAGE_LIMITS.cases), successCount, errorCount };
        }

        async function syncMaster() {
            if (syncRunning) return;
            if (!navigator.onLine) { updateStatusPill(); return; }
            syncRunning = true;
            updateStatusPill();
            const masterHash = appState.settings.masterHash || EXPECTED_MASTER_SHA256;
            try {
                if (!masterHash) {
                    showToast("Sync blockiert: Hash fehlt");
                    return;
                }
                const res = await fetchWithTimeout(MASTER_URL + "?t=" + Date.now(), { cache: "no-store" }, 6000, 1);
                if (!res.ok) { showToast("Sync Fehler: " + res.status); return; }
                const raw = await res.text();
                const hex = await sha256Hex(raw);
                if (hex !== masterHash) { showToast("Sync Integrität Fehler"); return; }
                let data;
                try { data = JSON.parse(raw); } catch(_) { showToast("Sync Daten defekt"); return; }
                if (!Array.isArray(data) || data.length === 0) return;
                await waitForDB();
                if (!db) {
                    const existing = sanitizeCases(loadLocalJSON(STORAGE_KEYS.cases, []));
                    const merge = mergeIncomingCases(existing, data);
                    const ok = saveLocalJSON(STORAGE_KEYS.cases, merge.list);
                    if (!ok) showToast("Speicher nicht verfügbar");
                    casesCache = merge.list;
                    if (merge.errorCount > 0) showToast(`Sync: ${merge.successCount} ok, ${merge.errorCount} Fehler`);
                    return;
                }
                let txAborted = false;
                let errorCount = 0;
                let successCount = 0;
                const tx = db.transaction("cases", "readwrite");
                tx.onerror = () => { txAborted = true; showToast("Sync abgebrochen"); };
                tx.onabort = () => { txAborted = true; };
                const store = tx.objectStore("cases");
                const existingReq = store.getAll();
                existingReq.onerror = () => { tx.abort(); };
                existingReq.onsuccess = () => {
                    try {
                        const list = (existingReq.result || []).filter(i => i && typeof i === "object" && i.id);
                        const existingMap = new Map(list.map(i => [i.id, i]));
                        for (const item of data) {
                            if (txAborted) break;
                            if (!item || typeof item !== "object") continue;
                            const incomingCloned = safeClone({ ...item, id: (item.id != null ? String(item.id) : genId()), isMaster: true }, "syncMaster.incomingClone");
                            if (!incomingCloned) continue;
                            incomingCloned.meta = incomingCloned.meta || {};
                            incomingCloned.meta.source = "master";
                            const rawId = incomingCloned.id;
                            const id = rawId.startsWith("master_") ? rawId : ("master_" + rawId);
                            incomingCloned.id = id;
                            const existing = existingMap.get(id);
                            const incomingTime = toFiniteNumber(incomingCloned.updatedAt, 0);
                            const existingTime = toFiniteNumber(existing?.updatedAt, 0);
                            const normNew = normalizeCard(incomingCloned);
                            if (existing) {
                                if (incomingTime && existingTime && incomingTime < existingTime) continue;
                                if (incomingTime === existingTime || !incomingTime) {
                                    const fpA = getFingerprint(normNew);
                                    const existingCloned = safeClone(existing, "syncMaster.existingClone");
                                    if (existingCloned) {
                                        const fpB = getFingerprint(normalizeCard(existingCloned));
                                        if (fpA === fpB) continue;
                                    }
                                }
                            }
                            normNew.updatedAt = incomingTime || 0;
                            if (!validateCardShape(normNew)) continue;
                            if (existing && Array.isArray(existing.keywords)) {
                                normNew.keywords = [...new Set([...(existing.keywords || []), ...(normNew.keywords || [])])];
                            }
                            try {
                                const req = store.put(normNew);
                                req.onsuccess = () => successCount++;
                                req.onerror = (e) => { e.preventDefault(); errorCount++; };
                            } catch (e) { errorCount++; }
                        }
                    } catch(_) { tx.abort(); }
                };
                tx.oncomplete = () => {
                    if (successCount > 0) loadCasesCache();
                    if (errorCount > 0) showToast(`Sync: ${successCount} ok, ${errorCount} Fehler`);
                };
            } catch(_) {
                showToast("Sync Fehler");
            } finally {
                syncRunning = false;
                updateStatusPill();
            }
        }

        async function exportData() {
            await waitForDB();
            if (!db && !localStorageAvailable) { showToast("Speicher nicht verfügbar"); return; }
            let cases = [];
            let logs = [];
            let settings = null;
            if (!db) {
                cases = sanitizeCases(loadLocalJSON(STORAGE_KEYS.cases, []));
                logs = (loadLocalJSON(STORAGE_KEYS.logs, []) || []).map(sanitizeLog);
                settings = loadLocalJSON(STORAGE_KEYS.settings, null);
                if (settings) settings = sanitizeSettings(settings);
            } else {
                const tx = db.transaction(["cases", "logs", "settings"], "readonly");
                const casesReq = tx.objectStore("cases").getAll();
                const logsReq = tx.objectStore("logs").getAll();
                const settingsReq = tx.objectStore("settings").get("main");
                [cases, logs, settings] = await Promise.all([
                    new Promise(r => { casesReq.onsuccess = () => r(casesReq.result || []); casesReq.onerror = () => r([]); }),
                    new Promise(r => { logsReq.onsuccess = () => r(logsReq.result || []); logsReq.onerror = () => r([]); }),
                    new Promise(r => { settingsReq.onsuccess = () => r(settingsReq.result || null); settingsReq.onerror = () => r(null); })
                ]);
                if (settings) settings = sanitizeSettings(settings);
            }
            const data = {
                version: BUILD_SIGNATURE,
                exportDate: new Date().toISOString(),
                settings,
                cases,
                logs
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `mehic_sales_os_export_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            showToast("Daten exportiert");
        }

        async function importData(file) {
            await waitForDB();
            if (!db && !localStorageAvailable) { showToast("Speicher nicht verfügbar"); return; }
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const parsed = JSON.parse(String(e.target.result || "{}"));
                    const data = sanitizeImportData(parsed);
                    const confirmed = await showConfirm({
                        title: "Import bestätigen",
                        message: "Import überschreibt lokale Daten. Fortfahren?",
                        confirmText: "Importieren"
                    });
                    if (!confirmed) return;
                    if (!db) {
                        saveLocalJSON(STORAGE_KEYS.cases, data.cases);
                        saveLocalJSON(STORAGE_KEYS.logs, data.logs);
                        saveLocalJSON(STORAGE_KEYS.settings, data.settings);
                        appState.settings = { ...appState.settings, ...data.settings, apiKey: appState.settings.apiKey };
                        await loadCasesCache();
                        applyTheme(appState.settings.theme);
                        applyDensity(appState.settings.density);
                        showToast("Import abgeschlossen");
                        render();
                        return;
                    }
                    const tx = db.transaction(["cases", "logs", "settings"], "readwrite");
                    data.cases.forEach(item => tx.objectStore("cases").put(item));
                    data.logs.forEach(log => tx.objectStore("logs").add(log));
                    tx.objectStore("settings").put({ id: "main", ...data.settings });
                    tx.oncomplete = async () => {
                        appState.settings = { ...appState.settings, ...data.settings, apiKey: appState.settings.apiKey };
                        await loadCasesCache();
                        applyTheme(appState.settings.theme);
                        applyDensity(appState.settings.density);
                        showToast("Import abgeschlossen");
                        render();
                    };
                    tx.onerror = () => showToast("Import fehlgeschlagen");
                } catch (_) {
                    showToast("Import fehlgeschlagen");
                }
            };
            reader.readAsText(file);
        }

        function resetApp() {
            haptic([50]);
            appState.objection = "";
            appState.contexts = [];
            appState.cards = [];
            appState.error = null;
            pendingObjection = null;
            dom.objectionInput.value = "";
            document.querySelectorAll(".chip.active").forEach(x => {
                x.classList.remove("active");
                x.setAttribute("aria-pressed", "false");
            });
            render();
        }

        async function doHardReset() {
            await waitForDB();
            if (!db) {
                if (!localStorageAvailable) { showToast("DB nicht bereit"); return; }
                localStorage.removeItem(STORAGE_KEYS.cases);
                localStorage.removeItem(STORAGE_KEYS.logs);
                localStorage.removeItem(STORAGE_KEYS.settings);
                showToast("System wird zurückgesetzt...");
                location.reload();
                return;
            }
            appState.loading = true;
            render();
            micRunning = false;
            pendingObjection = null;
            try { if (micStartWatchdog) { clearTimeout(micStartWatchdog); micStartWatchdog = null; } } catch(_){}
            try { if (recognition) recognition.abort(); } catch(_){}
            const tx = db.transaction(["cases", "logs", "settings"], "readwrite");
            tx.oncomplete = () => location.reload();
            tx.onerror = () => location.reload();
            tx.objectStore("cases").clear();
            tx.objectStore("logs").clear();
            tx.objectStore("settings").clear();
            showToast("System wird zurückgesetzt...");
        }

        function setupEvents() {
            document.querySelector(".header-right").addEventListener("click", (e) => e.stopPropagation());

            dom.themeToggle.addEventListener("click", async () => {
                const idx = THEME_ORDER.indexOf(appState.settings.theme);
                const next = THEME_ORDER[(idx + 1) % THEME_ORDER.length];
                appState.settings.theme = next;
                applyTheme(next);
                const ok = await saveSettings(appState.settings);
                if (!ok) showToast("Theme nicht gespeichert");
            });

            dom.densityToggle.addEventListener("click", async () => {
                const idx = DENSITY_ORDER.indexOf(appState.settings.density);
                const next = DENSITY_ORDER[(idx + 1) % DENSITY_ORDER.length];
                appState.settings.density = next;
                appState.settings.densityLocked = true;
                applyDensity(next);
                const ok = await saveSettings(appState.settings);
                if (!ok) showToast("Dichte nicht gespeichert");
                render();
            });

            document.getElementById("settingsBtn").onclick = (e) => {
                e.stopPropagation();
                haptic([30]);
                openSettingsModal();
            };
            document.getElementById("closeSettingsBtn").onclick = () => closeSettingsModal();
            document.getElementById("cancelSettingsBtn").onclick = () => closeSettingsModal();

            dom.settingsModal.addEventListener("click", (e) => {
                if (e.target === dom.settingsModal) closeSettingsModal();
            });

            dom.unlockBtn.addEventListener("click", async () => {
                const pass = dom.unlockPassphrase.value.trim();
                if (!pass) { showToast("Passphrase fehlt"); return; }
                const ok = await unlockSession(pass);
                if (!ok) {
                    showToast("Passphrase falsch");
                    dom.unlockPassphrase.focus();
                    return;
                }
                dom.unlockPassphrase.value = "";
                hideLockPanel();
                showToast("Session entsperrt");
                const first = getFirstFocusable(dom.settingsModal);
                if (first) first.focus();
            });

            dom.unlockPassphrase.addEventListener("keydown", (e) => {
                if (e.key === "Enter") dom.unlockBtn.click();
            });

            dom.unlockCancelBtn.addEventListener("click", () => closeSettingsModal());

            dom.lockRemoveBtn.addEventListener("click", async () => {
                if (!appState.settings.lockHash) { showToast("Kein Lock aktiv"); return; }
                const confirmed = await showConfirm({
                    title: "Lock entfernen",
                    message: "Session Lock wirklich entfernen?",
                    confirmText: "Entfernen"
                });
                if (!confirmed) return;
                appState.settings.lockHash = "";
                appState.settings.lockTimeoutMin = 30;
                lockSession();
                dom.lockPassphrase.value = "";
                dom.lockPassphraseConfirm.value = "";
                dom.lockTimeout.value = String(appState.settings.lockTimeoutMin);
                await saveSettings(appState.settings);
                showToast("Lock entfernt");
            });

            dom.confirmModal.addEventListener("click", (e) => {
                if (e.target === dom.confirmModal) closeConfirm(false);
            });

            dom.confirmOkBtn.addEventListener("click", () => closeConfirm(true));
            dom.confirmCancelBtn.addEventListener("click", () => closeConfirm(false));
            dom.confirmCloseBtn.addEventListener("click", () => closeConfirm(false));

            dom.settingsModal.addEventListener("keydown", (e) => {
                if (e.key !== "Tab") return;
                const focusables = Array.from(dom.settingsModal.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'))
                    .filter(el => isFocusable(el));
                if (focusables.length === 0) { e.preventDefault(); return; }
                const first = focusables[0];
                const last = focusables[focusables.length - 1];
                if (e.shiftKey) {
                    if (document.activeElement === first || !dom.settingsModal.contains(document.activeElement)) {
                        e.preventDefault();
                        last.focus();
                    }
                } else {
                    if (document.activeElement === last || !dom.settingsModal.contains(document.activeElement)) {
                        e.preventDefault();
                        first.focus();
                    }
                }
            });

            dom.confirmModal.addEventListener("keydown", (e) => {
                if (e.key !== "Tab") return;
                const focusables = Array.from(dom.confirmModal.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'))
                    .filter(el => isFocusable(el));
                if (focusables.length === 0) { e.preventDefault(); return; }
                const first = focusables[0];
                const last = focusables[focusables.length - 1];
                if (e.shiftKey) {
                    if (document.activeElement === first || !dom.confirmModal.contains(document.activeElement)) {
                        e.preventDefault();
                        last.focus();
                    }
                } else {
                    if (document.activeElement === last || !dom.confirmModal.contains(document.activeElement)) {
                        e.preventDefault();
                        first.focus();
                    }
                }
            });

            document.addEventListener("focusin", (e) => {
                if (modalClosing) return;
                if (dom.confirmModal.classList.contains("open")) return;
                if (dom.settingsModal.classList.contains("open") && !dom.settingsModal.contains(e.target)) {
                    const first = getFirstFocusable(dom.settingsModal);
                    if (first) first.focus();
                }
            });

            document.addEventListener("keydown", (e) => {
                if (e.key === "Escape") {
                    if (dom.confirmModal.classList.contains("open")) {
                        closeConfirm(false);
                        return;
                    }
                    if (dom.stealthOverlay.classList.contains("active")) {
                        dom.stealthOverlay.classList.remove("active");
                        dom.stealthOverlay.setAttribute("aria-hidden", "true");
                    }
                    closeSettingsModal();
                }
                if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "k") {
                    if (dom.confirmModal.classList.contains("open")) return;
                    if (appState.objection.trim() === "" && !dom.settingsModal.classList.contains("open")) {
                        e.preventDefault();
                        dom.objectionInput.focus();
                    }
                }
            });

            dom.objectionInput.addEventListener("input", (e) => {
                appState.objection = e.target.value;
                if (appState.loading) pendingObjection = appState.objection;
            });

            dom.objectionInput.addEventListener("keydown", (e) => {
                if (e.key === "Enter") {
                    appState.objection = e.target.value;
                    handleObjection();
                    e.target.blur();
                }
            });

            document.getElementById("resetBtn").onclick = (e) => {
                e.stopPropagation();
                resetApp();
            };

            let lastHeaderTap = 0;
            document.getElementById("header").onclick = (e) => {
                if (e.target.closest(".header-right")) return;
                const now = Date.now();
                if (now - lastHeaderTap < 400) {
                    dom.stealthOverlay.classList.toggle("active");
                    dom.stealthOverlay.setAttribute("aria-hidden", dom.stealthOverlay.classList.contains("active") ? "false" : "true");
                }
                lastHeaderTap = now;
            };
            dom.stealthOverlay.onclick = () => {
                dom.stealthOverlay.classList.remove("active");
                dom.stealthOverlay.setAttribute("aria-hidden", "true");
            };

            document.getElementById("contextChips").addEventListener("click", (e) => {
                const chip = e.target.closest(".chip");
                if (!chip) return;
                const ctx = chip.dataset.context;
                if (appState.contexts.includes(ctx)) {
                    appState.contexts = appState.contexts.filter(c => c !== ctx);
                    chip.classList.remove("active");
                    chip.setAttribute("aria-pressed", "false");
                } else {
                    appState.contexts.push(ctx);
                    chip.classList.add("active");
                    chip.setAttribute("aria-pressed", "true");
                }
            });

            dom.cardsContainer.addEventListener("click", (e) => {
                const trigger = e.target.closest('[data-action="toggle"]');
                if (trigger) {
                    haptic([20]);
                    toggleExpandable(trigger);
                }
                const feedbackBtn = e.target.closest(".feedback-btn");
                if (feedbackBtn) {
                    haptic([30]);
                    const feedback = feedbackBtn.dataset.feedback;
                    const cardId = feedbackBtn.dataset.card;
                    logEvent("feedback", { cardId, feedback });
                    showToast(feedback === "success" ? "Feedback gespeichert" : "Danke für Ihr Feedback");
                }
            });

            document.getElementById("saveSettingsBtn").onclick = async () => {
                appState.settings.theme = dom.themeSelect.value;
                appState.settings.density = dom.densitySelect.value;
                appState.settings.densityLocked = true;
                appState.settings.apiProvider = dom.apiProvider.value;
                appState.settings.modelName = dom.modelName.value.trim();
                appState.settings.department = dom.department.value;
                appState.settings.storePolicy = dom.storePolicy.value.trim();
                const proxyRaw = dom.proxyUrl.value.trim();
                const proxy = validateProxyUrl(proxyRaw);
                if (proxyRaw && !proxy) { showToast("Proxy URL ungültig"); dom.proxyUrl.focus(); return; }
                appState.settings.proxyUrl = proxy;
                const masterHashRaw = dom.masterHash.value.trim().toLowerCase();
                if (masterHashRaw && !/^[a-f0-9]{64}$/i.test(masterHashRaw)) {
                    showToast("Master Hash ungültig");
                    dom.masterHash.focus();
                    return;
                }
                appState.settings.masterHash = masterHashRaw;
                const newKey = dom.apiKey.value.trim();
                if (newKey) appState.settings.apiKey = newKey;
                const pass = dom.lockPassphrase.value.trim();
                const passConfirm = dom.lockPassphraseConfirm.value.trim();
                const timeoutMin = Math.min(240, Math.max(5, toFiniteNumber(dom.lockTimeout.value, appState.settings.lockTimeoutMin || 30)));
                if (pass || passConfirm) {
                    if (pass !== passConfirm) { showToast("Passphrase stimmt nicht"); return; }
                    if (pass.length < 6) { showToast("Passphrase zu kurz"); return; }
                    appState.settings.lockHash = await hashPassphrase(pass);
                    appState.settings.lockTimeoutMin = timeoutMin;
                    lockSession();
                    await unlockSession(pass);
                } else if (appState.settings.lockHash) {
                    appState.settings.lockTimeoutMin = timeoutMin;
                }
                applyTheme(appState.settings.theme);
                applyDensity(appState.settings.density);
                const ok = await saveSettings(appState.settings);
                appState.settings = { ...appState.settings, ...sanitizeSettings(appState.settings), apiKey: appState.settings.apiKey };
                closeSettingsModal();
                showToast(ok ? "Einstellungen gespeichert" : "Fehler beim Speichern");
                render();
            };

            document.getElementById("exportBtn").onclick = exportData;
            document.getElementById("importBtn").onclick = () => document.getElementById("importFile").click();
            document.getElementById("importFile").addEventListener("change", (e) => {
                if (!e.target.files || e.target.files.length === 0) return;
                importData(e.target.files[0]);
                e.target.value = "";
            });

            let resetHoldTimer = null;
            const clearBtn = document.getElementById("clearBtn");
            const cancelReset = () => {
                if (resetHoldTimer) clearTimeout(resetHoldTimer);
                resetHoldTimer = null;
                clearBtn.classList.remove("active");
            };
            clearBtn.onpointerdown = (e) => {
                e.preventDefault();
                cancelReset();
                resetHoldTimer = setTimeout(() => {
                    clearBtn.classList.add("active");
                    showConfirm({
                        title: "Daten löschen",
                        message: "Alle Daten werden gelöscht. Fortfahren?",
                        confirmText: "Löschen"
                    }).then((confirmed) => {
                        if (confirmed) {
                            doHardReset();
                        } else {
                            clearBtn.classList.remove("active");
                            showToast("Abgebrochen");
                        }
                    });
                }, 1200);
                showToast("Halten zum Zurücksetzen...");
            };
            clearBtn.onpointerup = cancelReset;
            clearBtn.onpointerleave = cancelReset;
            clearBtn.onpointercancel = cancelReset;
            clearBtn.addEventListener("touchend", cancelReset, { passive: true });
            clearBtn.addEventListener("touchcancel", cancelReset, { passive: true });

            window.addEventListener("online", () => {
                updateStatusPill();
                showToast("Online");
                syncMaster();
            });
            window.addEventListener("offline", () => {
                updateStatusPill();
                showToast("Offline");
            });

            document.addEventListener("visibilitychange", () => {
                if (document.visibilityState !== "visible" && appState.settings.lockHash) {
                    lockSession();
                }
            });

            window.addEventListener("popstate", () => {
                if (ignoreNextPop) { ignoreNextPop = false; return; }
                if (dom.confirmModal.classList.contains("open")) { closeConfirm(false); return; }
                if (dom.settingsModal.classList.contains("open")) closeSettingsModal({ skipHistory: true });
            });

            reducedMotionQuery.addEventListener("change", (e) => { reducedMotion = e.matches; });
            const themeMedia = window.matchMedia("(prefers-color-scheme: dark)");
            const onThemeChange = () => {
                if (appState.settings.theme === "auto") updateThemeColorMeta();
            };
            if (themeMedia.addEventListener) themeMedia.addEventListener("change", onThemeChange);
            else if (themeMedia.addListener) themeMedia.addListener(onThemeChange);

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (SpeechRecognition) {
                recognition = new SpeechRecognition();
                recognition.lang = "de-AT";
                recognition.interimResults = false;
                recognition.maxAlternatives = 1;
                recognition.onstart = () => {
                    if (micStartWatchdog) { clearTimeout(micStartWatchdog); micStartWatchdog = null; }
                    dom.micBtn.classList.add("processing");
                };
                recognition.onresult = (e) => {
                    const t = e?.results?.[0]?.[0]?.transcript || "";
                    if (!t) return;
                    appState.objection = t;
                    dom.objectionInput.value = t;
                    handleObjection();
                };
                recognition.onerror = () => {
                    if (micStartWatchdog) { clearTimeout(micStartWatchdog); micStartWatchdog = null; }
                    micRunning = false;
                    dom.micBtn.classList.remove("processing");
                    showToast("Mikrofon Fehler");
                };
                recognition.onend = () => {
                    if (micStartWatchdog) { clearTimeout(micStartWatchdog); micStartWatchdog = null; }
                    micRunning = false;
                    dom.micBtn.classList.remove("processing");
                };
                dom.micBtn.onclick = () => {
                    if (appState.loading || micRunning) return;
                    micRunning = true;
                    if (micStartWatchdog) clearTimeout(micStartWatchdog);
                    micStartWatchdog = setTimeout(() => {
                        try { recognition.abort(); } catch(_){}
                        micRunning = false;
                        dom.micBtn.classList.remove("processing");
                        showToast("Mikrofon Timeout");
                    }, 1500);
                    try { recognition.start(); }
                    catch (_) {
                        if (micStartWatchdog) clearTimeout(micStartWatchdog);
                        micRunning = false;
                        showToast("Mikrofon nicht verfügbar");
                    }
                };
            } else {
                dom.micBtn.style.display = "none";
            }
        }

        async function init() {
            bindDom();
            setupViewportHandling();
            updateStatusPill();
            localStorageAvailable = isLocalStorageAvailable();
            await initDB();
            await waitForDB();
            const saved = await loadSettings();
            if (saved) {
                appState.settings = { ...appState.settings, ...saved, apiKey: "" };
            }
            const isCoarse = window.matchMedia("(pointer: coarse)").matches;
            if (!saved || !saved.density) {
                appState.settings.density = isCoarse ? "comfortable" : "compact";
            }
            if (!saved || !saved.theme) {
                appState.settings.theme = "auto";
            }
            if (!appState.settings.masterHash && EXPECTED_MASTER_SHA256) {
                appState.settings.masterHash = EXPECTED_MASTER_SHA256;
            }
            applyTheme(appState.settings.theme);
            applyDensity(appState.settings.density);
            lastAutoDensity = appState.settings.density;
            applyAutoDensityIfNeeded();
            await saveSettings(appState.settings);
            await loadCasesCache();
            setupEvents();
            initWakeLock();
            setTimeout(syncMaster, 1000);
            document.getElementById("buildInfo").textContent = BUILD_SIGNATURE;
            render();
        }

        init();
    </script>
</body>
</html>
