<!DOCTYPE html>
<!--
Executive Summary:
- Minimal-Header mit Status-Dot und Quick-Panel-Zugriff für Retail-Speed.
- Sales First: Hero-Input, Kontext-Chips, sofortige Antwortkarten.
- Quick Panel bündelt Modus, Theme/Density, Datenaktionen, Danger Zone.
- Training Frame als KPI + Drill mit Top-3-Schwächen und Verlauf.
- Wiki erzwingt Datenblatt-Check, keine erfundenen Specs.
- Security & A11y bleiben aktiv (CSP, Focus, Tap Targets, Offline).
-->
<html lang="de" data-theme="light" data-density="comfortable" data-debug="false" data-frame="sales">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="color-scheme" content="light dark">
    <meta name="theme-color" content="#F3F4F6" id="themeColorMeta">
    <meta name="referrer" content="no-referrer">
    <meta http-equiv="Content-Security-Policy" content="default-src 'none'; base-uri 'self'; form-action 'self'; img-src 'self' data:; font-src 'self'; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline'; connect-src 'self' https://api.openai.com https://api.groq.com; frame-ancestors 'none'; object-src 'none';">
    <!-- CSP Level 2 (Enterprise, hash-based, no unsafe-inline):
         Content-Security-Policy: default-src 'none'; base-uri 'self'; form-action 'self'; img-src 'self' data:; font-src 'self'; style-src 'self' 'sha256-M4sENJrqBVCDv+mUS/Xrapwi66pZn/GK7b1VFlYbuAs='; script-src 'self' 'sha256-S/ySjqTl5V92Ch0CpgyK4oh71Ka7qeSo4DlQTi4tj0k=' 'sha256-+6vfCGl5FxFFbtiAodhL+PgaVRAKIFMgPVgoCrs9/DM='; connect-src 'self' https://api.openai.com https://api.groq.com; frame-ancestors 'none'; object-src 'none';
         Hash calculation details: see REPORT.md
    -->
    <script>
        (() => {
            try {
                const raw = localStorage.getItem("msos_settings");
                if (!raw) return;
                const settings = JSON.parse(raw);
                const frame = settings && settings.frameMode;
                if (["sales", "training", "wiki"].includes(frame)) {
                    document.documentElement.setAttribute("data-frame", frame);
                }
            } catch {
                // ignore storage errors
            }
        })();
    </script>
    <title>MEHIC SALES OS — Enterprise RC 2026</title>
    <style>
        *,
        *::before,
        *::after {
            box-sizing: border-box;
        }

        html {
            height: 100%;
            text-size-adjust: 100%;
        }

        :root {
            --font-sans: system-ui, -apple-system, "SF Pro Text", "Segoe UI", "Helvetica Neue", Arial, sans-serif;
            --font-mono: ui-monospace, "SF Mono", Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;

            --color-bg: #F3F4F6;
            --color-surface: #FFFFFF;
            --color-elevated: #FFFFFF;
            --color-border: rgba(0, 0, 0, 0.06);
            --color-divider: rgba(0, 0, 0, 0.08);
            --color-text-primary: #111827;
            --color-text-secondary: #6B7280;
            --color-text-muted: #9CA3AF;
            --color-accent: #E3000F;
            --color-danger: #DC2626;
            --color-warning: #F59E0B;
            --color-success: #10B981;
            --color-glass: rgba(255, 255, 255, 0.72);
            --color-glass-border: rgba(255, 255, 255, 0.35);
            --color-focus: rgba(227, 0, 15, 0.35);
            --color-selection: rgba(227, 0, 15, 0.18);
            --color-hover: rgba(17, 24, 39, 0.04);
            --color-pressed: rgba(17, 24, 39, 0.08);
            --color-toast: #111827;
            --color-toast-text: #FFFFFF;
            --color-skeleton-base: #E5E7EB;
            --color-skeleton-shine: #F3F4F6;
            --color-scrollbar-thumb: rgba(17, 24, 39, 0.25);
            --color-scrollbar-track: rgba(17, 24, 39, 0.08);
            --color-backdrop: rgba(0, 0, 0, 0.6);

            --shadow-1: 0 1px 2px rgba(0, 0, 0, 0.06);
            --shadow-2: 0 8px 24px rgba(0, 0, 0, 0.08);
            --shadow-3: 0 20px 48px rgba(0, 0, 0, 0.12);

            --radius-1: 10px;
            --radius-2: 14px;
            --radius-3: 18px;
            --radius-pill: 999px;

            --space-1: 4px;
            --space-2: 8px;
            --space-3: 12px;
            --space-4: 16px;
            --space-5: 20px;
            --space-6: 24px;
            --space-7: 32px;
            --space-8: 40px;

            --tap-min: 44px;
            --font-size-base: 16px;
            --tile-padding: 24px;
            --control-bar-padding: 20px;
            --input-height: 54px;

            --easing-standard: cubic-bezier(0.2, 0.8, 0.2, 1);
            --duration-fast: 120ms;
            --duration-medium: 240ms;
            --duration-slow: 360ms;
            --outline-offset: 2px;

            --safe-top: env(safe-area-inset-top);
            --safe-bottom: env(safe-area-inset-bottom);
            --safe-left: env(safe-area-inset-left);
            --safe-right: env(safe-area-inset-right);

            --keyboard-offset: 0px;
            --control-bar-height: 0px;
            --panel-width: 360px;
        }

        html[data-theme="dark"] {
            --color-bg: #09090B;
            --color-surface: #18181B;
            --color-elevated: #1F1F23;
            --color-border: #27272A;
            --color-divider: rgba(255, 255, 255, 0.08);
            --color-text-primary: #FAFAFA;
            --color-text-secondary: #A1A1AA;
            --color-text-muted: #71717A;
            --color-accent: #E3000F;
            --color-danger: #F43F5E;
            --color-warning: #FBBF24;
            --color-success: #34D399;
            --color-glass: rgba(24, 24, 27, 0.7);
            --color-glass-border: rgba(255, 255, 255, 0.08);
            --color-focus: rgba(227, 0, 15, 0.45);
            --color-selection: rgba(227, 0, 15, 0.28);
            --color-hover: rgba(250, 250, 250, 0.06);
            --color-pressed: rgba(250, 250, 250, 0.12);
            --color-toast: #F8FAFC;
            --color-toast-text: #0B0B0D;
            --color-skeleton-base: #27272A;
            --color-skeleton-shine: #1F1F23;
            --color-scrollbar-thumb: rgba(250, 250, 250, 0.25);
            --color-scrollbar-track: rgba(250, 250, 250, 0.08);

            --shadow-1: 0 1px 2px rgba(0, 0, 0, 0.4);
            --shadow-2: 0 10px 30px rgba(0, 0, 0, 0.5);
            --shadow-3: 0 24px 60px rgba(0, 0, 0, 0.6);
        }

        html[data-density="compact"] {
            --tile-padding: 18px;
            --control-bar-padding: 16px;
            --font-size-base: 14px;
            --input-height: 46px;
            --tap-min: 44px;
        }

        html[data-density="comfortable"] {
            --tile-padding: 24px;
            --control-bar-padding: 20px;
            --font-size-base: 16px;
            --input-height: 54px;
            --tap-min: 48px;
        }

        body {
            margin: 0;
            font-family: var(--font-sans);
            font-size: var(--font-size-base);
            line-height: 1.6;
            font-variant-numeric: tabular-nums;
            background: var(--color-bg);
            color: var(--color-text-primary);
            -webkit-font-smoothing: antialiased;
            text-rendering: optimizeLegibility;
            overflow-x: hidden;
            min-height: 100dvh;
            display: flex;
            flex-direction: column;
        }

        ::selection {
            background: var(--color-selection);
        }

        a {
            color: inherit;
        }

        button,
        input,
        select,
        textarea {
            font: inherit;
            color: inherit;
        }

        button {
            background: none;
            border: none;
            padding: 0;
            cursor: pointer;
            touch-action: manipulation;
        }

        button:disabled,
        input:disabled,
        select:disabled,
        textarea:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        button:focus-visible,
        input:focus-visible,
        select:focus-visible,
        textarea:focus-visible,
        a:focus-visible,
        [tabindex="0"]:focus-visible {
            outline: 2px solid transparent;
            box-shadow: 0 0 0 3px var(--color-focus);
            outline-offset: var(--outline-offset);
        }

        .skip-link {
            position: absolute;
            left: -999px;
            top: 0;
            background: var(--color-accent);
            color: #FFFFFF;
            padding: var(--space-2) var(--space-4);
            border-radius: var(--radius-2);
            z-index: 5000;
        }

        .skip-link:focus {
            left: var(--space-4);
            top: calc(var(--space-4) + var(--safe-top));
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            border: 0;
        }

        .header {
            position: sticky;
            top: 0;
            z-index: 200;
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
            gap: var(--space-3);
            padding: calc(var(--space-3) + var(--safe-top)) calc(var(--space-5) + var(--safe-right)) var(--space-3) calc(var(--space-5) + var(--safe-left));
            background: var(--color-glass);
            border-bottom: 1px solid var(--color-divider);
            box-shadow: var(--shadow-1);
            backdrop-filter: blur(18px);
            -webkit-backdrop-filter: blur(18px);
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: var(--space-3);
        }

        .header-center {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .logo-container {
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }

        .logo-svg {
            width: 32px;
            height: 32px;
        }

        .logo-text {
            font-size: 14px;
            font-weight: 800;
            letter-spacing: 0.4px;
            color: var(--color-text-primary);
        }

        .logo-text span {
            font-weight: 300;
            color: var(--color-text-secondary);
        }

        .header-actions {
            display: none;
        }

        .segment-control {
            display: inline-flex;
            align-items: center;
            gap: var(--space-1);
            padding: 4px;
            border-radius: var(--radius-pill);
            background: var(--color-elevated);
            border: 1px solid var(--color-border);
            min-height: var(--tap-min);
        }

        .segment-btn {
            padding: 6px 12px;
            border-radius: var(--radius-pill);
            font-size: 12px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--color-text-secondary);
            background: transparent;
            min-height: calc(var(--tap-min) - 10px);
        }

        .segment-btn[aria-pressed="true"] {
            background: var(--color-accent);
            color: #FFFFFF;
        }

        .status-pill {
            display: inline-flex;
            align-items: center;
            gap: var(--space-2);
            padding: 4px 10px;
            border-radius: var(--radius-pill);
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.6px;
            background: transparent;
            border: 1px solid var(--color-border);
            min-height: 32px;
        }

        .status-pill[data-status="online"] .status-dot {
            background: var(--color-success);
        }

        .status-pill[data-status="offline"] .status-dot {
            background: var(--color-danger);
        }

        .status-pill[data-status="syncing"] .status-dot {
            background: var(--color-warning);
        }

        .status-pill[data-status="error"] .status-dot {
            background: var(--color-danger);
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        @keyframes statusPulse {
            0%, 100% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.2); opacity: 1; }
        }

        .status-pill[data-status="syncing"] .status-dot {
            animation: statusPulse 1.2s var(--easing-standard) infinite;
        }

        @media (prefers-reduced-motion: reduce) {
            .status-pill[data-status="syncing"] .status-dot {
                animation: none;
            }
        }

        .dept-badge {
            padding: 4px 10px;
            border-radius: var(--radius-pill);
            font-size: 12px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            background: var(--color-accent);
            color: #FFFFFF;
            min-height: 32px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow-1);
        }

        .toggle-btn {
            display: inline-flex;
            align-items: center;
            gap: var(--space-2);
            padding: 8px 12px;
            border-radius: var(--radius-pill);
            border: 1px solid var(--color-border);
            background: var(--color-surface);
            min-height: var(--tap-min);
            transition: background var(--duration-fast) var(--easing-standard), border var(--duration-fast) var(--easing-standard);
        }

        .toggle-btn:hover {
            background: var(--color-hover);
        }

        .toggle-btn:active {
            background: var(--color-pressed);
        }

        .toggle-btn svg {
            width: 18px;
            height: 18px;
            stroke: var(--color-text-primary);
            fill: none;
            stroke-width: 2;
        }

        .toggle-label {
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.4px;
            color: var(--color-text-secondary);
            white-space: nowrap;
        }

        .icon-btn {
            width: var(--tap-min);
            height: var(--tap-min);
            border-radius: var(--radius-2);
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: transform var(--duration-fast) var(--easing-standard), background var(--duration-fast) var(--easing-standard);
        }

        .icon-btn:hover {
            background: var(--color-hover);
        }

        .icon-btn:active {
            transform: scale(0.98);
            background: var(--color-pressed);
        }

        .icon-btn svg {
            width: 18px;
            height: 18px;
            stroke: var(--color-text-primary);
            fill: none;
            stroke-width: 2.2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .offline-banner {
            display: none;
            align-items: center;
            justify-content: center;
            gap: var(--space-2);
            padding: var(--space-2) var(--space-4);
            background: rgba(220, 38, 38, 0.12);
            color: var(--color-danger);
            font-weight: 700;
            font-size: 13px;
            letter-spacing: 0.3px;
            border-bottom: 1px solid var(--color-divider);
        }

        .offline-banner.show {
            display: flex;
        }

        body.panel-docked .offline-banner {
            padding-right: calc(var(--panel-width) + var(--space-5));
        }

        .stage {
            flex: 1;
            overflow-y: auto;
            padding: var(--space-6);
            padding-bottom: calc(var(--space-6) + var(--safe-bottom));
            overscroll-behavior: contain;
        }

        .bento-grid {
            display: grid;
            gap: var(--space-5);
            grid-template-columns: 1fr;
        }

        .frame-container {
            background: transparent;
            border: none;
            box-shadow: none;
            padding: 0;
            position: relative;
        }

        .frame-root {
            opacity: 0;
            pointer-events: none;
            position: absolute;
            inset: 0;
            transition: opacity var(--duration-medium) var(--easing-standard);
        }

        html[data-frame="sales"] #salesFrame,
        html[data-frame="training"] #trainingFrame,
        html[data-frame="wiki"] #wikiFrame {
            opacity: 1;
            pointer-events: auto;
            position: relative;
        }

        html[data-view-direction]::view-transition-old(root),
        html[data-view-direction]::view-transition-new(root) {
            animation-duration: var(--duration-medium);
            animation-timing-function: var(--easing-standard);
        }

        html[data-view-direction="forward"]::view-transition-old(root) {
            animation-name: slide-left-out;
        }

        html[data-view-direction="forward"]::view-transition-new(root) {
            animation-name: slide-left-in;
        }

        html[data-view-direction="backward"]::view-transition-old(root) {
            animation-name: slide-right-out;
        }

        html[data-view-direction="backward"]::view-transition-new(root) {
            animation-name: slide-right-in;
        }

        @keyframes slide-left-out {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(-8%); opacity: 0; }
        }

        @keyframes slide-left-in {
            from { transform: translateX(8%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes slide-right-out {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(8%); opacity: 0; }
        }

        @keyframes slide-right-in {
            from { transform: translateX(-8%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .sales-frame > * + * {
            margin-top: var(--space-4);
        }

        html[data-frame="sales"] .training-only,
        html[data-frame="training"] .sales-only {
            display: none !important;
        }

        html[data-frame="sales"] .bento-grid {
            grid-template-columns: 1fr;
        }

        html[data-frame="training"] .bento-grid {
            grid-template-columns: 1fr;
        }

        .sales-layout,
        .training-layout,
        .wiki-layout {
            display: grid;
            gap: var(--space-4);
            grid-template-columns: 1fr;
        }

        @media (min-width: 1024px) {
            .sales-layout {
                grid-template-columns: minmax(0, 2fr) minmax(0, 1fr);
                align-items: start;
            }

            .sales-history {
                position: sticky;
                top: calc(var(--space-6) + var(--safe-top));
            }

            .wiki-layout {
                grid-template-columns: minmax(0, 1.1fr) minmax(0, 1.4fr);
            }
        }

        @media (min-width: 1200px) {
            .training-layout {
                grid-template-columns: repeat(3, minmax(0, 1fr));
            }
        }

        .history-section {
            margin-top: var(--space-3);
            display: grid;
            gap: var(--space-2);
        }

        .history-meta {
            font-size: 11px;
            color: var(--color-text-muted);
            text-transform: uppercase;
            letter-spacing: 0.6px;
            font-weight: 700;
        }

        .wiki-detail-grid {
            display: grid;
            gap: var(--space-3);
            margin-top: var(--space-3);
        }

        .spec-grid,
        .tag-row {
            display: grid;
            gap: var(--space-2);
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        }

        .spec-item,
        .tag-item {
            padding: 8px 10px;
            border-radius: var(--radius-2);
            border: 1px solid var(--color-border);
            background: var(--color-elevated);
            font-size: 12px;
        }

        .tile {
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-3);
            padding: var(--tile-padding);
            box-shadow: var(--shadow-1);
            position: relative;
            container-type: inline-size;
        }

        .tile.glass {
            background: var(--color-glass);
            border: 1px solid var(--color-glass-border);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
        }

        .tile-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: var(--space-3);
            margin-bottom: var(--space-4);
        }

        .tile-title {
            font-size: 13px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--color-text-secondary);
        }

        .tile-subtitle {
            font-size: 20px;
            font-weight: 800;
            color: var(--color-text-primary);
            margin-top: var(--space-2);
        }

        .tile-desc {
            font-size: 14px;
            color: var(--color-text-secondary);
        }

        .diagnostics {
            display: none;
        }

        html[data-debug="true"] .diagnostics {
            display: block;
        }

        .diagnostics-grid {
            display: grid;
            gap: var(--space-2);
            margin-top: var(--space-3);
        }

        .diag-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--space-3);
            font-size: 12px;
            padding: 6px 8px;
            border-radius: var(--radius-1);
            background: var(--color-elevated);
            border: 1px solid var(--color-border);
        }

        .diag-key {
            color: var(--color-text-muted);
            text-transform: uppercase;
            letter-spacing: 0.6px;
            font-weight: 700;
        }

        .diag-value {
            color: var(--color-text-primary);
            font-weight: 700;
        }

        .stat-grid {
            display: grid;
            gap: var(--space-4);
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        }

        .stat {
            display: flex;
            flex-direction: column;
            gap: var(--space-1);
        }

        .stat-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--color-text-muted);
            font-weight: 700;
        }

        .stat-value {
            font-size: 20px;
            font-weight: 800;
            color: var(--color-text-primary);
        }

        .pill-row {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-2);
            margin-top: var(--space-4);
        }

        .pill {
            padding: 6px 10px;
            border-radius: var(--radius-pill);
            border: 1px solid var(--color-border);
            font-size: 12px;
            font-weight: 600;
            color: var(--color-text-secondary);
            background: var(--color-elevated);
        }

        .history-list,
        .pattern-list {
            display: grid;
            gap: var(--space-2);
            margin-top: var(--space-3);
        }

        .history-item,
        .pattern-item {
            text-align: left;
            padding: 8px 10px;
            border-radius: var(--radius-2);
            border: 1px solid var(--color-border);
            background: var(--color-elevated);
            font-size: 13px;
            color: var(--color-text-primary);
            min-height: var(--tap-min);
        }

        .history-meta,
        .pattern-meta {
            font-size: 11px;
            color: var(--color-text-muted);
            text-transform: uppercase;
            letter-spacing: 0.6px;
        }

        .variant-toggle {
            display: inline-flex;
            align-items: center;
            gap: var(--space-2);
            margin-bottom: var(--space-3);
            padding: 4px;
            border-radius: var(--radius-pill);
            border: 1px solid var(--color-border);
            background: var(--color-elevated);
        }

        .variant-btn {
            padding: 6px 12px;
            border-radius: var(--radius-pill);
            font-size: 12px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 0.4px;
            color: var(--color-text-secondary);
        }

        .variant-btn[aria-pressed="true"] {
            background: var(--color-accent);
            color: #FFFFFF;
        }

        .roleplay-box {
            margin-top: var(--space-3);
            padding: var(--space-3);
            border-radius: var(--radius-2);
            background: rgba(227, 0, 15, 0.08);
            border: 1px solid rgba(227, 0, 15, 0.2);
            font-size: 13px;
            color: var(--color-text-primary);
        }

        .microlearning {
            margin-top: var(--space-3);
            padding: var(--space-3);
            border-radius: var(--radius-2);
            border: 1px solid var(--color-border);
            background: var(--color-elevated);
            font-size: 12px;
            color: var(--color-text-secondary);
        }

        .sync-indicator {
            display: inline-flex;
            align-items: center;
            gap: var(--space-2);
            padding: 6px 12px;
            border-radius: var(--radius-pill);
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.6px;
            border: 1px solid var(--color-border);
            background: var(--color-elevated);
            white-space: nowrap;
        }

        .sync-indicator[data-status="syncing"] {
            color: var(--color-warning);
            border-color: rgba(245, 158, 11, 0.4);
        }

        .sync-indicator[data-status="ok"] {
            color: var(--color-success);
            border-color: rgba(16, 185, 129, 0.4);
        }

        .sync-indicator[data-status="error"],
        .sync-indicator[data-status="offline"] {
            color: var(--color-danger);
            border-color: rgba(220, 38, 38, 0.4);
        }

        .shortcut-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--space-3);
            padding: var(--space-2) 0;
            border-bottom: 1px solid var(--color-divider);
        }

        .shortcut-row:last-child {
            border-bottom: none;
        }

        .shortcut-key {
            font-family: var(--font-mono);
            font-size: 12px;
            font-weight: 700;
            padding: 4px 8px;
            border-radius: var(--radius-1);
            background: var(--color-elevated);
            border: 1px solid var(--color-border);
        }

        .bento-cards {
            display: contents;
        }

        .card {
            position: relative;
            overflow: hidden;
        }

        .card::before {
            content: "";
            position: absolute;
            left: 0;
            top: 0;
            width: 4px;
            height: 100%;
            background: var(--color-accent);
        }

        .card.success::before {
            background: var(--color-success);
        }

        .card.warning::before {
            background: var(--color-warning);
        }

        .card.error::before {
            background: var(--color-danger);
        }

        .card-header {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            margin-bottom: var(--space-4);
        }

        .card-icon {
            width: 28px;
            height: 28px;
            stroke: var(--color-accent);
            fill: none;
            stroke-width: 2.2;
        }

        .card-title {
            font-size: 13px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--color-text-secondary);
        }

        .card-badge {
            margin-left: auto;
            padding: 4px 8px;
            border-radius: var(--radius-1);
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.6px;
            background: var(--color-elevated);
            border: 1px solid var(--color-border);
            color: var(--color-text-secondary);
        }

        .card-header-actions {
            display: inline-flex;
            align-items: center;
            gap: var(--space-2);
            margin-left: auto;
        }

        .favorite-btn,
        .copy-btn {
            padding: 6px 8px;
            border-radius: var(--radius-2);
            border: 1px solid var(--color-border);
            background: var(--color-elevated);
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.4px;
            color: var(--color-text-secondary);
            min-height: 32px;
        }

        .favorite-btn[aria-pressed="true"] {
            color: var(--color-accent);
            border-color: rgba(227, 0, 15, 0.4);
        }

        .favorite-btn svg {
            width: 14px;
            height: 14px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
        }

        .copy-btn {
            font-size: 10px;
        }

        .quick-cues {
            display: grid;
            gap: var(--space-4);
        }

        .cue-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--space-2);
        }

        .cue-label {
            font-size: 11px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 1.2px;
            color: var(--color-text-muted);
            margin-bottom: var(--space-2);
        }

        .cue-text {
            font-size: 14px;
            color: var(--color-text-primary);
        }

        html[data-frame="sales"] .cue-text {
            font-size: 16px;
        }

        .cue-text.spacing {
            margin-bottom: var(--space-3);
        }

        .expandable {
            margin-top: var(--space-4);
            padding-top: var(--space-4);
            border-top: 1px solid var(--color-divider);
        }

        .expand-trigger {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            padding: var(--space-2) 0;
            font-size: 13px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--color-text-primary);
        }

        .expand-label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.6px;
            font-weight: 700;
            color: var(--color-text-secondary);
            margin-bottom: 6px;
        }

        .expand-trigger:hover {
            color: var(--color-text-secondary);
        }

        .expand-icon {
            width: 18px;
            height: 18px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2.2;
            transition: transform var(--duration-medium) var(--easing-standard);
        }

        .expand-icon.open {
            transform: rotate(180deg);
        }

        .expand-content {
            overflow: hidden;
            max-height: 0;
            opacity: 0;
            transition: max-height var(--duration-slow) var(--easing-standard), opacity var(--duration-medium) var(--easing-standard);
        }

        .expand-content.open {
            max-height: 2000px;
            opacity: 1;
            padding-top: var(--space-3);
        }

        .coach-block {
            margin-bottom: var(--space-4);
        }

        .coach-label {
            font-size: 11px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--color-accent);
            margin-bottom: var(--space-2);
        }

        .coach-text {
            font-size: 13px;
            color: var(--color-text-primary);
        }

        .drill-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .drill-list li {
            padding-left: 18px;
            position: relative;
            font-size: 13px;
            color: var(--color-text-secondary);
            margin-bottom: var(--space-2);
        }

        .drill-list li::before {
            content: "→";
            position: absolute;
            left: 0;
            color: var(--color-accent);
            font-weight: 900;
        }

        .card-actions {
            margin-top: var(--space-4);
            padding-top: var(--space-4);
            border-top: 1px solid var(--color-divider);
            display: grid;
            gap: var(--space-3);
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        }

        .feedback-btn {
            padding: 10px;
            border-radius: var(--radius-2);
            border: 1px solid var(--color-border);
            background: var(--color-elevated);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-2);
            font-size: 12px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 0.4px;
        }

        .feedback-btn.success {
            color: var(--color-success);
            border-color: rgba(16, 185, 129, 0.4);
        }

        .feedback-btn.error {
            color: var(--color-danger);
            border-color: rgba(220, 38, 38, 0.4);
        }

        .feedback-btn svg {
            width: 16px;
            height: 16px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2.2;
        }

        .empty-state,
        .loading-state {
            text-align: center;
            padding: var(--space-7) var(--space-4);
        }

        .empty-title {
            font-size: 20px;
            font-weight: 800;
            color: var(--color-text-primary);
            margin-bottom: var(--space-2);
        }

        .empty-subtitle {
            font-size: 14px;
            color: var(--color-text-secondary);
        }

        .skeleton-line {
            height: 14px;
            border-radius: var(--radius-pill);
            background: linear-gradient(90deg, var(--color-skeleton-base), var(--color-skeleton-shine), var(--color-skeleton-base));
            background-size: 200% 100%;
            animation: shimmer 1.4s infinite;
            margin-bottom: var(--space-2);
        }

        .skeleton-line.wide {
            height: 18px;
        }

        @keyframes shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .sales-hero {
            border: 1px solid var(--color-border);
            background: var(--color-surface);
            box-shadow: var(--shadow-1);
        }

        .sales-playbook {
            display: grid;
            gap: var(--space-4);
        }

        .playbook-section {
            border: 1px solid var(--color-divider);
            border-radius: var(--radius-2);
            padding: var(--space-3);
            display: grid;
            gap: var(--space-2);
            background: var(--color-elevated);
        }

        .playbook-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--space-2);
        }

        .playbook-chips {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-2);
        }

        .context-chips {
            display: flex;
            gap: var(--space-2);
            overflow-x: auto;
            padding-bottom: var(--space-2);
            margin-top: var(--space-3);
            scrollbar-width: none;
        }

        .context-chips::-webkit-scrollbar {
            display: none;
        }

        .chip {
            min-height: var(--tap-min);
            padding: 8px 14px;
            border-radius: var(--radius-pill);
            border: 1px solid var(--color-border);
            background: var(--color-surface);
            font-size: 13px;
            font-weight: 700;
            letter-spacing: 0.2px;
            display: inline-flex;
            align-items: center;
            gap: var(--space-2);
            white-space: nowrap;
            transition: transform var(--duration-fast) var(--easing-standard), background var(--duration-fast) var(--easing-standard);
        }

        .chip[aria-pressed="true"] {
            background: var(--color-accent);
            color: #FFFFFF;
            border-color: var(--color-accent);
        }

        .chip svg {
            width: 16px;
            height: 16px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2.2;
        }

        .input-area {
            display: grid;
            gap: var(--space-3);
            grid-template-columns: 1fr auto auto;
            align-items: center;
        }

        .hero-input {
            margin-top: var(--space-4);
        }

        .hero-submit {
            min-width: 180px;
            min-height: var(--input-height);
            justify-content: center;
            padding: 14px 18px;
        }

        @container (max-width: 720px) {
            .sales-hero .hero-input {
                grid-template-columns: 1fr;
            }

            .sales-hero .hero-submit {
                width: 100%;
            }
        }

        .control-actions {
            display: none;
            gap: var(--space-2);
            margin-top: var(--space-3);
        }

        .icon-btn.small {
            width: 36px;
            height: 36px;
            border-radius: var(--radius-1);
        }

        @container (min-width: 1024px) {
            .control-actions {
                display: flex;
                justify-content: flex-end;
            }
        }

        .input-wrapper {
            position: relative;
        }

        .input-field {
            width: 100%;
            min-height: var(--input-height);
            padding: 12px 16px;
            border-radius: var(--radius-2);
            border: 1px solid var(--color-border);
            background: var(--color-surface);
            font-size: 15px;
        }

        .sales-hero .input-field {
            font-size: 16px;
        }

        .input-field:focus-visible {
            border-color: var(--color-accent);
        }

        .send-btn {
            width: var(--tap-min);
            height: var(--tap-min);
        }

        .mic-fab {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: var(--color-accent);
            border: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow-2);
            transition: transform var(--duration-fast) var(--easing-standard);
        }

        .mic-fab.recording {
            animation: micPulseRecording 1.4s infinite;
        }

        .mic-fab.processing {
            background: var(--color-warning);
        }

        .mic-fab svg {
            width: 22px;
            height: 22px;
            stroke: #FFFFFF;
            fill: none;
            stroke-width: 2.2;
        }

        @keyframes micPulseRecording {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.04); }
        }

        .modal {
            display: none;
            position: fixed;
            inset: 0;
            background: var(--color-backdrop);
            backdrop-filter: blur(8px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: var(--space-6);
        }

        .modal.open {
            display: flex;
        }

        .modal-content {
            background: var(--color-surface);
            border-radius: var(--radius-3);
            padding: var(--space-6);
            max-width: 560px;
            width: 100%;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: var(--shadow-3);
            border: 1px solid var(--color-border);
        }

        dialog.wiki-editor {
            padding: 0;
            border: none;
            background: transparent;
            width: min(720px, 100%);
            max-width: 720px;
        }

        dialog.wiki-editor::backdrop {
            background: var(--color-backdrop);
            backdrop-filter: blur(8px);
        }

        .wiki-entry-detail {
            margin-top: var(--space-4);
            display: grid;
            gap: var(--space-3);
        }

        .quick-panel {
            align-items: flex-end;
            justify-content: center;
            padding: 0;
        }

        .quick-panel .modal-content {
            width: 100%;
            max-width: 640px;
            border-radius: 20px 20px 0 0;
            max-height: 85vh;
            padding: var(--space-5);
        }

        .panel-handle {
            width: 52px;
            height: 4px;
            border-radius: 999px;
            background: var(--color-border);
            margin: 0 auto var(--space-4);
        }

        .panel-section {
            margin-bottom: var(--space-5);
            display: grid;
            gap: var(--space-3);
        }

        .panel-title {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.6px;
            font-weight: 800;
            color: var(--color-text-secondary);
        }

        .panel-divider {
            height: 1px;
            background: var(--color-divider);
        }

        .panel-mode .segment-control {
            width: 100%;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: var(--space-2);
            padding: 6px;
        }

        .panel-mode .segment-btn {
            min-height: var(--tap-min);
            text-align: center;
        }

        .panel-danger {
            border: 1px solid rgba(220, 38, 38, 0.3);
            background: rgba(220, 38, 38, 0.06);
            padding: var(--space-4);
            border-radius: var(--radius-2);
        }

        .panel-advanced summary {
            cursor: pointer;
            font-weight: 700;
            padding: var(--space-2) 0;
        }

        @media (min-width: 900px) {
            .panel-handle {
                display: none;
            }

            .quick-panel {
                align-items: stretch;
                justify-content: flex-end;
            }

            .quick-panel .modal-content {
                width: var(--panel-width);
                max-width: var(--panel-width);
                height: 100%;
                max-height: 100vh;
                border-radius: 0;
                padding: var(--space-5);
            }
        }

        @media (min-width: 1280px) {
            body.panel-docked .stage,
            body.panel-docked .header {
                padding-right: calc(var(--panel-width) + var(--space-5));
            }

            body.panel-docked .quick-panel {
                display: flex;
                background: transparent;
                pointer-events: none;
            }

            body.panel-docked .quick-panel .modal-content {
                pointer-events: auto;
            }
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-5);
        }

        .modal-title {
            font-size: 22px;
            font-weight: 800;
            color: var(--color-text-primary);
        }

        .close-btn {
            width: var(--tap-min);
            height: var(--tap-min);
            border-radius: var(--radius-2);
            background: var(--color-elevated);
            border: 1px solid var(--color-border);
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .confirm-extra {
            margin-top: var(--space-4);
            display: grid;
            gap: var(--space-2);
        }

        .btn.hold-active {
            opacity: 0.7;
            transform: scale(0.98);
        }

        .form-group {
            margin-bottom: var(--space-5);
        }

        .toggle-row {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: 8px 10px;
            border-radius: var(--radius-2);
            border: 1px solid var(--color-border);
            background: var(--color-elevated);
            font-size: 13px;
            color: var(--color-text-secondary);
        }

        .toggle-row input {
            width: 18px;
            height: 18px;
        }

        .form-label {
            display: block;
            font-size: 12px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--color-text-secondary);
            margin-bottom: var(--space-2);
        }

        .form-input,
        .form-select,
        .form-textarea {
            width: 100%;
            padding: 12px 14px;
            border-radius: var(--radius-2);
            border: 1px solid var(--color-border);
            background: var(--color-elevated);
            font-size: 14px;
        }

        .form-textarea {
            min-height: 90px;
            resize: vertical;
        }

        .helper-text {
            font-size: 12px;
            color: var(--color-text-muted);
            margin-top: var(--space-2);
        }

        .warning-box {
            display: flex;
            gap: var(--space-2);
            padding: var(--space-3);
            border-radius: var(--radius-2);
            background: rgba(245, 158, 11, 0.12);
            border: 1px solid rgba(245, 158, 11, 0.3);
            margin-top: var(--space-3);
        }

        .warning-box svg {
            width: 18px;
            height: 18px;
            stroke: var(--color-warning);
            stroke-width: 2.2;
        }

        .warning-text {
            font-size: 12px;
            color: var(--color-text-secondary);
        }

        .segmented {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: var(--space-2);
        }

        .segmented-option {
            position: relative;
            display: block;
        }

        .segmented-option input {
            position: absolute;
            opacity: 0;
            inset: 0;
        }

        .segmented-option span {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px 12px;
            border-radius: var(--radius-2);
            border: 1px solid var(--color-border);
            background: var(--color-elevated);
            font-size: 13px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.4px;
            min-height: var(--tap-min);
        }

        .segmented-option input:checked + span {
            border-color: var(--color-accent);
            color: var(--color-accent);
            background: rgba(227, 0, 15, 0.08);
        }

        .btn-group {
            display: grid;
            gap: var(--space-3);
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            margin-top: var(--space-3);
        }

        .btn {
            padding: 12px 16px;
            border-radius: var(--radius-2);
            font-size: 13px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 0.4px;
            border: 1px solid transparent;
            min-height: var(--tap-min);
        }

        .btn-primary {
            background: var(--color-accent);
            color: #FFFFFF;
        }

        .btn-secondary {
            background: var(--color-elevated);
            color: var(--color-text-primary);
            border-color: var(--color-border);
        }

        .btn-danger {
            background: var(--color-danger);
            color: #FFFFFF;
        }

        .toast {
            position: fixed;
            bottom: calc(var(--safe-bottom) + var(--space-4));
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            opacity: 0;
            pointer-events: none;
            padding: 14px 20px;
            border-radius: var(--radius-2);
            background: var(--color-toast);
            color: var(--color-toast-text);
            font-size: 13px;
            font-weight: 700;
            letter-spacing: 0.3px;
            transition: opacity var(--duration-medium) var(--easing-standard), transform var(--duration-medium) var(--easing-standard);
            z-index: 4000;
        }

        .toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        .footer {
            text-align: center;
            padding: var(--space-3);
            font-size: 11px;
            color: var(--color-text-muted);
            border-top: 1px solid var(--color-divider);
            background: var(--color-surface);
        }

        .build-info {
            margin-top: var(--space-1);
            font-size: 10px;
            font-family: var(--font-mono);
            color: var(--color-text-muted);
        }

        .stealth-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.92);
            backdrop-filter: blur(24px);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: var(--space-4);
            z-index: 5000;
            text-align: center;
            color: #FFFFFF;
        }

        .stealth-overlay.active {
            display: flex;
        }

        .stealth-icon {
            width: 72px;
            height: 72px;
            stroke: #FFFFFF;
            stroke-width: 1.6;
            opacity: 0.5;
        }

        .stealth-text {
            font-size: 16px;
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.8);
        }

        .stealth-hint {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
        }

        @media (min-width: 720px) {
            .bento-grid {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }

            .tile--wide {
                grid-column: span 2;
            }
        }

        @media (min-width: 1024px) {
            .bento-grid {
                grid-template-columns: repeat(3, minmax(0, 1fr));
            }

            .tile--hero {
                grid-column: span 2;
            }

            .tile--tall {
                grid-row: span 2;
            }
        }

        @media (min-width: 1280px) {
            .bento-grid {
                grid-template-columns: repeat(4, minmax(0, 1fr));
            }

            .tile--hero {
                grid-column: span 2;
            }
        }

        @media (max-width: 680px) {
            .header {
                padding: calc(var(--space-3) + var(--safe-top)) var(--space-4) var(--space-3) var(--space-4);
            }
        }

        @container (max-width: 680px) {
            .sales-hero .input-area {
                grid-template-columns: 1fr auto;
            }

            .sales-hero .send-btn {
                display: none;
            }
        }

        @media (hover: hover) and (pointer: fine) {
            .stage::-webkit-scrollbar {
                width: 10px;
            }

            .stage::-webkit-scrollbar-thumb {
                background: var(--color-scrollbar-thumb);
                border-radius: var(--radius-pill);
            }

            .stage::-webkit-scrollbar-track {
                background: var(--color-scrollbar-track);
            }
        }

        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }
        }
    </style>
</head>
<body>
    <a class="skip-link" href="#stage">Zum Inhalt springen</a>

    <div class="stealth-overlay" id="stealthOverlay" aria-hidden="true" tabindex="-1">
        <svg class="stealth-icon" viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <rect x="2" y="2" width="20" height="20" rx="2"/>
            <line x1="7" y1="12" x2="17" y2="12"/>
        </svg>
        <div class="stealth-text">Stealth aktiv</div>
        <div class="stealth-hint">Zweimal tippen oder ESC zum Beenden</div>
    </div>

    <header class="header" id="header">
        <div class="header-left">
            <div class="logo-container" aria-label="MEHIC SALES OS">
                <svg class="logo-svg" viewBox="0 0 100 100" fill="none" aria-hidden="true">
                    <defs>
                        <linearGradient id="logoGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" stop-color="#E3000F" />
                            <stop offset="100%" stop-color="#C70010" />
                        </linearGradient>
                    </defs>
                    <path d="M20 80 L20 20 L50 50 L80 20 L80 80" stroke="url(#logoGrad)" stroke-width="8" stroke-linecap="round" stroke-linejoin="round" fill="none" opacity="0.9"/>
                    <circle cx="50" cy="50" r="8" fill="url(#logoGrad)" opacity="0.8"/>
                </svg>
                <div class="logo-text">MEHIC <span>OS</span></div>
            </div>
            <div class="dept-badge" id="deptBadge">TV</div>
        </div>
        <div class="header-center">
            <div class="status-pill" id="onlineStatus" data-status="online" role="status" aria-live="polite">
                <span class="status-dot" aria-hidden="true"></span>
                <span id="onlineStatusLabel">Online</span>
            </div>
        </div>
        <button class="icon-btn" id="settingsBtn" type="button" title="Panel öffnen" aria-label="Panel öffnen" aria-expanded="false">
            <svg viewBox="0 0 24 24">
                <path d="M3 6h18"/>
                <path d="M3 12h18"/>
                <path d="M3 18h18"/>
            </svg>
        </button>
    </header>

    <div class="offline-banner" id="offlineBanner" role="status" aria-live="polite">
        Offline – Lokale Daten aktiv. Sync pausiert.
    </div>

    <main class="stage" id="stage">
        <div class="bento-grid" id="bentoGrid">
            <section class="tile tile--wide frame-container" id="frameContainer">
                <div class="frame-root sales-frame" id="salesFrame" role="tabpanel">
                    <section class="tile sales-hero" id="salesHero">
                        <div class="tile-title">Schnellstart</div>
                        <div class="tile-subtitle">Einwand tippen, Antwort zeigen, Abschlussfrage sagen.</div>
                        <div class="input-area hero-input">
                            <label class="sr-only" for="objectionInput">Kundeneinwand</label>
                            <div class="input-wrapper">
                                <input type="text" class="input-field" id="objectionInput" placeholder="Kundeneinwand eingeben..." autocomplete="off" />
                            </div>
                            <button class="btn btn-primary hero-submit" id="submitBtn" type="button">
                                Antwort generieren
                            </button>
                            <button class="mic-fab" id="micBtn" type="button" aria-label="Spracheingabe" aria-pressed="false">
                                <svg viewBox="0 0 24 24">
                                    <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
                                    <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                                    <line x1="12" y1="19" x2="12" y2="23"/>
                                    <line x1="8" y1="23" x2="16" y2="23"/>
                                </svg>
                            </button>
                        </div>
                        <div class="context-chips" id="contextChips" role="group" aria-label="Kontext Filter">
                            <button class="chip" type="button" data-context="hurry" aria-pressed="false">
                                <svg viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>
                                Eilig
                            </button>
                            <button class="chip" type="button" data-context="duo" aria-pressed="false">
                                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/></svg>
                                Paar
                            </button>
                            <button class="chip" type="button" data-context="easy" aria-pressed="false">
                                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 2v20M2 12h20"/></svg>
                                Einfach
                            </button>
                            <button class="chip" type="button" data-context="techie" aria-pressed="false">
                                <svg viewBox="0 0 24 24" aria-hidden="true"><rect x="2" y="3" width="20" height="14" rx="2"/><path d="M8 21h8M12 17v4"/></svg>
                                Techie
                            </button>
                        </div>
                        <div class="context-chips tech-toggle" id="techToggleGroup" role="group" aria-label="Technische Produktfrage">
                            <button class="chip" id="techQuestionToggle" type="button" aria-pressed="false" data-tech-question="true">
                                Technische Produktfrage
                            </button>
                        </div>
                    </section>
                    <div class="sales-layout">
                        <section class="tile sales-primary" id="salesPrimary">
                            <div id="salesCardContainer"></div>
                        </section>
                        <section class="tile sales-playbook" id="salesPlaybook">
                            <div class="tile-title">Leitfaden</div>
                            <div class="tile-subtitle">1-Tap Fragen und Abschlussbausteine.</div>
                            <div class="playbook-section">
                                <div class="playbook-header">
                                    <div class="history-meta">Bedarf & Prioritäten</div>
                                    <button class="copy-btn" type="button" data-playbook-copy="Welche Leistungen sind Ihnen wichtig | Welche sind Ihnen weniger wichtig | Welche Geräte verwenden Sie | Wer wird es hauptsächlich nutzen | Wie viel nutzen Sie es im Durchschnitt | Was ist Ihnen wichtig bei einem Smartphone | Was ist Ihnen wichtig bei einem Fernseher | Welche Ansprüche haben Sie an das Notebook oder den Laptop">Copy</button>
                                </div>
                                <div class="playbook-chips">
                                    <button class="chip" type="button" data-playbook-text="Welche Leistungen sind Ihnen wichtig">Welche Leistungen sind Ihnen wichtig</button>
                                    <button class="chip" type="button" data-playbook-text="Welche sind Ihnen weniger wichtig">Welche sind Ihnen weniger wichtig</button>
                                    <button class="chip" type="button" data-playbook-text="Welche Geräte verwenden Sie">Welche Geräte verwenden Sie</button>
                                    <button class="chip" type="button" data-playbook-text="Wer wird es hauptsächlich nutzen">Wer wird es hauptsächlich nutzen</button>
                                    <button class="chip" type="button" data-playbook-text="Wie viel nutzen Sie es im Durchschnitt">Wie viel nutzen Sie es im Durchschnitt</button>
                                    <button class="chip" type="button" data-playbook-text="Was ist Ihnen wichtig bei einem Smartphone">Was ist Ihnen wichtig bei einem Smartphone</button>
                                    <button class="chip" type="button" data-playbook-text="Was ist Ihnen wichtig bei einem Fernseher">Was ist Ihnen wichtig bei einem Fernseher</button>
                                    <button class="chip" type="button" data-playbook-text="Welche Ansprüche haben Sie an das Notebook oder den Laptop">Welche Ansprüche haben Sie an das Notebook oder den Laptop</button>
                                </div>
                            </div>
                            <div class="playbook-section">
                                <div class="playbook-header">
                                    <div class="history-meta">Nutzen & Wert</div>
                                    <button class="copy-btn" type="button" data-playbook-copy="Was ist der Vorteil für Sie, wenn das Smartphone eine gute Kamera hat | Was ist der Vorteil für Sie, wenn das Smartphone einen großen Speicher hat | Was ist der Vorteil für Sie, wenn das Notebook oder der Laptop eine lange Akkulaufzeit hat">Copy</button>
                                </div>
                                <div class="playbook-chips">
                                    <button class="chip" type="button" data-playbook-text="Was ist der Vorteil für Sie, wenn das Smartphone eine gute Kamera hat">Was ist der Vorteil für Sie, wenn das Smartphone eine gute Kamera hat</button>
                                    <button class="chip" type="button" data-playbook-text="Was ist der Vorteil für Sie, wenn das Smartphone einen großen Speicher hat">Was ist der Vorteil für Sie, wenn das Smartphone einen großen Speicher hat</button>
                                    <button class="chip" type="button" data-playbook-text="Was ist der Vorteil für Sie, wenn das Notebook oder der Laptop eine lange Akkulaufzeit hat">Was ist der Vorteil für Sie, wenn das Notebook oder der Laptop eine lange Akkulaufzeit hat</button>
                                </div>
                            </div>
                            <div class="playbook-section">
                                <div class="playbook-header">
                                    <div class="history-meta">Abschlussfragen</div>
                                    <button class="copy-btn" type="button" data-playbook-copy="Sollen wir es einpacken | Wollen wir das so machen | Darf ich es Ihnen reservieren | Wollen Sie bar oder mit Karte zahlen | Soll ich es gleich aktivieren | Soll ich es gleich einrichten | Soll ich es Ihnen nach Hause liefern lassen">Copy</button>
                                </div>
                                <div class="playbook-chips">
                                    <button class="chip" type="button" data-playbook-text="Sollen wir es einpacken">Sollen wir es einpacken</button>
                                    <button class="chip" type="button" data-playbook-text="Wollen wir das so machen">Wollen wir das so machen</button>
                                    <button class="chip" type="button" data-playbook-text="Darf ich es Ihnen reservieren">Darf ich es Ihnen reservieren</button>
                                    <button class="chip" type="button" data-playbook-text="Wollen Sie bar oder mit Karte zahlen">Wollen Sie bar oder mit Karte zahlen</button>
                                    <button class="chip" type="button" data-playbook-text="Soll ich es gleich aktivieren">Soll ich es gleich aktivieren</button>
                                    <button class="chip" type="button" data-playbook-text="Soll ich es gleich einrichten">Soll ich es gleich einrichten</button>
                                    <button class="chip" type="button" data-playbook-text="Soll ich es Ihnen nach Hause liefern lassen">Soll ich es Ihnen nach Hause liefern lassen</button>
                                </div>
                            </div>
                            <div class="playbook-section">
                                <div class="playbook-header">
                                    <div class="history-meta">DAF (Dank – Abklärung – Frage)</div>
                                    <button class="copy-btn" type="button" data-playbook-copy="D: Super, dass Sie das ansprechen | D: Danke, dass Sie das sagen | A: Was genau ist Ihnen dabei wichtig | A: Woran würden Sie festmachen, dass es sich lohnt | F: Wenn wir das lösen, wollen wir es heute mitnehmen | F: Wollen wir es so machen">Copy</button>
                                </div>
                                <div class="playbook-chips">
                                    <button class="chip" type="button" data-playbook-text="Super, dass Sie das ansprechen">D: Super, dass Sie das ansprechen</button>
                                    <button class="chip" type="button" data-playbook-text="Danke, dass Sie das sagen">D: Danke, dass Sie das sagen</button>
                                    <button class="chip" type="button" data-playbook-text="Was genau ist Ihnen dabei wichtig">A: Was genau ist Ihnen dabei wichtig</button>
                                    <button class="chip" type="button" data-playbook-text="Woran würden Sie festmachen, dass es sich lohnt">A: Woran würden Sie festmachen, dass es sich lohnt</button>
                                    <button class="chip" type="button" data-playbook-text="Wenn wir das lösen, wollen wir es heute mitnehmen">F: Wenn wir das lösen, wollen wir es heute mitnehmen</button>
                                    <button class="chip" type="button" data-playbook-text="Wollen wir es so machen">F: Wollen wir es so machen</button>
                                </div>
                            </div>
                            <div class="playbook-section">
                                <div class="playbook-header">
                                    <div class="history-meta">SPIN – Problem</div>
                                    <button class="copy-btn" type="button" data-playbook-copy="Was stört Sie am aktuellen Gerät am meisten | Was fehlt Ihnen im Alltag am meisten">Copy</button>
                                </div>
                                <div class="playbook-chips">
                                    <button class="chip" type="button" data-playbook-text="Was stört Sie am aktuellen Gerät am meisten">Was stört Sie am aktuellen Gerät am meisten</button>
                                    <button class="chip" type="button" data-playbook-text="Was fehlt Ihnen im Alltag am meisten">Was fehlt Ihnen im Alltag am meisten</button>
                                </div>
                            </div>
                            <div class="playbook-section">
                                <div class="playbook-header">
                                    <div class="history-meta">SPIN – Implikation</div>
                                    <button class="copy-btn" type="button" data-playbook-copy="Was passiert, wenn das Problem bleibt | Was kostet Sie das im Alltag (Zeit, Nerven, Geld)">Copy</button>
                                </div>
                                <div class="playbook-chips">
                                    <button class="chip" type="button" data-playbook-text="Was passiert, wenn das Problem bleibt">Was passiert, wenn das Problem bleibt</button>
                                    <button class="chip" type="button" data-playbook-text="Was kostet Sie das im Alltag (Zeit, Nerven, Geld)">Was kostet Sie das im Alltag (Zeit, Nerven, Geld)</button>
                                </div>
                            </div>
                            <div class="playbook-section">
                                <div class="playbook-header">
                                    <div class="history-meta">SPIN – Need-Payoff</div>
                                    <button class="copy-btn" type="button" data-playbook-copy="Was wäre für Sie besser, wenn das gelöst ist | Woran merken Sie, dass es sich gelohnt hat">Copy</button>
                                </div>
                                <div class="playbook-chips">
                                    <button class="chip" type="button" data-playbook-text="Was wäre für Sie besser, wenn das gelöst ist">Was wäre für Sie besser, wenn das gelöst ist</button>
                                    <button class="chip" type="button" data-playbook-text="Woran merken Sie, dass es sich gelohnt hat">Woran merken Sie, dass es sich gelohnt hat</button>
                                </div>
                            </div>
                            <div class="playbook-section">
                                <div class="playbook-header">
                                    <div class="history-meta">Kalibrierte Fragen</div>
                                    <button class="copy-btn" type="button" data-playbook-copy="Wie soll das für Sie idealerweise aussehen | Was müsste passieren, damit es für Sie passt">Copy</button>
                                </div>
                                <div class="playbook-chips">
                                    <button class="chip" type="button" data-playbook-text="Wie soll das für Sie idealerweise aussehen">Wie soll das für Sie idealerweise aussehen</button>
                                    <button class="chip" type="button" data-playbook-text="Was müsste passieren, damit es für Sie passt">Was müsste passieren, damit es für Sie passt</button>
                                </div>
                            </div>
                        </section>
                        <aside class="tile sales-history" id="salesHistory">
                            <div class="tile-title">Verlauf</div>
                            <div class="history-section">
                                <div class="history-meta">Letzte 15 Einwände</div>
                                <div class="history-list" id="historyList"></div>
                            </div>
                            <div class="history-section">
                                <div class="history-meta">Favoriten</div>
                                <div class="history-list" id="favoriteList"></div>
                            </div>
                        </aside>
                    </div>
                </div>

                <div class="frame-root training-frame" id="trainingFrame" role="tabpanel">
                    <div class="training-layout">
                        <section class="tile training-card" id="trainingCardPanel">
                            <div class="tile-header">
                                <div>
                                    <div class="tile-title">Training Card</div>
                                    <div class="tile-subtitle" id="trainingCardTitle">Aktueller Einwand</div>
                                </div>
                                <div class="variant-toggle" role="tablist" aria-label="Varianten">
                                    <button class="variant-btn" id="variantSoftBtn" type="button" data-variant="soft" aria-pressed="false">Soft</button>
                                    <button class="variant-btn" id="variantNeutralBtn" type="button" data-variant="neutral" aria-pressed="true">Neutral</button>
                                    <button class="variant-btn" id="variantChallengerBtn" type="button" data-variant="challenger" aria-pressed="false">Challenger</button>
                                </div>
                            </div>
                            <div id="trainingCardContainer"></div>
                            <div class="roleplay-box" id="roleplayPrompt">Roleplay bereit. Klick auf „Kunde sagt“.</div>
                            <div class="btn-group">
                                <button class="btn btn-secondary" id="roleplayBtn" type="button">Kunde sagt</button>
                                <button class="btn btn-secondary" id="roleplaySoftBtn" type="button" data-variant="soft">Antwort Soft</button>
                                <button class="btn btn-secondary" id="roleplayNeutralBtn" type="button" data-variant="neutral">Antwort Neutral</button>
                                <button class="btn btn-secondary" id="roleplayChallengerBtn" type="button" data-variant="challenger">Antwort Challenger</button>
                            </div>
                            <div class="tile-desc" id="roleplayResponse">Antwort erscheint hier.</div>
                        </section>

                        <section class="tile training-drill" id="trainingDrillPanel">
                            <div class="tile-title">Drill Mode</div>
                            <div class="tile-desc" id="drillText">Kein Drill geladen.</div>
                            <div class="btn-group">
                                <button class="btn btn-secondary" id="nextDrillBtn" type="button">Neuer Drill</button>
                                <button class="btn btn-primary" id="drillDoneBtn" type="button">30s fertig</button>
                            </div>
                            <div class="history-meta">Self-Rating</div>
                            <div class="pill-row" id="ratingButtons">
                                <button class="pill rating-btn" type="button" data-rating="1">1</button>
                                <button class="pill rating-btn" type="button" data-rating="2">2</button>
                                <button class="pill rating-btn" type="button" data-rating="3">3</button>
                                <button class="pill rating-btn" type="button" data-rating="4">4</button>
                                <button class="pill rating-btn" type="button" data-rating="5">5</button>
                            </div>
                        </section>

                        <section class="tile training-pattern" id="trainingPatternPanel">
                            <div class="tile-title">Pattern Library</div>
                            <select class="form-select" id="patternFilter" aria-label="Pattern Filter"></select>
                            <div class="pattern-list" id="patternList"></div>
                            <div class="microlearning" id="microlearningBox">Microlearning erscheint hier.</div>
                            <div class="history-section">
                                <div class="history-meta">Training KPIs</div>
                                <div class="stat-grid" id="trainingStats"></div>
                            </div>
                            <div class="history-section">
                                <div class="history-meta">Top 3 Schwächen</div>
                                <div class="pattern-list" id="trainingWeaknessList"></div>
                            </div>
                            <div class="history-section">
                                <div class="history-meta">Letzte 10 Einwände</div>
                                <div class="history-list" id="trainingHistoryList"></div>
                            </div>
                        </section>
                    </div>
                </div>

                <div class="frame-root wiki-frame" id="wikiFrame" role="tabpanel">
                    <div class="wiki-layout">
                        <section class="tile wiki-search-panel">
                            <div class="tile-title">Produkt Wiki</div>
                            <input class="form-input" id="wikiSearchInput" type="text" placeholder="Produkt suchen..." autocomplete="off">
                            <div class="context-chips" id="wikiFilterChips" role="group" aria-label="Wiki Filter"></div>
                            <div class="btn-group">
                                <button class="btn btn-secondary" id="wikiSyncBtn" type="button">Wiki Sync</button>
                                <button class="btn btn-secondary" id="wikiClearBtn" type="button">Filter zurücksetzen</button>
                            </div>
                        </section>

                        <section class="tile wiki-results-panel">
                            <div class="tile-title">Treffer</div>
                            <div class="history-list" id="wikiResults"></div>
                        </section>

                        <section class="tile wiki-crud-panel" id="wikiCrudPanel">
                            <div class="tile-header">
                                <div>
                                    <div class="tile-title">Wiki Einträge</div>
                                    <div class="tile-subtitle">Lokale Wissensbasis</div>
                                </div>
                                <button class="btn btn-secondary" id="wikiNewBtn" type="button">+ Neu</button>
                            </div>
                            <div class="history-list" id="wikiEntryList"></div>
                            <div class="panel-divider"></div>
                            <div class="wiki-entry-detail" id="wikiEntryDetail"></div>
                        </section>

                        <section class="tile wiki-detail-panel">
                            <div class="tile-title">Produktdetails</div>
                            <div id="wikiDetail"></div>
                        </section>

                        <section class="tile wiki-qa-panel">
                            <div class="tile-title">Product Q&A</div>
                            <input class="form-input" id="wikiQuestionInput" type="text" placeholder="Frage zum Produkt..." autocomplete="off">
                            <div class="btn-group">
                                <button class="btn btn-primary" id="wikiQuestionBtn" type="button">Antwort holen</button>
                            </div>
                            <div class="history-meta" id="wikiAnswerStatus">–</div>
                            <div class="tile-desc" id="wikiAnswerText"></div>
                            <div class="pattern-list" id="wikiCitations"></div>
                        </section>

                        <section class="tile wiki-compare-panel">
                            <div class="tile-title">Vergleich</div>
                            <div class="history-list" id="wikiCompareList"></div>
                        </section>
                    </div>
                </div>
            </section>
        </div>
    </main>

    <div class="modal quick-panel" id="settingsModal" role="dialog" aria-modal="true" aria-labelledby="settingsTitle" aria-hidden="true">
        <div class="modal-content" role="document">
            <div class="panel-handle" aria-hidden="true"></div>
            <div class="modal-header">
                <div class="modal-title" id="settingsTitle">Quick Panel</div>
                <button class="close-btn" id="closeSettingsBtn" type="button" aria-label="Panel schließen">
                    <svg viewBox="0 0 24 24">
                        <line x1="18" y1="6" x2="6" y2="18"/>
                        <line x1="6" y1="6" x2="18" y2="18"/>
                    </svg>
                </button>
            </div>

            <div class="panel-section panel-mode">
                <div class="panel-title">Modus</div>
                <div class="segment-control" role="tablist" aria-label="Modus Switcher">
                    <button class="segment-btn" id="frameSalesBtn" type="button" data-frame="sales" aria-pressed="true" role="tab" aria-controls="salesFrame">Verkauf</button>
                    <button class="segment-btn" id="frameTrainingBtn" type="button" data-frame="training" aria-pressed="false" role="tab" aria-controls="trainingFrame">Training</button>
                    <button class="segment-btn" id="frameWikiBtn" type="button" data-frame="wiki" aria-pressed="false" role="tab" aria-controls="wikiFrame">Wiki</button>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title">Theme</div>
                <div class="segmented" role="radiogroup" aria-label="Theme Auswahl">
                    <label class="segmented-option">
                        <input type="radio" name="themeMode" value="auto" id="themeAuto">
                        <span>Auto</span>
                    </label>
                    <label class="segmented-option">
                        <input type="radio" name="themeMode" value="light" id="themeLight">
                        <span>Hell</span>
                    </label>
                    <label class="segmented-option">
                        <input type="radio" name="themeMode" value="dark" id="themeDark">
                        <span>Dunkel</span>
                    </label>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title">Density</div>
                <div class="segmented" role="radiogroup" aria-label="Density Auswahl">
                    <label class="segmented-option">
                        <input type="radio" name="densityMode" value="compact" id="densityCompact">
                        <span>Kompakt</span>
                    </label>
                    <label class="segmented-option">
                        <input type="radio" name="densityMode" value="comfortable" id="densityComfortable">
                        <span>Comfort</span>
                    </label>
                </div>
                <div class="helper-text">Default: Mobile Comfort, Desktop Kompakt. Manuelle Wahl wird gespeichert.</div>
            </div>

            <div class="panel-section">
                <div class="panel-title">Daten</div>
                <div class="btn-group">
                    <button class="btn btn-secondary" id="exportBtn" type="button">Export</button>
                    <button class="btn btn-secondary" id="importBtn" type="button">Import</button>
                </div>
                <input type="file" id="importFile" accept=".json" class="sr-only" />
                <div class="btn-group">
                    <button class="btn btn-secondary" id="libraryExportBtn" type="button">Library exportieren</button>
                    <button class="btn btn-secondary" id="libraryImportBtn" type="button">Library importieren</button>
                </div>
                <input type="file" id="libraryImportFile" accept=".json" class="sr-only" />
                <button class="btn btn-secondary" id="wikiResetBtn" type="button">Wiki zurücksetzen</button>
                <div class="helper-text">Letzter Sync: <span id="syncTime">–</span></div>
            </div>

            <div class="panel-section panel-danger">
                <div class="panel-title">Danger Zone</div>
                <div class="tile-desc">Reset löscht lokale Daten. Nur bei Bedarf.</div>
                <button class="btn btn-danger" id="clearBtn" type="button">Reset & Daten löschen</button>
            </div>

            <details class="panel-advanced">
                <summary>Advanced Settings</summary>
                <div class="panel-section">
                    <label class="form-label" for="apiProvider">API Provider</label>
                    <select class="form-select" id="apiProvider">
                        <option value="openai">OpenAI</option>
                        <option value="groq">Groq</option>
                    </select>
                </div>

                <div class="panel-section">
                    <label class="form-label" for="apiKey">API Key (BYOK)</label>
                    <input type="password" class="form-input" id="apiKey" placeholder="sk-..." autocomplete="off" />
                    <div class="warning-box">
                        <svg viewBox="0 0 24 24">
                            <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/>
                            <line x1="12" y1="9" x2="12" y2="13"/>
                            <line x1="12" y1="17" x2="12.01" y2="17"/>
                        </svg>
                        <div class="warning-text">Schlüssel wird lokal gespeichert. Passphrase-Lock empfohlen. Niemals auf öffentlichen Geräten verwenden.</div>
                    </div>
                </div>

                <div class="panel-section">
                    <label class="form-label" for="sessionOnlyKey">API Key Modus</label>
                    <label class="toggle-row">
                        <input type="checkbox" id="sessionOnlyKey">
                        Session Only (nicht speichern)
                    </label>
                    <div class="helper-text">Wenn aktiv, bleibt der Key nur im RAM und wird nicht persistiert.</div>
                </div>

                <div class="panel-section">
                    <label class="form-label" for="passphraseInput">Passphrase (optional)</label>
                    <input type="password" class="form-input" id="passphraseInput" placeholder="Nur lokal verwendet" autocomplete="off" />
                    <div class="helper-text" id="lockStatus">Lock deaktiviert</div>
                    <div class="btn-group">
                        <button class="btn btn-secondary" id="lockToggleBtn" type="button">Passphrase-Lock aktivieren</button>
                        <button class="btn btn-secondary" id="unlockBtn" type="button">Unlock</button>
                    </div>
                </div>

                <div class="panel-section">
                    <label class="form-label" for="modelName">AI Model Name</label>
                    <input type="text" class="form-input" id="modelName" placeholder="gpt-4o-mini" />
                </div>

                <div class="panel-section">
                    <label class="form-label" for="proxyUrl">API Proxy URL (optional)</label>
                    <input type="text" class="form-input" id="proxyUrl" placeholder="https://your-proxy.example" />
                    <div class="helper-text">Nur Same-Origin Proxies erlaubt (CSP-konform).</div>
                </div>

                <div class="panel-section">
                    <label class="form-label" for="wikiSourceUrl">Wiki Source URL (optional)</label>
                    <input type="text" class="form-input" id="wikiSourceUrl" placeholder="https://example.com/wiki.json" />
                    <div class="helper-text">Wiki Sync nutzt diese Quelle (same-origin empfohlen).</div>
                </div>

                <div class="panel-section">
                    <label class="form-label" for="department">Abteilung</label>
                    <select class="form-select" id="department">
                        <option value="TV">TV & Audio</option>
                        <option value="Mobile">Mobile</option>
                        <option value="IT">IT</option>
                        <option value="Weiß">Weiße Ware</option>
                    </select>
                </div>

                <div class="panel-section">
                    <label class="form-label" for="storePolicy">Store Policy</label>
                    <textarea class="form-textarea" id="storePolicy" placeholder="z.B. 'Winteraktion bis 31.01.2026'"></textarea>
                </div>

                <div class="panel-section">
                    <div class="btn-group">
                        <button class="btn btn-primary" id="saveSettingsBtn" type="button">Speichern</button>
                    </div>
                </div>
            </details>
        </div>
    </div>

    <div class="modal confirm-modal" id="confirmModal" role="alertdialog" aria-modal="true" aria-labelledby="confirmTitle" aria-describedby="confirmMessage" aria-hidden="true">
        <div class="modal-content" role="document">
            <div class="modal-header">
                <div class="modal-title" id="confirmTitle">Bestätigen</div>
                <button class="close-btn" id="confirmCloseBtn" type="button" aria-label="Dialog schließen">
                    <svg viewBox="0 0 24 24">
                        <line x1="18" y1="6" x2="6" y2="18"/>
                        <line x1="6" y1="6" x2="18" y2="18"/>
                    </svg>
                </button>
            </div>
            <div class="tile-desc" id="confirmMessage">Bitte bestätigen.</div>
            <div class="confirm-extra" id="confirmExtra" hidden>
                <label class="form-label" for="confirmInput">Tippe: “Ich bestätige”</label>
                <input type="text" class="form-input" id="confirmInput" placeholder="Ich bestätige" autocomplete="off" />
                <div class="helper-text" id="confirmHoldHint">Zum Bestätigen 800ms halten.</div>
            </div>
            <div class="btn-group">
                <button class="btn btn-secondary" id="confirmCancelBtn" type="button">Abbrechen</button>
                <button class="btn btn-danger" id="confirmConfirmBtn" type="button">Bestätigen</button>
            </div>
        </div>
    </div>

    <dialog class="wiki-editor" id="wikiEditorModal" aria-labelledby="wikiEditorTitle">
        <form class="modal-content" id="wikiEditorForm">
            <div class="modal-header">
                <div class="modal-title" id="wikiEditorTitle">Wiki Eintrag</div>
                <button class="close-btn" id="wikiEditorCloseBtn" type="button" aria-label="Dialog schließen">
                    <svg viewBox="0 0 24 24">
                        <line x1="18" y1="6" x2="6" y2="18"/>
                        <line x1="6" y1="6" x2="18" y2="18"/>
                    </svg>
                </button>
            </div>
            <input type="hidden" id="wikiEditorId" />
            <div class="panel-section">
                <label class="form-label" for="wikiTitle">Titel (Pflicht)</label>
                <input class="form-input" id="wikiTitle" type="text" placeholder="z.B. Garantie Ablauf" autocomplete="off" />
            </div>
            <div class="panel-section">
                <label class="form-label" for="wikiCategory">Kategorie (Pflicht)</label>
                <input class="form-input" id="wikiCategory" type="text" placeholder="z.B. TV" autocomplete="off" />
            </div>
            <div class="panel-section">
                <label class="form-label" for="wikiBrand">Brand</label>
                <input class="form-input" id="wikiBrand" type="text" placeholder="z.B. Samsung" autocomplete="off" />
            </div>
            <div class="panel-section">
                <label class="form-label" for="wikiTags">Tags</label>
                <input class="form-input" id="wikiTags" type="text" placeholder="kamera, oled, gaming" autocomplete="off" />
                <div class="helper-text">Kommagetrennt oder Zeilenumbrüche.</div>
            </div>
            <div class="panel-section">
                <label class="form-label" for="wikiKurz">Kurz</label>
                <textarea class="form-textarea" id="wikiKurz" placeholder="Kurzbeschreibung"></textarea>
            </div>
            <div class="panel-section">
                <label class="form-label" for="wikiSpecs">Specs</label>
                <textarea class="form-textarea" id="wikiSpecs" placeholder="Spezifikationen"></textarea>
            </div>
            <div class="panel-section">
                <label class="form-label" for="wikiFaq">FAQ</label>
                <textarea class="form-textarea" id="wikiFaq" placeholder="FAQ Einträge"></textarea>
            </div>
            <div class="btn-group">
                <button class="btn btn-secondary" id="wikiEditorCancelBtn" type="button">Abbrechen</button>
                <button class="btn btn-primary" id="wikiEditorSaveBtn" type="button">Speichern</button>
            </div>
        </form>
    </dialog>

    <div class="toast" id="toast" role="status" aria-live="polite"></div>

    <footer class="footer">
        © 2026 Enes Mehic. All rights reserved.
        <div class="build-info" id="buildInfo"></div>
    </footer>

    <script>
        const APP_VERSION = "2026.2.1-rc";
        const BUILD_DATE = "2026-01-18";
        const BUILD_SIGNATURE = `MEHIC_SALES_OS_RC_${APP_VERSION}__${BUILD_DATE}`;

        const DB_NAME = "MehicSalesOS_DB";
        const DB_VERSION = 4;
        const MASTER_LIBRARY_URL = "./library.json";
        const LIBRARY_SHA256 = "pM/qq9A97C8i/Bgtyx2UG/8gtFdRzlangPRZbIYFbUQ=";

        const MODEL_DEFAULTS = {
            openai: "gpt-4o-mini",
            groq: "llama-3.3-70b-versatile"
        };

        const FRAME_MODES = ["sales", "training", "wiki"];
        const DEFAULT_WIKI_SEEDS = [];
        const DEFAULT_LIBRARY_SEEDS = [
            {
                id: "abo_kuendigung_vergessen",
                objectionKey: "subscription_aversion",
                objectionText: "Abo kündigen vergessen",
                suggestedReply: "Transparenz: Ich zeige kurz, was abgedeckt ist und was nicht. Sie entscheiden in Ruhe.",
                playbookRefs: [],
                sellerVotes: { works: 0, fails: 0 },
                lastUsedAt: 0,
                updatedAt: Date.now(),
                source: "seed"
            },
            {
                id: "zu_teuer",
                objectionKey: "price",
                objectionText: "Zu teuer",
                suggestedReply: "Ich zeige kurz, welcher Nutzen im Alltag für Sie relevant ist.",
                playbookRefs: [],
                sellerVotes: { works: 0, fails: 0 },
                lastUsedAt: 0,
                updatedAt: Date.now(),
                source: "seed"
            },
            {
                id: "ueberlege_noch",
                objectionKey: "uncertainty",
                objectionText: "Überlege noch",
                suggestedReply: "Gerne. Was müssten wir klären, damit Sie sicher entscheiden können?",
                playbookRefs: [],
                sellerVotes: { works: 0, fails: 0 },
                lastUsedAt: 0,
                updatedAt: Date.now(),
                source: "seed"
            },
            {
                id: "brauche_ich_nicht",
                objectionKey: "feature_gap",
                objectionText: "Brauche ich nicht",
                suggestedReply: "Verstanden. Darf ich fragen, was für Sie im Alltag wirklich zählt?",
                playbookRefs: [],
                sellerVotes: { works: 0, fails: 0 },
                lastUsedAt: 0,
                updatedAt: Date.now(),
                source: "seed"
            },
            {
                id: "nur_schauen",
                objectionKey: "trust",
                objectionText: "Nur schauen",
                suggestedReply: "Natürlich. Darf ich kurz verstehen, was Sie vergleichen möchten?",
                playbookRefs: [],
                sellerVotes: { works: 0, fails: 0 },
                lastUsedAt: 0,
                updatedAt: Date.now(),
                source: "seed"
            },
            {
                id: "online_guenstiger",
                objectionKey: "competitor",
                objectionText: "Online günstiger",
                suggestedReply: "Danke fürs Offen sagen. Wollen wir kurz den Gesamtvergleich machen?",
                playbookRefs: [],
                sellerVotes: { works: 0, fails: 0 },
                lastUsedAt: 0,
                updatedAt: Date.now(),
                source: "seed"
            },
            {
                id: "keine_zeit",
                objectionKey: "delivery",
                objectionText: "Keine Zeit",
                suggestedReply: "Verstanden. Was wäre der schnellste Weg für Sie: kurz klären oder gleich reservieren?",
                playbookRefs: [],
                sellerVotes: { works: 0, fails: 0 },
                lastUsedAt: 0,
                updatedAt: Date.now(),
                source: "seed"
            }
        ];
        const MAX_HISTORY = 15;
        const DEFAULT_TRAINING_STATE = {
            drillIndex: 0,
            roleplayStep: 0,
            selectedPattern: "all",
            variant: "neutral",
            sessions: 0,
            streak: 0,
            lastSessionDate: "",
            ratingSum: 0,
            ratingCount: 0
        };

        const PATTERN_RULES = {
            price: {
                attach: {
                    suggestion: "Servicepaket oder Zubehör mit klarem Mehrwert",
                    why: "Hilft, den Nutzen sichtbar zu machen, ohne Preis zu verteidigen.",
                    how_to_offer: "Optional und transparent anbieten, ohne Druck."
                },
                next_step: {
                    cta: "Direktvergleich starten",
                    two_options: ["Modelle nebeneinander zeigen", "Bedarf kurz abklären"]
                },
                microlearning: {
                    rule: "Wert vor Preis. Erst Nutzen, dann Zahlen.",
                    do: "Vergleich auf konkrete Vorteile lenken.",
                    dont: "Preis rechtfertigen oder diskutieren."
                }
            },
            trust: {
                attach: {
                    suggestion: "Transparente Dokumentation oder Service-Zusage",
                    why: "Stärkt Vertrauen ohne leere Versprechen.",
                    how_to_offer: "Sicherheiten zeigen, keine Behauptungen."
                },
                next_step: {
                    cta: "Transparenz anbieten",
                    two_options: ["Ablauf erklären", "Serviceprozess zeigen"]
                },
                microlearning: {
                    rule: "Vertrauen wächst durch Klarheit, nicht durch Druck.",
                    do: "Offen erklären und nachfragen.",
                    dont: "Mit Zahlen oder Versprechen übertreiben."
                }
            },
            risk: {
                attach: {
                    suggestion: "Schutz oder Garantie optional",
                    why: "Reduziert Risiko, wenn sauber erklärt.",
                    how_to_offer: "Transparenzsatz immer nennen."
                },
                next_step: {
                    cta: "Risiko klären",
                    two_options: ["Transparenz zu Schutz zeigen", "Alternativen prüfen"]
                },
                microlearning: {
                    rule: "Risiko konkret machen, aber nie Angst erzeugen.",
                    do: "Konkrete Szenarien ruhig erklären.",
                    dont: "Druck oder Angsttrigger."
                }
            },
            comparison: {
                attach: {
                    suggestion: "Live-Demo oder Side-by-Side Vergleich",
                    why: "Kontrolle entsteht durch Sichtbarkeit.",
                    how_to_offer: "Direkt am Floor zeigen."
                },
                next_step: {
                    cta: "Side-by-Side zeigen",
                    two_options: ["Kurzvergleich starten", "Features priorisieren"]
                },
                microlearning: {
                    rule: "Vergleich auf Kundenziele fokussieren.",
                    do: "Prioritäten erfragen.",
                    dont: "Feature-Overload."
                }
            },
            uncertainty: {
                attach: {
                    suggestion: "Reservierung oder Testlauf anbieten",
                    why: "Gibt Sicherheit ohne Druck.",
                    how_to_offer: "Zeit geben, aber Klarheit herstellen."
                },
                next_step: {
                    cta: "Bedenkzeit strukturieren",
                    two_options: ["Reservierung anbieten", "Offene Fragen klären"]
                },
                microlearning: {
                    rule: "Unsicherheit heißt: offene Frage finden.",
                    do: "Offen nachfragen.",
                    dont: "Zwangsabschluss."
                }
            },
            control: {
                attach: {
                    suggestion: "Alternative Close A/B",
                    why: "Kontrolle bleibt beim Kunden.",
                    how_to_offer: "Zwei klare Wege anbieten."
                },
                next_step: {
                    cta: "Alternative anbieten",
                    two_options: ["Option A wählen", "Option B wählen"]
                },
                microlearning: {
                    rule: "Kontrolle zurückgeben, nicht übernehmen.",
                    do: "A/B Frage stellen.",
                    dont: "Ja/Nein Frage."
                }
            },
            subscription_aversion: {
                attach: {
                    suggestion: "Transparenz-Check für Abo/Versicherung",
                    why: "Vermeidet Misstrauen.",
                    how_to_offer: "Konditionen offen zeigen, keine versteckten Kosten."
                },
                next_step: {
                    cta: "Transparenz zeigen",
                    two_options: ["Konditionen durchgehen", "Ohne Abo rechnen"]
                },
                microlearning: {
                    rule: "Transparenz zuerst, Verkauf später.",
                    do: "Monatlich und jährlich nennen.",
                    dont: "Abo als Pflicht darstellen."
                }
            }
        };

        const appState = {
            objection: "",
            contexts: [],
            cards: [],
            loading: false,
            stealthMode: false,
            lastFocused: null,
            frame: "sales",
            history: [],
            favorites: [],
            playbookRefs: [],
            library: [],
            training: { ...DEFAULT_TRAINING_STATE },
            wiki: {
                products: [],
                faq: [],
                notes: [],
                comparisons: [],
                entries: [],
                selectedEntryId: null,
                filters: { category: "all", brand: "all", feature: "all" },
                selectedProductId: null,
                searchQuery: "",
                answer: null
            },
            settings: {
                apiProvider: "openai",
                apiKey: "",
                apiKeyEncrypted: "",
                apiKeyIv: "",
                apiKeySalt: "",
                apiKeyLocked: false,
                sessionOnlyKey: false,
                modelName: "gpt-4o-mini",
                proxyUrl: "",
                department: "TV",
                storePolicy: "",
                themeMode: "auto",
                densityMode: "",
                densityUserSet: false,
                frameMode: "sales",
                wikiSourceUrl: "",
                lastSyncAt: "",
                lastWikiSyncAt: ""
            },
            ui: {
                online: navigator.onLine,
                syncStatus: "idle",
                lastSync: null,
                lastWikiSync: null,
                techQuestion: false,
                debug: false
            },
            stats: {
                cases: 0,
                logs: 0
            }
        };

        const storage = {
            mode: "indexeddb",
            db: null,
            ready: false
        };

        const toastQueue = [];
        let toastActive = false;
        let recognition = null;
        let modalHistoryActive = false;
        let ignoreNextPop = false;
        let reduceMotionMedia = window.matchMedia("(prefers-reduced-motion: reduce)");
        let themeMedia = window.matchMedia("(prefers-color-scheme: dark)");
        let controlBarObserver = null;
        let densityResizeRaf = null;
        const modalStack = [];
        let panelDocked = false;
        let panelOpen = false;
        let panelHoldTimer = null;
        let panelTouchStart = null;

        const elements = {};

        const SEED_CASES = [
            {
                id: "seed_price_1",
                objection: "zu teuer",
                keywords: ["teuer", "preis", "kostet", "viel", "hoch", "expensive"],
                meta: { status: "success", pattern: "price", safety: "clean" },
                ui: { color: "success", icon: "tag" },
                content: {
                    quick: {
                        neutral: {
                            entry: "Ich verstehe, dass der Preis im ersten Moment hoch erscheint.",
                            anchor: "Viele Kundinnen und Kunden achten zuerst auf den Preis und entscheiden sich dann für den Nutzen.",
                            question: "Darf ich Ihnen kurz zeigen, was dieses Modell im Alltag besser macht?",
                            bridge: "So sehen Sie, ob der Mehrwert den Aufpreis für Sie rechtfertigt.",
                            close: "Welche Option passt besser zu Ihrem Bedarf: Fokus auf Preis oder Fokus auf Nutzen?"
                        },
                        soft: {
                            entry: "Völlig nachvollziehbar, der Preis wirkt im ersten Moment hoch.",
                            anchor: "Viele Kundinnen und Kunden fühlen sich am Anfang genauso.",
                            question: "Darf ich Ihnen die wichtigsten Vorteile in Ruhe zeigen?",
                            bridge: "Dann entscheiden Sie entspannt, ob es für Sie passt.",
                            close: "Was wäre Ihnen wichtiger: eine sichere Lösung oder ein günstiger Einstieg?"
                        },
                        challenger: {
                            entry: "Lassen Sie uns kurz anders drauf schauen: Es geht weniger um den Preis als um den Nutzen.",
                            anchor: "Viele Kundinnen und Kunden unterschätzen den Unterschied im Alltag.",
                            question: "Darf ich Ihnen den konkreten Unterschied in zwei Punkten zeigen?",
                            bridge: "Damit wird klar, ob das Gerät die bessere Investition ist.",
                            close: "Wollen wir nach Nutzen entscheiden: A) Alltag, B) Preis?"
                        }
                    },
                    smart: {
                        text: "Preis ist wichtig. Der Unterschied ist: Das günstigere Modell hat X, unser Modell bietet zusätzlich Y und Z. Das wirkt sich im Alltag direkt aus. Viele entscheiden sich deshalb für die Lösung, die länger sinnvoll bleibt.",
                        closing: "Sollen wir beide Modelle kurz nebeneinander ansehen?"
                    },
                    coach: {
                        diagnosis: "Preiseinwand ist ein Kontrolleinwand.",
                        strategy: "Von Preis auf Nutzen shiften, ohne zu verteidigen.",
                        behavioral_fix: "Value-Frame vor Zahlen.",
                        drill: [
                            "Übe: Nutzen in 2 Sätzen erklären.",
                            "Übe: Alternative Close statt Ja/Nein."
                        ]
                    },
                    attach: {
                        suggestion: "Servicepaket oder Zubehör mit klarem Mehrwert",
                        why: "Macht Nutzen sichtbar und reduziert Preissensibilität.",
                        how_to_offer: "Optional anbieten, transparent bleiben."
                    },
                    next_step: {
                        cta: "Direktvergleich starten",
                        two_options: ["Modelle nebeneinander zeigen", "Bedarf kurz abklären"]
                    }
                },
                createdAt: Date.now()
            },
            {
                id: "seed_sub_1",
                objection: "keine versicherung",
                keywords: ["versicherung", "garantie", "schutz", "abo", "absicherung"],
                meta: { status: "success", pattern: "subscription_aversion", safety: "transparency_required" },
                ui: { color: "warning", icon: "shield" },
                content: {
                    quick: {
                        neutral: {
                            entry: "Verstehe ich vollkommen, Versicherungen sind nicht jedermanns Sache.",
                            anchor: "Viele Kundinnen und Kunden überlegen erst genau, bevor sie so etwas wählen.",
                            question: "Darf ich Ihnen transparent zeigen, was abgedeckt wäre und was nicht?",
                            bridge: "Transparenz: Alle Kosten und Bedingungen sind offen, keine versteckten Gebühren.",
                            close: "Wollen Sie die Konditionen sehen oder lieber ohne Schutz rechnen?"
                        },
                        soft: {
                            entry: "Das ist verständlich. Sie wollen keine unnötigen Zusatzkosten.",
                            anchor: "Viele Kundinnen und Kunden denken ähnlich, bevor sie die Details sehen.",
                            question: "Darf ich Ihnen die Konditionen ganz offen zeigen?",
                            bridge: "Transparenz: Sie sehen alle Kosten und Bedingungen klar auf einen Blick.",
                            close: "Welche Variante ist für Sie angenehmer: mit Schutz oder ohne?"
                        },
                        challenger: {
                            entry: "Lassen Sie uns kurz klar unterscheiden: Schutz ist keine Pflicht, sondern ein Tool.",
                            anchor: "Viele Kundinnen und Kunden entscheiden erst nach dem Fakten-Check.",
                            question: "Darf ich Ihnen die Fakten kurz zeigen?",
                            bridge: "Transparenz: Keine versteckten Kosten, alle Bedingungen offen.",
                            close: "Welche Option passt besser: volle Absicherung oder maximaler Preisfokus?"
                        }
                    },
                    smart: {
                        text: "Kein Problem. Der Schutz deckt konkrete Fälle ab und ist optional. Wichtig ist, dass Sie alle Details sehen und dann selbst entscheiden.",
                        closing: "Möchten Sie die Konditionen kurz ansehen?"
                    },
                    coach: {
                        diagnosis: "Abo-Abwehr wegen Misstrauen oder Unklarheit.",
                        strategy: "Transparenz zuerst, Druck vermeiden.",
                        behavioral_fix: "Kosten offen zeigen, Entscheidung zurückgeben.",
                        drill: [
                            "Übe: Transparenzsatz in einem Satz.",
                            "Übe: A/B Frage ohne Druck."
                        ]
                    },
                    attach: {
                        suggestion: "Transparenz-Check für Schutz/Versicherung",
                        why: "Reduziert Misstrauen durch Klarheit.",
                        how_to_offer: "Konditionen offen zeigen, keine Behauptungen."
                    },
                    next_step: {
                        cta: "Transparenz zeigen",
                        two_options: ["Konditionen durchgehen", "Ohne Schutz rechnen"]
                    }
                },
                createdAt: Date.now()
            },
            {
                id: "seed_uncertainty_1",
                objection: "muss überlegen",
                keywords: ["überlegen", "bedenkzeit", "später", "nachdenken", "warten"],
                meta: { status: "success", pattern: "uncertainty", safety: "clean" },
                ui: { color: "success", icon: "clock" },
                content: {
                    quick: {
                        neutral: {
                            entry: "Natürlich, das ist eine wichtige Entscheidung.",
                            anchor: "Viele Kundinnen und Kunden nehmen sich dafür bewusst Zeit.",
                            question: "Darf ich fragen, was Ihnen noch unklar ist?",
                            bridge: "Wenn wir den Punkt klären, fällt die Entscheidung leichter.",
                            close: "Wollen Sie reservieren oder zuerst die offenen Punkte klären?"
                        },
                        soft: {
                            entry: "Das ist absolut okay. Sie wollen Sicherheit.",
                            anchor: "Viele nehmen sich genau dafür Zeit.",
                            question: "Was wäre der wichtigste Punkt, den wir klären sollten?",
                            bridge: "Dann gehen Sie mit einem guten Gefühl.",
                            close: "Möchten Sie eine Reservierung oder lieber eine kurze Klärung?"
                        },
                        challenger: {
                            entry: "Lassen Sie uns den einen Punkt finden, der Sie noch bremst.",
                            anchor: "Viele Kundinnen und Kunden zögern wegen genau einer Sache.",
                            question: "Liegt es eher an Technik, Preis oder Nutzung?",
                            bridge: "Wenn wir das klären, ist die Entscheidung klarer.",
                            close: "Sollen wir klären oder reservieren?"
                        }
                    },
                    smart: {
                        text: "Verständlich. Die Frage ist meist: Passt das Gerät wirklich zu Ihrem Alltag? Wenn wir den Punkt klären, wird die Entscheidung leichter.",
                        closing: "Soll ich es für Sie reservieren?"
                    },
                    coach: {
                        diagnosis: "Unklarheit oder verdeckter Einwand.",
                        strategy: "Offene Frage stellen, Klarheit schaffen.",
                        behavioral_fix: "Zeit geben, aber strukturieren.",
                        drill: [
                            "Übe: Offene Frage statt Druck.",
                            "Übe: Reservierung als Service."
                        ]
                    },
                    attach: {
                        suggestion: "Reservierung oder Testlauf anbieten",
                        why: "Gibt Sicherheit ohne Druck.",
                        how_to_offer: "Als Service anbieten."
                    },
                    next_step: {
                        cta: "Bedenkzeit strukturieren",
                        two_options: ["Reservierung anbieten", "Offene Fragen klären"]
                    }
                },
                createdAt: Date.now()
            }
        ];

        const JOKER_CARD = {
            id: "joker",
            meta: { status: "success", pattern: "trust", safety: "clean" },
            ui: { color: "success", icon: "info" },
            content: {
                quick: {
                    neutral: {
                        entry: "Ich verstehe Ihre Bedenken vollkommen.",
                        anchor: "Viele Kundinnen und Kunden stellen diese Frage, und das ist richtig so.",
                        question: "Darf ich Ihnen kurz zeigen, wie wir das handhaben?",
                        bridge: "Mir ist wichtig, dass Sie sich gut informiert fühlen.",
                        close: "Welche Info hilft Ihnen jetzt am meisten?"
                    },
                    soft: {
                        entry: "Das ist absolut verständlich.",
                        anchor: "Viele möchten genau diese Klarheit.",
                        question: "Darf ich Ihnen die wichtigsten Infos dazu geben?",
                        bridge: "Dann entscheiden Sie mit Sicherheit.",
                        close: "Welche Info wäre für Sie am hilfreichsten?"
                    },
                    challenger: {
                        entry: "Lassen Sie uns das klar einordnen.",
                        anchor: "Viele Kundinnen und Kunden fragen genau das.",
                        question: "Darf ich die Fakten kurz ordnen?",
                        bridge: "So bleibt die Entscheidung transparent.",
                        close: "Was ist wichtiger: Klarheit oder Geschwindigkeit?"
                    }
                },
                smart: {
                    text: "Das ist eine berechtigte Frage. Wenn wir das kurz klären, fühlen Sie sich sicherer.",
                    closing: "Welche Info brauchen Sie jetzt konkret?"
                },
                coach: {
                    diagnosis: "Unbekannter Einwand, Bedarf an Klarheit.",
                    strategy: "Empathie + offene Frage.",
                    behavioral_fix: "Keine Defensive, Fokus auf Dialog.",
                    drill: [
                        "Übe: 2 Sekunden Pause vor Antwort.",
                        "Übe: Rückfrage zum Bedarf."
                    ]
                },
                attach: {
                    suggestion: "Transparenz-Check",
                    why: "Erhöht Vertrauen.",
                    how_to_offer: "Fakten kurz strukturieren."
                },
                next_step: {
                    cta: "Dialog öffnen",
                    two_options: ["Fakten klären", "Alternativen prüfen"]
                }
            },
            createdAt: Date.now()
        };

        function cacheElements() {
            elements.header = document.getElementById("header");
            elements.stage = document.getElementById("stage");
            elements.themeColorMeta = document.getElementById("themeColorMeta");
            elements.onlineStatus = document.getElementById("onlineStatus");
            elements.onlineStatusLabel = document.getElementById("onlineStatusLabel");
            elements.deptBadge = document.getElementById("deptBadge");
            elements.frameSalesBtn = document.getElementById("frameSalesBtn");
            elements.frameTrainingBtn = document.getElementById("frameTrainingBtn");
            elements.frameWikiBtn = document.getElementById("frameWikiBtn");
            elements.syncBtn = document.getElementById("syncBtn");
            elements.settingsBtn = document.getElementById("settingsBtn");
            elements.offlineBanner = document.getElementById("offlineBanner");
            elements.salesFrame = document.getElementById("salesFrame");
            elements.trainingFrame = document.getElementById("trainingFrame");
            elements.wikiFrame = document.getElementById("wikiFrame");
            elements.salesCardContainer = document.getElementById("salesCardContainer");
            elements.salesPlaybook = document.getElementById("salesPlaybook");
            elements.historyList = document.getElementById("historyList");
            elements.favoriteList = document.getElementById("favoriteList");
            elements.trainingCardContainer = document.getElementById("trainingCardContainer");
            elements.trainingCardTitle = document.getElementById("trainingCardTitle");
            elements.variantSoftBtn = document.getElementById("variantSoftBtn");
            elements.variantNeutralBtn = document.getElementById("variantNeutralBtn");
            elements.variantChallengerBtn = document.getElementById("variantChallengerBtn");
            elements.roleplayPrompt = document.getElementById("roleplayPrompt");
            elements.roleplayResponse = document.getElementById("roleplayResponse");
            elements.roleplayBtn = document.getElementById("roleplayBtn");
            elements.roleplaySoftBtn = document.getElementById("roleplaySoftBtn");
            elements.roleplayNeutralBtn = document.getElementById("roleplayNeutralBtn");
            elements.roleplayChallengerBtn = document.getElementById("roleplayChallengerBtn");
            elements.drillText = document.getElementById("drillText");
            elements.nextDrillBtn = document.getElementById("nextDrillBtn");
            elements.drillDoneBtn = document.getElementById("drillDoneBtn");
            elements.ratingButtons = document.getElementById("ratingButtons");
            elements.patternFilter = document.getElementById("patternFilter");
            elements.patternList = document.getElementById("patternList");
            elements.microlearningBox = document.getElementById("microlearningBox");
            elements.trainingStats = document.getElementById("trainingStats");
            elements.trainingWeaknessList = document.getElementById("trainingWeaknessList");
            elements.trainingHistoryList = document.getElementById("trainingHistoryList");
            elements.wikiSearchInput = document.getElementById("wikiSearchInput");
            elements.wikiFilterChips = document.getElementById("wikiFilterChips");
            elements.wikiSyncBtn = document.getElementById("wikiSyncBtn");
            elements.wikiClearBtn = document.getElementById("wikiClearBtn");
            elements.wikiResults = document.getElementById("wikiResults");
            elements.wikiDetail = document.getElementById("wikiDetail");
            elements.wikiEntryList = document.getElementById("wikiEntryList");
            elements.wikiEntryDetail = document.getElementById("wikiEntryDetail");
            elements.wikiNewBtn = document.getElementById("wikiNewBtn");
            elements.wikiQuestionInput = document.getElementById("wikiQuestionInput");
            elements.wikiQuestionBtn = document.getElementById("wikiQuestionBtn");
            elements.wikiAnswerStatus = document.getElementById("wikiAnswerStatus");
            elements.wikiAnswerText = document.getElementById("wikiAnswerText");
            elements.wikiCitations = document.getElementById("wikiCitations");
            elements.wikiCompareList = document.getElementById("wikiCompareList");
            elements.wikiEditorModal = document.getElementById("wikiEditorModal");
            elements.wikiEditorForm = document.getElementById("wikiEditorForm");
            elements.wikiEditorId = document.getElementById("wikiEditorId");
            elements.wikiTitle = document.getElementById("wikiTitle");
            elements.wikiCategory = document.getElementById("wikiCategory");
            elements.wikiBrand = document.getElementById("wikiBrand");
            elements.wikiTags = document.getElementById("wikiTags");
            elements.wikiKurz = document.getElementById("wikiKurz");
            elements.wikiSpecs = document.getElementById("wikiSpecs");
            elements.wikiFaq = document.getElementById("wikiFaq");
            elements.wikiEditorCloseBtn = document.getElementById("wikiEditorCloseBtn");
            elements.wikiEditorCancelBtn = document.getElementById("wikiEditorCancelBtn");
            elements.wikiEditorSaveBtn = document.getElementById("wikiEditorSaveBtn");
            elements.objectionInput = document.getElementById("objectionInput");
            elements.submitBtn = document.getElementById("submitBtn");
            elements.micBtn = document.getElementById("micBtn");
            elements.contextChips = document.getElementById("contextChips");
            elements.techQuestionToggle = document.getElementById("techQuestionToggle");
            elements.buildInfo = document.getElementById("buildInfo");
            elements.toast = document.getElementById("toast");
            elements.settingsModal = document.getElementById("settingsModal");
            elements.closeSettingsBtn = document.getElementById("closeSettingsBtn");
            elements.saveSettingsBtn = document.getElementById("saveSettingsBtn");
            elements.apiProvider = document.getElementById("apiProvider");
            elements.apiKey = document.getElementById("apiKey");
            elements.sessionOnlyKey = document.getElementById("sessionOnlyKey");
            elements.passphraseInput = document.getElementById("passphraseInput");
            elements.lockToggleBtn = document.getElementById("lockToggleBtn");
            elements.unlockBtn = document.getElementById("unlockBtn");
            elements.lockStatus = document.getElementById("lockStatus");
            elements.modelName = document.getElementById("modelName");
            elements.proxyUrl = document.getElementById("proxyUrl");
            elements.wikiSourceUrl = document.getElementById("wikiSourceUrl");
            elements.department = document.getElementById("department");
            elements.storePolicy = document.getElementById("storePolicy");
            elements.exportBtn = document.getElementById("exportBtn");
            elements.importBtn = document.getElementById("importBtn");
            elements.importFile = document.getElementById("importFile");
            elements.libraryExportBtn = document.getElementById("libraryExportBtn");
            elements.libraryImportBtn = document.getElementById("libraryImportBtn");
            elements.libraryImportFile = document.getElementById("libraryImportFile");
            elements.wikiResetBtn = document.getElementById("wikiResetBtn");
            elements.clearBtn = document.getElementById("clearBtn");
            elements.confirmModal = document.getElementById("confirmModal");
            elements.confirmTitle = document.getElementById("confirmTitle");
            elements.confirmMessage = document.getElementById("confirmMessage");
            elements.confirmConfirmBtn = document.getElementById("confirmConfirmBtn");
            elements.confirmCancelBtn = document.getElementById("confirmCancelBtn");
            elements.confirmCloseBtn = document.getElementById("confirmCloseBtn");
            elements.confirmExtra = document.getElementById("confirmExtra");
            elements.confirmInput = document.getElementById("confirmInput");
            elements.confirmHoldHint = document.getElementById("confirmHoldHint");
            elements.stealthOverlay = document.getElementById("stealthOverlay");
            elements.themeAuto = document.getElementById("themeAuto");
            elements.themeLight = document.getElementById("themeLight");
            elements.themeDark = document.getElementById("themeDark");
            elements.densityCompact = document.getElementById("densityCompact");
            elements.densityComfortable = document.getElementById("densityComfortable");
            elements.syncTime = document.getElementById("syncTime");
        }

        function escapeHTML(value) {
            return String(value)
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#39;");
        }

        function sanitizeString(value, maxLength = 200) {
            if (typeof value !== "string") return "";
            return value.trim().slice(0, maxLength);
        }

        function sanitizeEnum(value, allowed, fallback) {
            if (allowed.includes(value)) return value;
            return fallback;
        }

        function sanitizeArray(values, maxLength = 50) {
            if (!Array.isArray(values)) return [];
            return values.map(item => sanitizeString(item, maxLength)).filter(Boolean);
        }

        function safeParseJSON(raw, fallback) {
            if (!raw) return fallback;
            try {
                return JSON.parse(raw);
            } catch {
                return fallback;
            }
        }

        function sanitizeImportSettings(settings) {
            if (!settings || typeof settings !== "object") return null;
            return {
                apiProvider: sanitizeEnum(settings.apiProvider, ["openai", "groq"], "openai"),
                apiKey: sanitizeString(settings.apiKey, 200),
                apiKeyEncrypted: sanitizeString(settings.apiKeyEncrypted, 2000),
                apiKeyIv: sanitizeString(settings.apiKeyIv, 200),
                apiKeySalt: sanitizeString(settings.apiKeySalt, 200),
                apiKeyLocked: Boolean(settings.apiKeyLocked),
                sessionOnlyKey: Boolean(settings.sessionOnlyKey),
                modelName: sanitizeString(settings.modelName, 80) || MODEL_DEFAULTS.openai,
                proxyUrl: sanitizeString(settings.proxyUrl, 200),
                department: sanitizeString(settings.department, 40) || "TV",
                storePolicy: sanitizeString(settings.storePolicy, 400),
                themeMode: sanitizeEnum(settings.themeMode, ["auto", "light", "dark"], "auto"),
                densityMode: sanitizeEnum(settings.densityMode, ["compact", "comfortable"], ""),
                densityUserSet: Boolean(settings.densityUserSet),
                frameMode: sanitizeEnum(settings.frameMode, FRAME_MODES, "sales"),
                wikiSourceUrl: sanitizeString(settings.wikiSourceUrl, 200),
                lastSyncAt: sanitizeString(settings.lastSyncAt, 40),
                lastWikiSyncAt: sanitizeString(settings.lastWikiSyncAt, 40)
            };
        }

        function showToast(message, options = {}) {
            const entry = {
                message: sanitizeString(message, 160),
                duration: options.duration || 3000
            };
            toastQueue.push(entry);
            if (!toastActive) displayNextToast();
        }

        function displayNextToast() {
            if (toastQueue.length === 0) {
                toastActive = false;
                return;
            }
            toastActive = true;
            const { message, duration } = toastQueue.shift();
            elements.toast.textContent = message;
            elements.toast.classList.add("show");
            setTimeout(() => {
                elements.toast.classList.remove("show");
                setTimeout(displayNextToast, 250);
            }, duration);
        }

        function haptic(pattern = [40]) {
            if ("vibrate" in navigator) {
                navigator.vibrate(pattern);
            }
        }

        function updateThemeColorMeta() {
            const color = getComputedStyle(document.documentElement).getPropertyValue("--color-bg").trim();
            elements.themeColorMeta.setAttribute("content", color || "#000000");
        }

        function resolveTheme(mode) {
            if (mode === "auto") {
                return themeMedia.matches ? "dark" : "light";
            }
            return mode;
        }

        function applyTheme(mode, persist = true) {
            appState.settings.themeMode = mode;
            const resolved = resolveTheme(mode);
            document.documentElement.setAttribute("data-theme", resolved);
            if (elements.themeToggleLabel) {
                elements.themeToggleLabel.textContent = `Theme: ${mode === "auto" ? "Auto" : resolved.charAt(0).toUpperCase() + resolved.slice(1)}`;
            }
            updateThemeColorMeta();
            if (persist) saveSettings(buildPersistedSettings());
            updateDiagnostics();
        }

        function computeDensity(width) {
            return width >= 900 ? "compact" : "comfortable";
        }

        function applyDensity(mode, userSet = false, persist = true) {
            appState.settings.densityMode = mode;
            if (userSet) appState.settings.densityUserSet = true;
            document.documentElement.setAttribute("data-density", mode);
            const label = mode === "compact" ? "Kompakt" : "Comfort";
            if (elements.densityToggleLabel) {
                elements.densityToggleLabel.textContent = `Dichte: ${label}`;
            }
            if (persist) saveSettings(buildPersistedSettings());
            updateDiagnostics();
        }

        function cycleTheme() {
            const cycle = ["auto", "light", "dark"];
            const current = appState.settings.themeMode;
            const next = cycle[(cycle.indexOf(current) + 1) % cycle.length];
            applyTheme(next);
            updateTrustStatus();
        }

        function toggleDensity() {
            const next = appState.settings.densityMode === "compact" ? "comfortable" : "compact";
            applyDensity(next, true);
        }

        function getFrameDirection(previous, next) {
            const order = { sales: 0, training: 1, wiki: 2 };
            if (previous === next) return "forward";
            return order[next] > order[previous] ? "forward" : "backward";
        }

        function withViewTransition(fn, direction = "forward") {
            document.documentElement.setAttribute("data-view-direction", direction);
            if (document.startViewTransition) {
                const transition = document.startViewTransition(() => fn());
                transition.finished.finally(() => {
                    document.documentElement.removeAttribute("data-view-direction");
                });
                return;
            }
            fn();
            document.documentElement.removeAttribute("data-view-direction");
        }

        function setFrame(mode, persist = true) {
            if (!FRAME_MODES.includes(mode)) return;
            const previous = appState.frame;
            const direction = getFrameDirection(previous, mode);
            const apply = () => {
                appState.frame = mode;
                document.documentElement.setAttribute("data-frame", mode);
                elements.frameSalesBtn.setAttribute("aria-pressed", String(mode === "sales"));
                elements.frameTrainingBtn.setAttribute("aria-pressed", String(mode === "training"));
                elements.frameWikiBtn.setAttribute("aria-pressed", String(mode === "wiki"));
                elements.salesFrame.setAttribute("aria-hidden", String(mode !== "sales"));
                elements.trainingFrame.setAttribute("aria-hidden", String(mode !== "training"));
                elements.wikiFrame.setAttribute("aria-hidden", String(mode !== "wiki"));
            };
            if (previous === mode) {
                apply();
            } else {
                withViewTransition(apply, direction);
            }
            if (persist) {
                appState.settings.frameMode = mode;
                saveSettings(buildPersistedSettings());
            }
        }

        function updateContextStatus() {
            const label = appState.contexts.length ? appState.contexts.join(", ") : "Neutral";
            if (elements.statContext) {
                elements.statContext.textContent = `Kontext: ${label}`;
            }
        }

        function updateTrustStatus() {
            const keyStatus = appState.settings.apiKeyLocked ? "Key: Locked" : appState.settings.apiKey ? "Key: Aktiv" : "Key: Nicht gesetzt";
            if (elements.trustKeyStatus) {
                elements.trustKeyStatus.textContent = keyStatus;
            }
            const proxyValid = validateProxyUrl(appState.settings.proxyUrl);
            const proxyStatus = proxyValid.ok ? "Proxy: Aktiv" : "Proxy: Aus";
            if (elements.trustProxyStatus) {
                elements.trustProxyStatus.textContent = proxyStatus;
            }
            if (elements.trustMotionStatus) {
                elements.trustMotionStatus.textContent = reduceMotionMedia.matches ? "Motion: Reduced" : "Motion: Standard";
            }
        }

        function updatePolicyTile() {
            const policy = sanitizeString(appState.settings.storePolicy, 400);
            if (!elements.policyTitle || !elements.policyText) return;
            if (policy) {
                elements.policyTitle.textContent = "Aktive Policy";
                elements.policyText.textContent = policy;
            } else {
                elements.policyTitle.textContent = "Keine Aktion aktiv";
                elements.policyText.textContent = "Trage im Settings-Panel aktuelle Aktionen ein, um Scarcity sicher zu nutzen.";
            }
        }

        function updateOnlineStatus() {
            appState.ui.online = navigator.onLine;
            if (elements.offlineBanner) {
                elements.offlineBanner.classList.toggle("show", !appState.ui.online);
            }
            if (!appState.ui.online) {
                setSyncStatus("offline", "Offline");
            } else if (appState.ui.syncStatus === "offline") {
                appState.ui.syncStatus = "idle";
            }
            updateStatusIndicator();
            updateDiagnostics();
        }

        function updateStatusIndicator() {
            if (!elements.onlineStatus || !elements.onlineStatusLabel) return;
            let status = "online";
            let label = "Online";
            if (!appState.ui.online) {
                status = "offline";
                label = "Offline";
            } else if (appState.ui.syncStatus === "syncing") {
                status = "syncing";
                label = "Syncing";
            } else if (appState.ui.syncStatus === "error") {
                status = "error";
                label = "Sync Fehler";
            }
            elements.onlineStatus.dataset.status = status;
            elements.onlineStatusLabel.textContent = label;
        }

        function getCspMode() {
            const meta = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
            if (!meta) return "unknown";
            const content = meta.getAttribute("content") || "";
            if (content.includes("'unsafe-inline'")) return "Level 1 (unsafe-inline)";
            if (content.includes("sha256-")) return "Level 2 (hash)";
            return "custom";
        }

        function updateDiagnostics() {
            if (!elements.diagTheme) return;
            const mode = appState.settings.themeMode;
            const resolved = resolveTheme(mode);
            elements.diagTheme.textContent = `${mode} (${resolved})`;
            elements.diagDensity.textContent = appState.settings.densityMode || "auto";
            elements.diagOnline.textContent = appState.ui.online ? "online" : "offline";
            const dbState = storage.ready ? `ready (${storage.mode})` : `loading (${storage.mode})`;
            elements.diagDb.textContent = dbState;
            elements.diagCsp.textContent = getCspMode();
        }

        function setDebugMode(enabled) {
            appState.ui.debug = enabled;
            document.documentElement.setAttribute("data-debug", enabled ? "true" : "false");
            if (elements.diagnosticsTile) {
                elements.diagnosticsTile.setAttribute("aria-hidden", String(!enabled));
            }
            updateDiagnostics();
        }

        function setSyncStatus(status, label) {
            appState.ui.syncStatus = status;
            if (elements.syncIndicator) {
                elements.syncIndicator.dataset.status = status;
                elements.syncIndicator.textContent = label || status;
            }
            if (elements.syncTitle) {
                elements.syncTitle.textContent = label || status;
            }
            updateStatusIndicator();
        }

        function updateSyncTime() {
            if (!elements.syncTime) return;
            if (!appState.ui.lastSync) {
                elements.syncTime.textContent = "–";
                return;
            }
            const date = new Date(appState.ui.lastSync);
            elements.syncTime.textContent = date.toLocaleString("de-AT", { hour: "2-digit", minute: "2-digit" });
        }

        function buildPersistedSettings() {
            const settings = { ...appState.settings };
            if (settings.apiKeyLocked || settings.sessionOnlyKey) {
                settings.apiKey = "";
            }
            if (settings.sessionOnlyKey) {
                settings.apiKeyEncrypted = "";
                settings.apiKeyIv = "";
                settings.apiKeySalt = "";
                settings.apiKeyLocked = false;
            }
            return settings;
        }

        function setAppInert(isInert) {
            const targets = [elements.header, elements.stage, elements.controlBar, document.querySelector("footer")];
            targets.forEach(target => {
                if (!target) return;
                if (isInert) {
                    target.setAttribute("aria-hidden", "true");
                } else {
                    target.removeAttribute("aria-hidden");
                }
            });
        }

        function openModal(modal) {
            appState.lastFocused = document.activeElement;
            if (modal.tagName === "DIALOG") {
                if (!modal.open) modal.showModal();
            } else {
                modal.classList.add("open");
            }
            modal.setAttribute("aria-hidden", "false");
            setAppInert(true);
            trapFocus(modal);
            if (!modalStack.includes(modal.id)) {
                modalStack.push(modal.id);
            }
            if (modalStack.length === 1 && !modalHistoryActive) {
                history.pushState({ modal: modal.id }, "");
                modalHistoryActive = true;
            }
        }

        function closeModal(modal, fromPopstate = false) {
            if (modal.tagName === "DIALOG") {
                if (modal.open) modal.close();
            } else {
                modal.classList.remove("open");
            }
            modal.setAttribute("aria-hidden", "true");
            releaseFocusTrap(modal);
            const index = modalStack.indexOf(modal.id);
            if (index > -1) {
                modalStack.splice(index, 1);
            }
            setAppInert(modalStack.length > 0);
            if (appState.lastFocused) {
                appState.lastFocused.focus();
            }
            if (modalHistoryActive && !fromPopstate && modalStack.length === 0) {
                ignoreNextPop = true;
                history.back();
            }
            if (modalStack.length === 0) {
                modalHistoryActive = false;
            }
        }

        function trapFocus(modal) {
            const focusable = modal.querySelectorAll("button, [href], input, select, textarea, [tabindex]:not([tabindex='-1'])");
            if (!focusable.length) return;
            const first = focusable[0];
            const last = focusable[focusable.length - 1];
            modal._focusHandler = (event) => {
                if (event.key !== "Tab") return;
                if (event.shiftKey && document.activeElement === first) {
                    event.preventDefault();
                    last.focus();
                } else if (!event.shiftKey && document.activeElement === last) {
                    event.preventDefault();
                    first.focus();
                }
            };
            modal.addEventListener("keydown", modal._focusHandler);
            first.focus();
        }

        function releaseFocusTrap(modal) {
            if (modal._focusHandler) {
                modal.removeEventListener("keydown", modal._focusHandler);
                modal._focusHandler = null;
            }
        }

        function confirmAction({ title, message, confirmLabel, requireText, holdMs }) {
            return new Promise(resolve => {
                elements.confirmTitle.textContent = title;
                elements.confirmMessage.textContent = message;
                elements.confirmConfirmBtn.textContent = confirmLabel || "Bestätigen";
                const requiresText = Boolean(requireText);
                const requiresHold = typeof holdMs === "number";

                if (elements.confirmExtra) {
                    elements.confirmExtra.hidden = !requiresText;
                }
                if (elements.confirmInput) {
                    elements.confirmInput.value = "";
                }
                if (elements.confirmHoldHint) {
                    elements.confirmHoldHint.textContent = requiresHold ? `Zum Bestätigen ${holdMs}ms halten.` : "";
                    elements.confirmHoldHint.style.display = requiresHold ? "block" : "none";
                }

                const updateConfirmState = () => {
                    if (requiresText && elements.confirmInput) {
                        elements.confirmConfirmBtn.disabled = elements.confirmInput.value.trim() !== requireText;
                    } else {
                        elements.confirmConfirmBtn.disabled = false;
                    }
                };

                updateConfirmState();

                const handleConfirm = () => {
                    cleanup();
                    resolve(true);
                };

                const handleCancel = () => {
                    cleanup();
                    resolve(false);
                };

                const handleHoldStart = () => {
                    if (elements.confirmConfirmBtn.disabled) return;
                    if (panelHoldTimer) {
                        clearTimeout(panelHoldTimer);
                        panelHoldTimer = null;
                    }
                    elements.confirmConfirmBtn.classList.add("hold-active");
                    panelHoldTimer = window.setTimeout(() => {
                        elements.confirmConfirmBtn.classList.remove("hold-active");
                        handleConfirm();
                    }, holdMs);
                };

                const handleHoldEnd = () => {
                    if (panelHoldTimer) {
                        clearTimeout(panelHoldTimer);
                        panelHoldTimer = null;
                        elements.confirmConfirmBtn.classList.remove("hold-active");
                    }
                };

                const swallowClick = (event) => {
                    if (requiresHold) {
                        event.preventDefault();
                    }
                };

                const cleanup = () => {
                    if (panelHoldTimer) {
                        clearTimeout(panelHoldTimer);
                        panelHoldTimer = null;
                    }
                    elements.confirmConfirmBtn.removeEventListener("click", handleConfirm);
                    elements.confirmConfirmBtn.removeEventListener("click", swallowClick);
                    elements.confirmConfirmBtn.removeEventListener("pointerdown", handleHoldStart);
                    elements.confirmConfirmBtn.removeEventListener("pointerup", handleHoldEnd);
                    elements.confirmConfirmBtn.removeEventListener("pointerleave", handleHoldEnd);
                    elements.confirmConfirmBtn.removeEventListener("pointercancel", handleHoldEnd);
                    elements.confirmCancelBtn.removeEventListener("click", handleCancel);
                    elements.confirmCloseBtn.removeEventListener("click", handleCancel);
                    if (elements.confirmInput) {
                        elements.confirmInput.removeEventListener("input", updateConfirmState);
                    }
                    if (elements.confirmExtra) {
                        elements.confirmExtra.hidden = true;
                    }
                    elements.confirmConfirmBtn.disabled = false;
                    closeModal(elements.confirmModal);
                };

                if (requiresText && elements.confirmInput) {
                    elements.confirmInput.addEventListener("input", updateConfirmState);
                }
                if (requiresHold) {
                    elements.confirmConfirmBtn.addEventListener("pointerdown", handleHoldStart);
                    elements.confirmConfirmBtn.addEventListener("pointerup", handleHoldEnd);
                    elements.confirmConfirmBtn.addEventListener("pointerleave", handleHoldEnd);
                    elements.confirmConfirmBtn.addEventListener("pointercancel", handleHoldEnd);
                    elements.confirmConfirmBtn.addEventListener("click", swallowClick);
                } else {
                    elements.confirmConfirmBtn.addEventListener("click", handleConfirm);
                }
                elements.confirmCancelBtn.addEventListener("click", handleCancel);
                elements.confirmCloseBtn.addEventListener("click", handleCancel);
                openModal(elements.confirmModal);
            });
        }

        function setStealthMode(enabled) {
            appState.stealthMode = enabled;
            elements.stealthOverlay.classList.toggle("active", enabled);
            elements.stealthOverlay.setAttribute("aria-hidden", String(!enabled));
            if (enabled) {
                elements.stealthOverlay.focus();
            }
        }

        function setupStealthOverlay() {
            let lastTap = 0;
            elements.stealthOverlay.addEventListener("click", () => {
                const now = Date.now();
                if (now - lastTap < 350) {
                    setStealthMode(false);
                }
                lastTap = now;
            });
        }

        function updatePanelDockedState() {
            if (!elements.settingsModal) return;
            const wasDocked = panelDocked;
            panelDocked = window.matchMedia("(min-width: 1280px)").matches;
            document.body.classList.toggle("panel-docked", panelDocked);
            elements.settingsModal.setAttribute("aria-modal", panelDocked ? "false" : "true");
            if (panelDocked) {
                panelOpen = true;
                elements.settingsModal.classList.add("open");
                elements.settingsModal.setAttribute("aria-hidden", "false");
                if (elements.settingsBtn) {
                    elements.settingsBtn.setAttribute("aria-expanded", "true");
                }
                const index = modalStack.indexOf("settingsModal");
                if (index > -1) {
                    modalStack.splice(index, 1);
                    if (modalStack.length === 0) {
                        modalHistoryActive = false;
                        setAppInert(false);
                    }
                }
                return;
            }
            if (wasDocked && !panelDocked) {
                panelOpen = false;
                elements.settingsModal.classList.remove("open");
                elements.settingsModal.setAttribute("aria-hidden", "true");
                if (elements.settingsBtn) {
                    elements.settingsBtn.setAttribute("aria-expanded", "false");
                }
            }
        }

        function openQuickPanel() {
            if (!elements.settingsModal) return;
            updatePanelDockedState();
            panelOpen = true;
            if (elements.settingsBtn) {
                elements.settingsBtn.setAttribute("aria-expanded", "true");
            }
            if (panelDocked) {
                elements.settingsModal.classList.add("open");
                elements.settingsModal.setAttribute("aria-hidden", "false");
                return;
            }
            elements.settingsModal.setAttribute("aria-modal", "true");
            openModal(elements.settingsModal);
        }

        function closeQuickPanel(fromPopstate = false) {
            if (!elements.settingsModal) return;
            if (panelDocked) return;
            panelOpen = false;
            if (elements.settingsBtn) {
                elements.settingsBtn.setAttribute("aria-expanded", "false");
            }
            closeModal(elements.settingsModal, fromPopstate);
        }

        function toggleQuickPanel() {
            if (panelOpen && !panelDocked) {
                closeQuickPanel();
            } else {
                openQuickPanel();
            }
        }

        function setupPanelSwipe() {
            if (!elements.settingsModal) return;
            const panelContent = elements.settingsModal.querySelector(".modal-content");
            if (!panelContent) return;

            panelContent.addEventListener("touchstart", (event) => {
                if (!panelOpen || panelDocked) return;
                if (panelContent.scrollTop > 0) return;
                panelTouchStart = event.touches[0].clientY;
            }, { passive: true });

            panelContent.addEventListener("touchmove", (event) => {
                if (!panelTouchStart || panelDocked) return;
                const deltaY = event.touches[0].clientY - panelTouchStart;
                if (deltaY > 80) {
                    panelTouchStart = null;
                    closeQuickPanel();
                }
            }, { passive: true });

            panelContent.addEventListener("touchend", () => {
                panelTouchStart = null;
            }, { passive: true });

            panelContent.addEventListener("touchcancel", () => {
                panelTouchStart = null;
            }, { passive: true });
        }

        function extractJSON(text) {
            let start = -1;
            let depth = 0;
            let inString = false;
            let escape = false;
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                if (inString) {
                    if (escape) {
                        escape = false;
                    } else if (char === "\\") {
                        escape = true;
                    } else if (char === "\"") {
                        inString = false;
                    }
                    continue;
                }
                if (char === "\"") {
                    inString = true;
                    continue;
                }
                if (char === "{") {
                    if (depth === 0) start = i;
                    depth += 1;
                } else if (char === "}") {
                    depth -= 1;
                    if (depth === 0 && start !== -1) {
                        return text.slice(start, i + 1);
                    }
                }
            }
            throw new Error("No JSON found in response");
        }

        function ensureQuestion(text) {
            if (!text) return "Welche Option passt besser für Sie?";
            const trimmed = text.trim();
            if (trimmed.endsWith("?")) return trimmed;
            return `${trimmed}?`;
        }

        function normalizeQuickBlock(block) {
            return {
                entry: sanitizeString(block.entry, 400),
                anchor: sanitizeString(block.anchor, 400),
                question: ensureQuestion(sanitizeString(block.question, 400)),
                bridge: sanitizeString(block.bridge, 400),
                close: ensureQuestion(sanitizeString(block.close, 400))
            };
        }

        function deriveVariant(variant, neutral) {
            if (!neutral) return normalizeQuickBlock({});
            const intro = variant === "soft"
                ? "Verstehe ich gut. "
                : variant === "challenger"
                    ? "Lassen Sie uns das kurz neu einordnen. "
                    : "";
            return {
                entry: `${intro}${neutral.entry}`.trim(),
                anchor: variant === "challenger"
                    ? `Viele Kundinnen und Kunden unterschätzen den Nutzen. ${neutral.anchor}`.trim()
                    : neutral.anchor,
                question: neutral.question,
                bridge: variant === "soft"
                    ? `${neutral.bridge} Mir ist wichtig, dass Sie sich sicher fühlen.`.trim()
                    : neutral.bridge,
                close: neutral.close
            };
        }

        function needsTransparency(card) {
            const keywords = (card.keywords || []).join(" ");
            return keywords.includes("versicherung") || keywords.includes("abo") || card.meta.pattern === "subscription_aversion";
        }

        function ensureTransparency(card) {
            if (!needsTransparency(card)) return card;
            const transparencySentence = "Transparenz: Alle Kosten und Bedingungen sind offen, keine versteckten Gebühren.";
            ["neutral", "soft", "challenger"].forEach(variant => {
                const bridge = card.content.quick[variant].bridge || "";
                if (!bridge.includes("Transparenz")) {
                    card.content.quick[variant].bridge = `${bridge} ${transparencySentence}`.trim();
                }
            });
            card.meta.safety = "transparency_required";
            return card;
        }

        function ensureAttachAndNextStep(card) {
            const rule = PATTERN_RULES[card.meta.pattern] || PATTERN_RULES.trust;
            if (!card.content.attach) {
                card.content.attach = rule.attach;
            }
            if (!card.content.next_step) {
                card.content.next_step = rule.next_step;
            }
            return card;
        }

        function normalizeCaseCard(raw) {
            const quick = raw.content && raw.content.quick ? raw.content.quick : {};
            const neutral = quick.neutral ? normalizeQuickBlock(quick.neutral) : normalizeQuickBlock(quick);
            const soft = quick.soft ? normalizeQuickBlock(quick.soft) : deriveVariant("soft", neutral);
            const challenger = quick.challenger ? normalizeQuickBlock(quick.challenger) : deriveVariant("challenger", neutral);
            const smart = raw.content && raw.content.smart ? raw.content.smart : {};
            const coach = raw.content && raw.content.coach ? raw.content.coach : {};

            const normalized = {
                id: sanitizeString(raw.id || `case_${Date.now()}`, 80),
                objection: sanitizeString(raw.objection, 200),
                keywords: sanitizeArray(raw.keywords, 50),
                createdAt: typeof raw.createdAt === "number" ? raw.createdAt : Date.now(),
                meta: {
                    status: sanitizeEnum(raw.meta && raw.meta.status, ["success", "warning", "error", "check_datasheet", "fact_check_needed", "transparency_missing_details"], "success"),
                    pattern: sanitizeString(raw.meta && raw.meta.pattern, 40) || "trust",
                    safety: sanitizeEnum(raw.meta && raw.meta.safety, ["clean", "transparency_required", "fact_check_needed"], "clean")
                },
                ui: {
                    color: sanitizeEnum(raw.ui && raw.ui.color, ["success", "warning", "error"], "success"),
                    icon: sanitizeEnum(raw.ui && raw.ui.icon, ["shield", "clock", "tag", "info"], "info")
                },
                content: {
                    quick: { neutral, soft, challenger },
                    smart: {
                        text: sanitizeString(smart.text, 800),
                        closing: ensureQuestion(sanitizeString(smart.closing, 300))
                    },
                    coach: {
                        diagnosis: sanitizeString(coach.diagnosis, 300) || "Einwandtyp unklar.",
                        strategy: sanitizeString(coach.strategy, 300),
                        behavioral_fix: sanitizeString(coach.behavioral_fix, 300),
                        drill: sanitizeArray(coach.drill, 200)
                    },
                    attach: raw.content ? raw.content.attach : null,
                    next_step: raw.content ? raw.content.next_step : null
                }
            };

            ensureAttachAndNextStep(normalized);
            ensureTransparency(normalized);
            return normalized;
        }

        function normalizeProduct(item) {
            if (!item || typeof item !== "object") return null;
            return {
                id: sanitizeString(item.id || `product_${Date.now()}`, 80),
                name: sanitizeString(item.name, 120),
                brand: sanitizeString(item.brand, 80),
                category: sanitizeString(item.category, 80),
                tags: sanitizeArray(item.tags, 40),
                specs: item.specs && typeof item.specs === "object" ? item.specs : {},
                accessories: sanitizeArray(item.accessories, 120),
                warnings: sanitizeArray(item.warnings, 120),
                updatedAt: item.updatedAt || new Date().toISOString()
            };
        }

        function normalizeFaq(item) {
            if (!item || typeof item !== "object") return null;
            return {
                id: sanitizeString(item.id || `faq_${Date.now()}`, 80),
                productId: sanitizeString(item.productId, 80),
                question: sanitizeString(item.question, 200),
                answer: sanitizeString(item.answer, 400)
            };
        }

        function normalizeNote(item) {
            if (!item || typeof item !== "object") return null;
            return {
                id: sanitizeString(item.id || `note_${Date.now()}`, 80),
                productId: sanitizeString(item.productId, 80),
                note: sanitizeString(item.note, 400)
            };
        }

        function parseTags(value) {
            if (Array.isArray(value)) {
                return sanitizeArray(value, 40);
            }
            if (typeof value === "string") {
                return value
                    .split(/[,;\n]/)
                    .map(tag => tag.trim())
                    .filter(Boolean)
                    .slice(0, 40);
            }
            return [];
        }

        function normalizeWikiEntry(item) {
            if (!item || typeof item !== "object") return null;
            return {
                id: sanitizeString(item.id || `wiki_${Date.now()}`, 80),
                title: sanitizeString(item.title, 120),
                brand: sanitizeString(item.brand, 80),
                tags: parseTags(item.tags),
                category: sanitizeString(item.category, 80),
                sections: {
                    kurz: sanitizeString(item.sections && item.sections.kurz, 600),
                    specs: sanitizeString(item.sections && item.sections.specs, 800),
                    faq: sanitizeString(item.sections && item.sections.faq, 800)
                },
                updatedAt: item.updatedAt || new Date().toISOString()
            };
        }

        function normalizeLibraryItem(item) {
            if (!item || typeof item !== "object") return null;
            const votes = item.sellerVotes || {};
            return {
                id: sanitizeString(item.id || `lib_${Date.now()}`, 80),
                objectionKey: sanitizeString(item.objectionKey, 80),
                objectionText: sanitizeString(item.objectionText, 200),
                suggestedReply: sanitizeString(item.suggestedReply, 600),
                playbookRefs: sanitizeArray(item.playbookRefs, 120),
                sellerVotes: {
                    works: Number(votes.works) || 0,
                    fails: Number(votes.fails) || 0
                },
                lastUsedAt: typeof item.lastUsedAt === "number" ? item.lastUsedAt : 0,
                updatedAt: typeof item.updatedAt === "number" ? item.updatedAt : Date.now(),
                source: sanitizeEnum(item.source, ["seed", "learned"], "learned")
            };
        }

        function validateProxyUrl(value) {
            if (!value) return { ok: false };
            try {
                const url = new URL(value, window.location.origin);
                const isSameOrigin = url.origin === window.location.origin && window.location.origin !== "null";
                if (!isSameOrigin) return { ok: false, reason: "same_origin_required" };
                if (url.protocol !== "https:") return { ok: false, reason: "https_only" };
                if (["localhost", "127.0.0.1", "[::1]"].includes(url.hostname)) {
                    return { ok: false, reason: "localhost_blocked" };
                }
                return { ok: true, url: url.toString() };
            } catch {
                return { ok: false, reason: "invalid" };
            }
        }

        async function initDB() {
            return new Promise(resolve => {
                if (!("indexedDB" in window)) {
                    storage.mode = "local";
                    storage.ready = true;
                    resolve();
                    return;
                }
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onerror = () => {
                    storage.mode = "local";
                    storage.ready = true;
                    resolve();
                };
                request.onsuccess = () => {
                    storage.db = request.result;
                    storage.ready = true;
                    resolve();
                };
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains("settings")) db.createObjectStore("settings", { keyPath: "id" });
                    if (!db.objectStoreNames.contains("cases")) db.createObjectStore("cases", { keyPath: "id" });
                    if (!db.objectStoreNames.contains("logs")) db.createObjectStore("logs", { keyPath: "id", autoIncrement: true });
                    if (!db.objectStoreNames.contains("products")) db.createObjectStore("products", { keyPath: "id" });
                    if (!db.objectStoreNames.contains("productFaq")) db.createObjectStore("productFaq", { keyPath: "id" });
                    if (!db.objectStoreNames.contains("productNotes")) db.createObjectStore("productNotes", { keyPath: "id" });
                    if (!db.objectStoreNames.contains("comparisons")) db.createObjectStore("comparisons", { keyPath: "id" });
                    if (!db.objectStoreNames.contains("seller")) db.createObjectStore("seller", { keyPath: "id" });
                    if (!db.objectStoreNames.contains("wiki")) db.createObjectStore("wiki", { keyPath: "id" });
                    if (!db.objectStoreNames.contains("objection_library")) db.createObjectStore("objection_library", { keyPath: "id" });
                };
            });
        }

        function waitForDB() {
            return new Promise(resolve => {
                if (storage.ready) {
                    resolve();
                    return;
                }
                const interval = setInterval(() => {
                    if (storage.ready) {
                        clearInterval(interval);
                        resolve();
                    }
                }, 50);
            });
        }

        async function saveSettings(settings) {
            await waitForDB();
            if (storage.mode === "local") {
                localStorage.setItem("msos_settings", JSON.stringify(settings));
                return;
            }
            const tx = storage.db.transaction("settings", "readwrite");
            tx.objectStore("settings").put({ id: "main", ...settings });
            return new Promise(resolve => {
                tx.oncomplete = () => resolve();
            });
        }

        async function loadSettings() {
            await waitForDB();
            if (storage.mode === "local") {
                return safeParseJSON(localStorage.getItem("msos_settings"), null);
            }
            return new Promise(resolve => {
                const tx = storage.db.transaction("settings", "readonly");
                const req = tx.objectStore("settings").get("main");
                req.onsuccess = () => resolve(req.result || null);
                req.onerror = () => resolve(null);
            });
        }

        async function saveSellerState() {
            await waitForDB();
            const payload = {
                id: "main",
                history: appState.history,
                favorites: appState.favorites,
                training: appState.training
            };
            if (storage.mode === "local") {
                localStorage.setItem("msos_seller", JSON.stringify(payload));
                return;
            }
            const tx = storage.db.transaction("seller", "readwrite");
            tx.objectStore("seller").put(payload);
            return new Promise(resolve => {
                tx.oncomplete = () => resolve();
            });
        }

        async function loadSellerState() {
            await waitForDB();
            if (storage.mode === "local") {
                return safeParseJSON(localStorage.getItem("msos_seller"), null);
            }
            return new Promise(resolve => {
                const tx = storage.db.transaction("seller", "readonly");
                const req = tx.objectStore("seller").get("main");
                req.onsuccess = () => resolve(req.result || null);
                req.onerror = () => resolve(null);
            });
        }

        async function getAllFromStore(storeName, fallbackKey) {
            await waitForDB();
            if (storage.mode === "local") {
                return safeParseJSON(localStorage.getItem(fallbackKey), []);
            }
            return new Promise(resolve => {
                const tx = storage.db.transaction(storeName, "readonly");
                const req = tx.objectStore(storeName).getAll();
                req.onsuccess = () => resolve(req.result || []);
                req.onerror = () => resolve([]);
            });
        }

        async function saveAllToStore(storeName, fallbackKey, items) {
            await waitForDB();
            if (storage.mode === "local") {
                localStorage.setItem(fallbackKey, JSON.stringify(items));
                return;
            }
            const tx = storage.db.transaction(storeName, "readwrite");
            const store = tx.objectStore(storeName);
            items.forEach(item => store.put(item));
            return new Promise(resolve => {
                tx.oncomplete = () => resolve();
            });
        }

        async function logEvent(type, data) {
            await waitForDB();
            const log = {
                timestamp: new Date().toISOString(),
                type,
                objection: appState.objection,
                contexts: [...appState.contexts],
                data: data || {}
            };
            if (storage.mode === "local") {
                const logs = safeParseJSON(localStorage.getItem("msos_logs"), []);
                logs.push(log);
                localStorage.setItem("msos_logs", JSON.stringify(logs));
                return;
            }
            const tx = storage.db.transaction("logs", "readwrite");
            tx.objectStore("logs").add(log);
            return new Promise(resolve => {
                tx.oncomplete = () => resolve();
            });
        }

        async function getAllCases() {
            return getAllFromStore("cases", "msos_cases");
        }

        async function getAllLogs() {
            return getAllFromStore("logs", "msos_logs");
        }

        async function getAllProducts() {
            return getAllFromStore("products", "msos_products");
        }

        async function getAllFaq() {
            return getAllFromStore("productFaq", "msos_product_faq");
        }

        async function getAllNotes() {
            return getAllFromStore("productNotes", "msos_product_notes");
        }

        async function getAllComparisons() {
            return getAllFromStore("comparisons", "msos_comparisons");
        }

        async function getAllWikiEntries() {
            return getAllFromStore("wiki", "msos_wiki");
        }

        async function saveWikiEntry(entry) {
            await waitForDB();
            if (storage.mode === "local") {
                const items = safeParseJSON(localStorage.getItem("msos_wiki"), []);
                const index = items.findIndex(item => item.id === entry.id);
                if (index > -1) {
                    items[index] = entry;
                } else {
                    items.unshift(entry);
                }
                localStorage.setItem("msos_wiki", JSON.stringify(items));
                return;
            }
            const tx = storage.db.transaction("wiki", "readwrite");
            tx.objectStore("wiki").put(entry);
            return new Promise(resolve => {
                tx.oncomplete = () => resolve();
            });
        }

        async function deleteWikiEntry(id) {
            await waitForDB();
            if (storage.mode === "local") {
                const items = safeParseJSON(localStorage.getItem("msos_wiki"), []).filter(item => item.id !== id);
                localStorage.setItem("msos_wiki", JSON.stringify(items));
                return;
            }
            const tx = storage.db.transaction("wiki", "readwrite");
            tx.objectStore("wiki").delete(id);
            return new Promise(resolve => {
                tx.oncomplete = () => resolve();
            });
        }

        async function ensureWikiSeeds() {
            if (!DEFAULT_WIKI_SEEDS.length) return;
            const entries = await getAllWikiEntries();
            if (entries.length) return;
            const normalized = DEFAULT_WIKI_SEEDS.map(normalizeWikiEntry).filter(Boolean);
            await saveAllToStore("wiki", "msos_wiki", normalized);
        }

        async function resetWikiEntries() {
            await waitForDB();
            if (storage.mode === "local") {
                localStorage.removeItem("msos_wiki");
                if (DEFAULT_WIKI_SEEDS.length) {
                    const normalized = DEFAULT_WIKI_SEEDS.map(normalizeWikiEntry).filter(Boolean);
                    localStorage.setItem("msos_wiki", JSON.stringify(normalized));
                }
                return;
            }
            const tx = storage.db.transaction("wiki", "readwrite");
            const store = tx.objectStore("wiki");
            store.clear();
            if (DEFAULT_WIKI_SEEDS.length) {
                DEFAULT_WIKI_SEEDS.map(normalizeWikiEntry).filter(Boolean).forEach(item => store.put(item));
            }
            return new Promise(resolve => {
                tx.oncomplete = () => resolve();
            });
        }

        async function getAllLibraryItems() {
            return getAllFromStore("objection_library", "msos_objection_library");
        }

        async function saveLibraryItem(item) {
            await waitForDB();
            if (storage.mode === "local") {
                const items = safeParseJSON(localStorage.getItem("msos_objection_library"), []);
                const index = items.findIndex(entry => entry.id === item.id);
                if (index > -1) {
                    items[index] = item;
                } else {
                    items.unshift(item);
                }
                localStorage.setItem("msos_objection_library", JSON.stringify(items));
                return;
            }
            const tx = storage.db.transaction("objection_library", "readwrite");
            tx.objectStore("objection_library").put(item);
            return new Promise(resolve => {
                tx.oncomplete = () => resolve();
            });
        }

        async function ensureLibrarySeeds() {
            const items = await getAllLibraryItems();
            if (items.length) return;
            const normalized = DEFAULT_LIBRARY_SEEDS.map(normalizeLibraryItem).filter(Boolean);
            await saveAllToStore("objection_library", "msos_objection_library", normalized);
        }

        async function refreshLibraryItems() {
            await ensureLibrarySeeds();
            appState.library = (await getAllLibraryItems()).map(normalizeLibraryItem).filter(Boolean);
        }

        async function clearDataStores() {
            await waitForDB();
            if (storage.mode === "local") {
                ["msos_cases", "msos_logs", "msos_products", "msos_product_faq", "msos_product_notes", "msos_comparisons", "msos_seller", "msos_wiki", "msos_objection_library"].forEach(key => localStorage.removeItem(key));
                return;
            }
            const tx = storage.db.transaction(["cases", "logs", "products", "productFaq", "productNotes", "comparisons", "seller", "wiki", "objection_library"], "readwrite");
            tx.objectStore("cases").clear();
            tx.objectStore("logs").clear();
            tx.objectStore("products").clear();
            tx.objectStore("productFaq").clear();
            tx.objectStore("productNotes").clear();
            tx.objectStore("comparisons").clear();
            tx.objectStore("seller").clear();
            tx.objectStore("wiki").clear();
            tx.objectStore("objection_library").clear();
            return new Promise(resolve => {
                tx.oncomplete = () => resolve();
            });
        }

        async function updateStats() {
            const cases = await getAllCases();
            const logs = await getAllLogs();
            appState.stats.cases = cases.length;
            appState.stats.logs = logs.length;
            if (elements.statCases) {
                elements.statCases.textContent = String(appState.stats.cases);
            }
            if (elements.statLogs) {
                elements.statLogs.textContent = String(appState.stats.logs);
            }
        }

        function levenshteinDistance(a, b) {
            const matrix = Array.from({ length: b.length + 1 }, () => []);
            for (let i = 0; i <= b.length; i++) matrix[i][0] = i;
            for (let j = 0; j <= a.length; j++) matrix[0][j] = j;
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    if (b.charAt(i - 1) === a.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            return matrix[b.length][a.length];
        }

        async function saveCaseToLibrary(card) {
            await waitForDB();
            const baseKeywords = appState.objection.toLowerCase().split(" ").filter(word => word.length > 3);
            const synonymMap = {
                teuer: ["preis", "kostet", "hoch", "viel", "expensive"],
                versicherung: ["garantie", "schutz", "absicherung", "abo"],
                überlegen: ["bedenkzeit", "später", "nachdenken", "warten"],
                rabatt: ["nachlass", "discount", "günstiger", "reduzierung"],
                vergleichen: ["andere", "konkurrenz", "woanders"],
                qualität: ["hochwertig", "premium", "gut"],
                lieferung: ["versand", "transport", "zustellung"],
                garantie: ["gewährleistung", "rückgabe", "umtausch"]
            };

            const enhancedKeywords = [...new Set([
                ...baseKeywords,
                ...baseKeywords.flatMap(keyword => synonymMap[keyword] || [])
            ])];

            const item = {
                ...card,
                id: card.id || `case_${Date.now()}`,
                objection: appState.objection,
                keywords: enhancedKeywords,
                createdAt: card.createdAt || Date.now()
            };

            if (storage.mode === "local") {
                const data = safeParseJSON(localStorage.getItem("msos_cases"), []);
                data.push(item);
                localStorage.setItem("msos_cases", JSON.stringify(data));
                return;
            }
            const tx = storage.db.transaction("cases", "readwrite");
            tx.objectStore("cases").put(item);
            return new Promise(resolve => {
                tx.oncomplete = () => resolve();
            });
        }

        async function searchLocalCases(query) {
            const queryLower = query.toLowerCase();
            const queryWords = queryLower.split(" ").filter(word => word.length > 3);
            const results = await getAllCases();
            return results.find(item => {
                const keywords = Array.isArray(item.keywords) ? item.keywords : [];
                return keywords.some(keyword => {
                    return queryWords.some(qw => {
                        if (qw.includes(keyword.toLowerCase()) || keyword.toLowerCase().includes(qw)) {
                            return true;
                        }
                        const distance = levenshteinDistance(qw, keyword.toLowerCase());
                        return distance <= 2;
                    });
                });
            }) || null;
        }

        function searchSeeds(query) {
            const queryLower = query.toLowerCase();
            const queryWords = queryLower.split(" ").filter(word => word.length > 3);
            return SEED_CASES.find(seed => {
                return seed.keywords.some(keyword => {
                    return queryWords.some(qw => {
                        if (qw.includes(keyword.toLowerCase()) || keyword.toLowerCase().includes(qw)) {
                            return true;
                        }
                        const distance = levenshteinDistance(qw, keyword.toLowerCase());
                        return distance <= 2;
                    });
                });
            });
        }

        async function callAI(objection, contexts) {
            const { apiProvider, apiKey, modelName, proxyUrl, department, storePolicy } = appState.settings;
            if (!apiKey && !proxyUrl) throw new Error("API Key oder Proxy URL erforderlich");
            if (appState.settings.apiKeyLocked) throw new Error("API Key gesperrt");
            if (!navigator.onLine) throw new Error("Offline");

            const contextMods = [];
            if (contexts.includes("hurry")) contextMods.push("- Kunde ist eilig: Ultra-kurze Antworten, max 2 Sätze pro Abschnitt");
            if (contexts.includes("duo")) contextMods.push("- Kunde ist Paar/Gruppe: Inkludiere beide Personen ('Sie beide', 'für Sie gemeinsam')");
            if (contexts.includes("easy")) contextMods.push("- Kunde will es einfach: Keine Technik-Details, nur Nutzen.");
            if (contexts.includes("techie")) contextMods.push("- Kunde ist technikaffin: Specs nur wenn sicher, sonst auf Datenblatt verweisen.");

            const systemPrompt = `ROLE: Retail Sales Expert (Austria). Abteilung: ${department}
OUTPUT: STRICT JSON ONLY. NO preamble, NO markdown, NO text before or after JSON.
EXPERT MATRIX: VOSS, Challenger, Kahneman, Cialdini, SPIN, Sandler.
GUARDRAILS:
- Social Proof ohne Zahlen.
- Keine Scarcity ohne Store-Policy-Datum. Store Policy: "${storePolicy || "keine Aktionen definiert"}"
- Versicherung/Abo: Transparenzsatz zwingend.
- Keine erfundenen Fakten. Wenn Details fehlen: status="transparency_missing_details".

KONTEXT:
${contextMods.join("\n")}

OUTPUT SCHEMA:
{
  "id":"str",
  "meta":{"status":"success|warning|error|check_datasheet|transparency_missing_details","pattern":"price|trust|risk|comparison|uncertainty|control|subscription_aversion","safety":"clean|transparency_required|fact_check_needed"},
  "ui":{"color":"success|warning|error","icon":"tag|shield|clock|info"},
  "content":{
    "quick":{
      "neutral":{"entry":"str","anchor":"str","question":"str","bridge":"str","close":"str"},
      "soft":{"entry":"str","anchor":"str","question":"str","bridge":"str","close":"str"},
      "challenger":{"entry":"str","anchor":"str","question":"str","bridge":"str","close":"str"}
    },
    "smart":{"text":"str","closing":"str"},
    "coach":{"diagnosis":"str (1 Satz)","strategy":"str","behavioral_fix":"str","drill":["str","str"]},
    "attach":{"suggestion":"str","why":"str","how_to_offer":"str"},
    "next_step":{"cta":"str","two_options":["str","str"]}
  },
  "keywords":["str"],
  "createdAt": 0
}`;

            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 15000);
            let apiUrl;
            let headers;
            let body;

            if (proxyUrl) {
                const validated = validateProxyUrl(proxyUrl);
                if (!validated.ok) throw new Error("Proxy URL nicht erlaubt");
                apiUrl = validated.url;
                headers = { "Content-Type": "application/json" };
                body = JSON.stringify({ provider: apiProvider, prompt: systemPrompt, objection });
            } else if (apiProvider === "openai") {
                apiUrl = "https://api.openai.com/v1/chat/completions";
                headers = {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${apiKey}`
                };
                body = JSON.stringify({
                    model: modelName || MODEL_DEFAULTS.openai,
                    messages: [
                        { role: "system", content: systemPrompt },
                        { role: "user", content: objection }
                    ],
                    temperature: 0.7
                });
            } else if (apiProvider === "groq") {
                apiUrl = "https://api.groq.com/openai/v1/chat/completions";
                headers = {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${apiKey}`
                };
                body = JSON.stringify({
                    model: modelName || MODEL_DEFAULTS.groq,
                    messages: [
                        { role: "system", content: systemPrompt },
                        { role: "user", content: objection }
                    ],
                    temperature: 0.7
                });
            } else {
                throw new Error("Unbekannter Provider");
            }

            const response = await fetch(apiUrl, {
                method: "POST",
                headers,
                body,
                signal: controller.signal,
                referrerPolicy: "no-referrer",
                credentials: "omit"
            });
            clearTimeout(timeout);
            if (!response.ok) throw new Error(`API Error: ${response.status}`);
            const data = await response.json();
            const rawContent = data.choices?.[0]?.message?.content || "";
            const content = extractJSON(rawContent);
            const parsed = JSON.parse(content);
            parsed.id = `ai_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
            parsed.createdAt = Date.now();
            return normalizeCaseCard(parsed);
        }

        async function callAIProduct(question, product) {
            const { apiProvider, apiKey, modelName, proxyUrl } = appState.settings;
            if (!apiKey && !proxyUrl) throw new Error("API Key oder Proxy URL erforderlich");
            if (appState.settings.apiKeyLocked) throw new Error("API Key gesperrt");
            if (!navigator.onLine) throw new Error("Offline");

            const productContext = product
                ? `Produkt: ${product.name} (${product.brand})\\nKategorie: ${product.category}\\nSichere Daten: ${JSON.stringify(product.specs)}`
                : "Kein Produkt gefunden.";

            const systemPrompt = `ROLE: Product Knowledge Assistant.
RULES:
- Keine Spezifikationen erfinden.
- Wenn keine sicheren Daten: status="fact_check_needed".
- Antworte kurz, klar, ohne Marketing.

OUTPUT JSON ONLY:
{
  "type":"product_answer",
  "productId":"str|null",
  "confidence":"high|medium|low",
  "source":"wiki|mixed|ai_only",
  "status":"success|check_datasheet|fact_check_needed",
  "answer":"str",
  "citations":[{"field":"str","value":"str","origin":"spec|faq|note"}],
  "nextAction":"str"
}`;

            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 12000);
            let apiUrl;
            let headers;
            let body;

            if (proxyUrl) {
                const validated = validateProxyUrl(proxyUrl);
                if (!validated.ok) throw new Error("Proxy URL nicht erlaubt");
                apiUrl = validated.url;
                headers = { "Content-Type": "application/json" };
                body = JSON.stringify({ provider: apiProvider, prompt: systemPrompt, question, context: productContext });
            } else if (apiProvider === "openai") {
                apiUrl = "https://api.openai.com/v1/chat/completions";
                headers = {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${apiKey}`
                };
                body = JSON.stringify({
                    model: modelName || MODEL_DEFAULTS.openai,
                    messages: [
                        { role: "system", content: systemPrompt },
                        { role: "user", content: `FRAGE: ${question}\\n${productContext}` }
                    ],
                    temperature: 0.4
                });
            } else if (apiProvider === "groq") {
                apiUrl = "https://api.groq.com/openai/v1/chat/completions";
                headers = {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${apiKey}`
                };
                body = JSON.stringify({
                    model: modelName || MODEL_DEFAULTS.groq,
                    messages: [
                        { role: "system", content: systemPrompt },
                        { role: "user", content: `FRAGE: ${question}\\n${productContext}` }
                    ],
                    temperature: 0.4
                });
            } else {
                throw new Error("Unbekannter Provider");
            }

            const response = await fetch(apiUrl, {
                method: "POST",
                headers,
                body,
                signal: controller.signal,
                referrerPolicy: "no-referrer",
                credentials: "omit"
            });
            clearTimeout(timeout);
            if (!response.ok) throw new Error("API Error");
            const data = await response.json();
            const rawContent = data.choices?.[0]?.message?.content || "";
            const content = extractJSON(rawContent);
            const parsed = JSON.parse(content);
            return normalizeProductAnswer(parsed, product);
        }

        function normalizeProductAnswer(answer, product) {
            const normalized = {
                type: "product_answer",
                productId: answer.productId || (product ? product.id : null),
                confidence: sanitizeEnum(answer.confidence, ["high", "medium", "low"], "low"),
                source: sanitizeEnum(answer.source, ["wiki", "mixed", "ai_only"], "ai_only"),
                status: sanitizeEnum(answer.status, ["success", "check_datasheet", "fact_check_needed"], "fact_check_needed"),
                answer: sanitizeString(answer.answer, 600),
                citations: Array.isArray(answer.citations) ? answer.citations.map(c => ({
                    field: sanitizeString(c.field, 80),
                    value: sanitizeString(c.value, 200),
                    origin: sanitizeEnum(c.origin, ["spec", "faq", "note"], "note")
                })) : [],
                nextAction: sanitizeString(answer.nextAction, 200) || "Bitte Datenblatt prüfen."
            };

            if (normalized.source === "ai_only") {
                normalized.status = "fact_check_needed";
                if (!normalized.answer.includes("nicht sicher")) {
                    normalized.answer = `Nicht sicher: ${normalized.answer}`;
                }
            }
            return normalized;
        }

        async function answerProductQuestion(question) {
            const trimmed = sanitizeString(question, 300);
            if (!trimmed) return null;
            const product = appState.wiki.products.find(item => item.id === appState.wiki.selectedProductId);
            const citations = [];
            if (product) {
                Object.entries(product.specs || {}).forEach(([field, value]) => {
                    const val = String(value);
                    if (trimmed.toLowerCase().includes(field.toLowerCase())) {
                        citations.push({ field, value: val, origin: "spec" });
                    }
                });
                appState.wiki.faq.filter(faq => faq.productId === product.id).forEach(faq => {
                    if (trimmed.toLowerCase().includes(faq.question.toLowerCase())) {
                        citations.push({ field: faq.question, value: faq.answer, origin: "faq" });
                    }
                });
                appState.wiki.notes.filter(note => note.productId === product.id).forEach(note => {
                    if (trimmed.toLowerCase().includes(note.note.toLowerCase())) {
                        citations.push({ field: "Hinweis", value: note.note, origin: "note" });
                    }
                });
            }
            if (citations.length > 0) {
                const answerText = citations.map(item => `${item.field}: ${item.value}`).join(" | ");
                return {
                    type: "product_answer",
                    productId: product ? product.id : null,
                    confidence: "high",
                    source: "wiki",
                    status: "success",
                    answer: answerText,
                    citations,
                    nextAction: "Bei Bedarf Datenblatt öffnen."
                };
            }
            if (product) {
                return {
                    type: "product_answer",
                    productId: product.id,
                    confidence: "medium",
                    source: "wiki",
                    status: "check_datasheet",
                    answer: "Keine gesicherten Wiki-Daten zu dieser Frage. Bitte Datenblatt prüfen.",
                    citations: [],
                    nextAction: "Datenblatt öffnen oder Produktseite prüfen."
                };
            }
            return {
                type: "product_answer",
                productId: null,
                confidence: "low",
                source: "ai_only",
                status: "fact_check_needed",
                answer: "Kein Produkt gefunden. Bitte Produktseite prüfen.",
                citations: [],
                nextAction: "Produktseite oder Datenblatt prüfen."
            };
        }

        async function handleTechnicalQuestion(question) {
            appState.wiki.searchQuery = question;
            if (elements.wikiSearchInput) {
                elements.wikiSearchInput.value = question;
            }
            renderWikiFrame();
            setFrame("wiki");
            let answer = await answerProductQuestion(question);
            if (answer && answer.status !== "success") {
                try {
                    const product = appState.wiki.products.find(item => item.id === appState.wiki.selectedProductId);
                    answer = await callAIProduct(question, product);
                } catch {
                    // keep wiki-only answer
                }
            }
            appState.wiki.answer = answer;
            renderWikiAnswer();
        }

        async function handleObjectionSubmit() {
            const objection = sanitizeString(elements.objectionInput.value, 200);
            appState.objection = objection;
            if (!objection) {
                showToast("Bitte Einwand eingeben");
                return;
            }
            appState.loading = true;
            setInputBusy(true);
            render();

            try {
                if (appState.ui.techQuestion) {
                    await handleTechnicalQuestion(objection);
                    return;
                }
                let card = null;
                if (!navigator.onLine || (!appState.settings.apiKey && !appState.settings.proxyUrl)) {
                    const localMatch = await searchLocalCases(objection);
                    card = localMatch ? normalizeCaseCard(localMatch) : null;
                    if (!card) {
                        const seedMatch = searchSeeds(objection);
                        card = seedMatch ? normalizeCaseCard(seedMatch) : null;
                    }
                } else {
                    const seedMatch = searchSeeds(objection);
                    if (seedMatch) {
                        card = normalizeCaseCard(seedMatch);
                    } else {
                        const localMatch = await searchLocalCases(objection);
                        if (localMatch) {
                            card = normalizeCaseCard(localMatch);
                        } else {
                            card = await callAI(objection, appState.contexts);
                            await saveCaseToLibrary(card);
                            await logEvent("api_call", { provider: appState.settings.apiProvider });
                        }
                    }
                }

                if (!card) {
                    card = normalizeCaseCard(JOKER_CARD);
                }

                setActiveCard(card);
                haptic([35]);
                await logEvent("case_resolved", { cardId: card.id, pattern: card.meta.pattern });
            } catch (error) {
                const fallback = normalizeCaseCard(JOKER_CARD);
                setActiveCard(fallback);
                haptic([80]);
                await logEvent("error_fallback", { error: error.message });
                showToast("Fallback geladen");
            } finally {
                appState.loading = false;
                setInputBusy(false);
                render();
            }
        }

        function setInputBusy(isBusy) {
            elements.micBtn.classList.toggle("processing", isBusy);
            elements.objectionInput.disabled = isBusy;
            elements.submitBtn.disabled = isBusy;
            elements.micBtn.disabled = isBusy || !recognition;
        }

        function setActiveCard(card, options = {}) {
            appState.cards = [card];
            appState.training.variant = appState.training.variant || "neutral";
            if (options.addToHistory !== false) {
                addHistoryEntry(card);
            }
        }

        function addHistoryEntry(card) {
            const entry = {
                id: `hist_${Date.now()}`,
                objection: appState.objection || card.objection,
                cardId: card.id,
                pattern: card.meta.pattern,
                timestamp: new Date().toISOString(),
                result: "",
                card
            };
            appState.history.unshift(entry);
            appState.history = appState.history.slice(0, MAX_HISTORY);
            saveSellerState();
        }

        function updateHistoryResult(cardId, result) {
            const entry = appState.history.find(item => item.cardId === cardId);
            if (entry) {
                entry.result = result;
            }
            saveSellerState();
        }

        function trackPlaybookRef(text) {
            if (!text) return;
            const existing = appState.playbookRefs.filter(item => item !== text);
            appState.playbookRefs = [text, ...existing].slice(0, 12);
        }

        async function recordLibraryVote(card, voteType) {
            await refreshLibraryItems();
            const now = Date.now();
            const id = sanitizeString(card.id || `lib_${now}`, 80);
            let item = appState.library.find(entry => entry.id === id);
            if (!item) {
                const quick = card.content.quick.neutral;
                item = normalizeLibraryItem({
                    id,
                    objectionKey: card.meta.pattern,
                    objectionText: card.objection || appState.objection,
                    suggestedReply: [quick.entry, quick.anchor, quick.question, quick.bridge, quick.close].join(" "),
                    playbookRefs: [...appState.playbookRefs],
                    sellerVotes: { works: 0, fails: 0 },
                    lastUsedAt: now,
                    updatedAt: now,
                    source: "learned"
                });
                appState.library.unshift(item);
            }
            if (voteType === "works") {
                item.sellerVotes.works += 1;
            } else {
                item.sellerVotes.fails += 1;
            }
            item.lastUsedAt = now;
            item.updatedAt = now;
            item.playbookRefs = Array.from(new Set([...(item.playbookRefs || []), ...appState.playbookRefs]));
            await saveLibraryItem(item);
        }

        function toggleFavorite(cardId) {
            const index = appState.favorites.indexOf(cardId);
            if (index > -1) {
                appState.favorites.splice(index, 1);
            } else {
                appState.favorites.unshift(cardId);
            }
            saveSellerState();
            renderSalesHistory();
        }

        function resetApp() {
            appState.objection = "";
            appState.contexts = [];
            appState.cards = [];
            appState.playbookRefs = [];
            appState.ui.techQuestion = false;
            elements.objectionInput.value = "";
            elements.contextChips.querySelectorAll(".chip").forEach(chip => {
                chip.setAttribute("aria-pressed", "false");
            });
            if (elements.techQuestionToggle) {
                elements.techQuestionToggle.setAttribute("aria-pressed", "false");
            }
            updateContextStatus();
            render();
        }

        function getActiveCard() {
            return appState.cards.length ? appState.cards[0] : null;
        }

        function buildQuickBlock(label, text, cardId, field, variant = "neutral") {
            return `
                <div class="cue-block">
                    <div class="cue-header">
                        <div class="cue-label">${label}</div>
                        <button class="copy-btn" type="button" data-card="${cardId}" data-copy="${field}" data-variant="${variant}">Copy</button>
                    </div>
                    <div class="cue-text">${escapeHTML(text)}</div>
                </div>
            `;
        }

        function renderSalesCard(card) {
            if (!card) {
                return `
                    <section class="tile empty-state">
                        <div class="empty-title">Bereit für Kunden</div>
                        <div class="empty-subtitle">Geben Sie einen Kundeneinwand ein, um sofort eine Antwort zu erhalten.</div>
                    </section>
                `;
            }
            const quick = card.content.quick.neutral;
            const isFavorite = appState.favorites.includes(card.id);
            const attach = card.content.attach;
            const nextStep = card.content.next_step;
            const transparency = card.meta.safety === "transparency_required" ? "Transparenz Pflicht: Konditionen offen nennen." : "";
            const safeId = card.id.replace(/[^a-zA-Z0-9_-]/g, "");

            return `
                <section class="tile card ${card.ui.color}">
                    <div class="card-header">
                        <svg class="card-icon" viewBox="0 0 24 24">${getIcon(card.ui.icon)}</svg>
                        <div class="card-title">Sales Frame</div>
                        <div class="card-header-actions">
                            <button class="favorite-btn" type="button" data-favorite="${card.id}" aria-pressed="${isFavorite}">
                                <svg viewBox="0 0 24 24"><path d="M12 17.3l-6.2 3.7 1.6-7-5.4-4.7 7.1-.6L12 2l2.9 6.7 7.1.6-5.4 4.7 1.6 7z"/></svg>
                            </button>
                        </div>
                        <div class="card-badge">${escapeHTML(card.meta.pattern)}</div>
                    </div>

                    <div class="quick-cues">
                        ${buildQuickBlock("Einstieg", quick.entry, card.id, "entry", "neutral")}
                        ${buildQuickBlock("Anker", quick.anchor, card.id, "anchor", "neutral")}
                        ${buildQuickBlock("Frage", quick.question, card.id, "question", "neutral")}
                        ${buildQuickBlock("Bridge", quick.bridge, card.id, "bridge", "neutral")}
                        ${buildQuickBlock("Close", quick.close, card.id, "close", "neutral")}
                        <button class="copy-btn" type="button" data-card="${card.id}" data-copy="full" data-variant="neutral">Copy Full Quick</button>
                    </div>

                    <div class="expandable">
                        <button class="expand-trigger" type="button" aria-expanded="false" aria-controls="smart-${safeId}" data-target="smart-${safeId}">
                            Smart Script
                            <svg class="expand-icon" viewBox="0 0 24 24"><path d="M6 9l6 6 6-6"/></svg>
                        </button>
                        <div class="expand-content" id="smart-${safeId}" hidden>
                            <div class="cue-text spacing">${escapeHTML(card.content.smart.text)}</div>
                            <div class="cue-label">Abschlussfrage</div>
                            <div class="cue-text">${escapeHTML(card.content.smart.closing)}</div>
                        </div>
                    </div>

                    <div class="expandable">
                        <button class="expand-trigger" type="button" aria-expanded="false" aria-controls="coach-${safeId}" data-target="coach-${safeId}">
                            Coach Mode
                            <svg class="expand-icon" viewBox="0 0 24 24"><path d="M6 9l6 6 6-6"/></svg>
                        </button>
                        <div class="expand-content" id="coach-${safeId}" hidden>
                            <div class="coach-block">
                                <div class="coach-label">Diagnose</div>
                                <div class="coach-text">${escapeHTML(card.content.coach.diagnosis)}</div>
                            </div>
                            <div class="coach-block">
                                <div class="coach-label">Strategie</div>
                                <div class="coach-text">${escapeHTML(card.content.coach.strategy)}</div>
                            </div>
                            <div class="coach-block">
                                <div class="coach-label">Verhaltensfix</div>
                                <div class="coach-text">${escapeHTML(card.content.coach.behavioral_fix)}</div>
                            </div>
                            <div class="coach-block">
                                <div class="coach-label">Übungen</div>
                                <ul class="drill-list">
                                    ${card.content.coach.drill.map(item => `<li>${escapeHTML(item)}</li>`).join("")}
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div class="expandable">
                        <div class="expand-label">Attach Vorschlag</div>
                        <div class="cue-text">${escapeHTML(attach.suggestion)}</div>
                        <div class="cue-text">${escapeHTML(attach.why)}</div>
                        <div class="cue-text">${escapeHTML(attach.how_to_offer)}</div>
                        ${transparency ? `<div class="cue-text">${escapeHTML(transparency)}</div>` : ""}
                    </div>

                    <div class="expandable">
                        <div class="expand-label">Next Step</div>
                        <div class="cue-text">${escapeHTML(nextStep.cta)}</div>
                        <div class="pill-row">
                            ${nextStep.two_options.map(option => `<span class="pill">${escapeHTML(option)}</span>`).join("")}
                        </div>
                    </div>

                    <div class="card-actions">
                        <button class="feedback-btn success" type="button" data-feedback="success" data-card="${card.id}">
                            <svg viewBox="0 0 24 24"><path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"/></svg>
                            Erfolgreich
                        </button>
                        <button class="feedback-btn error" type="button" data-feedback="fail" data-card="${card.id}">
                            <svg viewBox="0 0 24 24"><path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17"/></svg>
                            Nicht hilfreich
                        </button>
                        <button class="feedback-btn" type="button" data-train="${card.id}">Train this</button>
                        <button class="feedback-btn success" type="button" data-library-vote="works" data-card="${card.id}">
                            Funktioniert
                        </button>
                        <button class="feedback-btn error" type="button" data-library-vote="fails" data-card="${card.id}">
                            Funktioniert nicht
                        </button>
                    </div>
                </section>
            `;
        }

        function renderSalesFrame() {
            if (appState.loading) {
                elements.salesCardContainer.innerHTML = `
                    <section class="tile loading-state" aria-busy="true">
                        <div class="skeleton-line wide"></div>
                        <div class="skeleton-line"></div>
                        <div class="skeleton-line"></div>
                        <div class="skeleton-line"></div>
                    </section>
                `;
                return;
            }
            elements.salesCardContainer.innerHTML = renderSalesCard(getActiveCard());
            renderSalesHistory();
        }

        function renderSalesHistory() {
            if (!elements.historyList) return;
            const historyItems = appState.history.map(item => {
                return `
                    <button class="history-item" type="button" data-history="${item.id}">
                        <div>${escapeHTML(item.objection || "Einwand")}</div>
                        <div class="history-meta">${escapeHTML(item.pattern || "pattern")}</div>
                    </button>
                `;
            }).join("");
            elements.historyList.innerHTML = historyItems || `<div class="tile-desc">Noch kein Verlauf.</div>`;

            const favorites = appState.favorites.map(id => {
                const entry = appState.history.find(item => item.cardId === id);
                const title = entry ? entry.objection : id;
                return `
                    <button class="history-item" type="button" data-favorite-item="${id}">
                        <div>${escapeHTML(title)}</div>
                        <div class="history-meta">Favorit</div>
                    </button>
                `;
            }).join("");
            elements.favoriteList.innerHTML = favorites || `<div class="tile-desc">Keine Favoriten.</div>`;
        }

        function renderTrainingFrame() {
            const card = getActiveCard();
            if (!card) {
                elements.trainingCardTitle.textContent = "Kein Einwand aktiv";
                elements.trainingCardContainer.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-title">Training bereit</div>
                        <div class="empty-subtitle">Wähle eine Karte aus dem Verkauf.</div>
                    </div>
                `;
                elements.roleplayPrompt.textContent = "Roleplay bereit. Wähle zuerst eine Karte.";
                elements.roleplayResponse.textContent = "";
            } else {
                elements.trainingCardTitle.textContent = `Pattern: ${card.meta.pattern}`;
                const variant = appState.training.variant || "neutral";
                updateVariantButtons(variant);
                const quick = card.content.quick[variant];
                elements.trainingCardContainer.innerHTML = `
                    <div class="quick-cues">
                        <div class="cue-block">
                            <div class="cue-label">Diagnose</div>
                            <div class="cue-text">${escapeHTML(card.content.coach.diagnosis)}</div>
                        </div>
                        ${buildQuickBlock("Einstieg", quick.entry, card.id, "entry", variant)}
                        ${buildQuickBlock("Anker", quick.anchor, card.id, "anchor", variant)}
                        ${buildQuickBlock("Frage", quick.question, card.id, "question", variant)}
                        ${buildQuickBlock("Bridge", quick.bridge, card.id, "bridge", variant)}
                        ${buildQuickBlock("Close", quick.close, card.id, "close", variant)}
                    </div>
                `;
            }
            renderDrill(card);
            renderTrainingStats();
            renderPatternLibrary();
        }

        function updateVariantButtons(active) {
            elements.variantSoftBtn.setAttribute("aria-pressed", String(active === "soft"));
            elements.variantNeutralBtn.setAttribute("aria-pressed", String(active === "neutral"));
            elements.variantChallengerBtn.setAttribute("aria-pressed", String(active === "challenger"));
        }

        function buildTrainingDrills(card) {
            const drills = [];
            const baseDrills = card && card.content && card.content.coach ? card.content.coach.drill || [] : [];
            if (baseDrills.length) {
                drills.push(...baseDrills);
            }
            drills.push(
                "Drill Bedarf: Stelle drei Bedarf-Fragen aus dem Leitfaden.",
                "Drill Nutzen: Formuliere eine Nutzenfrage und einen Nutzenanker.",
                "Drill Abschluss: Wähle zwei Abschlussfragen aus dem Leitfaden."
            );
            const pool = [
                ...appState.cards.map(item => item.objection).filter(Boolean),
                ...appState.history.slice(0, 200).map(item => item.objection).filter(Boolean),
                ...SEED_CASES.map(item => item.objection).filter(Boolean)
            ];
            const unique = Array.from(new Set(pool)).slice(0, 2);
            unique.forEach(text => {
                drills.push(`Drill: Reagiere auf "${text}" mit Einstieg, Anker, Frage, Bridge, Close.`);
            });
            return drills;
        }

        function renderDrill(card) {
            const drills = buildTrainingDrills(card);
            if (!drills.length) {
                elements.drillText.textContent = "Kein Drill vorhanden.";
                return;
            }
            const index = appState.training.drillIndex % drills.length;
            elements.drillText.textContent = drills[index];
        }

        function renderTrainingStats() {
            const lastTen = appState.history.slice(0, 10);
            const successCount = appState.history.filter(item => item.result === "success").length;
            const totalFeedback = appState.history.filter(item => item.result).length;
            const successRate = totalFeedback ? Math.round((successCount / totalFeedback) * 100) : 0;
            const patternCounts = {};
            lastTen.forEach(item => {
                patternCounts[item.pattern] = (patternCounts[item.pattern] || 0) + 1;
            });
            const topPatterns = Object.entries(patternCounts).sort((a, b) => b[1] - a[1]).slice(0, 2);
            const patternText = topPatterns.map(([pattern, count]) => `${pattern} (${count})`).join(", ") || "–";
            const patternScores = {};
            appState.history.filter(item => item.result).forEach(item => {
                if (!patternScores[item.pattern]) {
                    patternScores[item.pattern] = { total: 0, success: 0 };
                }
                patternScores[item.pattern].total += 1;
                if (item.result === "success") {
                    patternScores[item.pattern].success += 1;
                }
            });
            const weaknessList = Object.entries(patternScores)
                .map(([pattern, stat]) => ({ pattern, rate: stat.total ? stat.success / stat.total : 1 }))
                .sort((a, b) => a.rate - b.rate)
                .slice(0, 3);

            elements.trainingStats.innerHTML = `
                <div class="stat">
                    <div class="stat-label">Last 10</div>
                    <div class="stat-value">${lastTen.length}</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Success</div>
                    <div class="stat-value">${successRate}%</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Top Pattern</div>
                    <div class="stat-value">${escapeHTML(patternText)}</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Sessions</div>
                    <div class="stat-value">${appState.training.sessions}</div>
                </div>
            `;

            if (elements.trainingWeaknessList) {
                elements.trainingWeaknessList.innerHTML = weaknessList.map(item => `
                    <div class="pattern-item">
                        <div>${escapeHTML(item.pattern)}</div>
                        <div class="pattern-meta">${Math.round(item.rate * 100)}% Erfolg</div>
                    </div>
                `).join("") || `<div class="tile-desc">Noch keine Schwächen.</div>`;
            }

            elements.trainingHistoryList.innerHTML = lastTen.map(item => `
                <div class="history-item">
                    <div>${escapeHTML(item.objection)}</div>
                    <div class="history-meta">${escapeHTML(item.pattern)} ${item.result ? `• ${item.result}` : ""}</div>
                </div>
            `).join("") || `<div class="tile-desc">Keine Einträge.</div>`;
        }

        function renderPatternLibrary() {
            const patterns = Object.keys(PATTERN_RULES);
            if (!elements.patternFilter.options.length) {
                const options = ["all", ...patterns];
                elements.patternFilter.innerHTML = options.map(pattern => `<option value="${pattern}">${pattern}</option>`).join("");
            }
            const selected = appState.training.selectedPattern;
            elements.patternFilter.value = selected;
            const cards = [ ...SEED_CASES, ...appState.cards ].map(normalizeCaseCard);
            const filtered = selected === "all" ? cards : cards.filter(card => card.meta.pattern === selected);
            elements.patternList.innerHTML = filtered.map(card => `
                <div class="pattern-item">
                    <div>${escapeHTML(card.objection || card.meta.pattern)}</div>
                    <div class="pattern-meta">${escapeHTML(card.meta.pattern)}</div>
                </div>
            `).join("") || `<div class="tile-desc">Keine Patterns.</div>`;
            const rule = PATTERN_RULES[selected] || PATTERN_RULES.trust;
            elements.microlearningBox.textContent = `Regel: ${rule.microlearning.rule} | Do: ${rule.microlearning.do} | Don't: ${rule.microlearning.dont}`;
        }

        function renderWikiFrame() {
            const query = appState.wiki.searchQuery.toLowerCase();
            const products = appState.wiki.products.filter(item => {
                const matchesQuery = !query || item.name.toLowerCase().includes(query) || item.brand.toLowerCase().includes(query);
                const filterCategory = appState.wiki.filters.category === "all" || item.category === appState.wiki.filters.category;
                const filterBrand = appState.wiki.filters.brand === "all" || item.brand === appState.wiki.filters.brand;
                const filterFeature = appState.wiki.filters.feature === "all" || item.tags.includes(appState.wiki.filters.feature);
                return matchesQuery && filterCategory && filterBrand && filterFeature;
            });

            elements.wikiResults.innerHTML = products.map(item => `
                <button class="history-item" type="button" data-product="${item.id}">
                    <div>${escapeHTML(item.name)}</div>
                    <div class="history-meta">${escapeHTML(item.brand)} • ${escapeHTML(item.category)}</div>
                </button>
            `).join("") || `<div class="tile-desc">Keine Produkte gefunden.</div>`;

            renderWikiEntries();
            renderWikiFilters();
            renderWikiDetail();
            renderWikiAnswer();
            renderWikiCompare();
        }

        function renderWikiEntries() {
            if (!elements.wikiEntryList || !elements.wikiEntryDetail) return;
            elements.wikiEntryList.innerHTML = appState.wiki.entries.map(entry => `
                <button class="history-item" type="button" data-wiki-entry="${entry.id}">
                    <div>${escapeHTML(entry.title || "Ohne Titel")}</div>
                    <div class="history-meta">${escapeHTML(entry.category || "Kategorie")}${entry.brand ? ` • ${escapeHTML(entry.brand)}` : ""}</div>
                </button>
            `).join("") || `<div class="tile-desc">Keine Einträge.</div>`;
            renderWikiEntryDetail();
        }

        function renderWikiEntryDetail() {
            if (!elements.wikiEntryDetail) return;
            const entry = appState.wiki.entries.find(item => item.id === appState.wiki.selectedEntryId);
            if (!entry) {
                elements.wikiEntryDetail.innerHTML = `<div class="tile-desc">Kein Eintrag ausgewählt.</div>`;
                return;
            }
            const tags = Array.isArray(entry.tags) ? entry.tags : [];
            elements.wikiEntryDetail.innerHTML = `
                <div class="diag-row">
                    <span class="diag-key">Titel</span>
                    <span class="diag-value">${escapeHTML(entry.title)}</span>
                </div>
                <div class="diag-row">
                    <span class="diag-key">Kategorie</span>
                    <span class="diag-value">${escapeHTML(entry.category)}</span>
                </div>
                <div class="diag-row">
                    <span class="diag-key">Brand</span>
                    <span class="diag-value">${escapeHTML(entry.brand || "–")}</span>
                </div>
                <div class="history-meta">Tags</div>
                <div class="tag-row">
                    ${tags.map(tag => `<div class="tag-item">${escapeHTML(tag)}</div>`).join("") || `<div class="tile-desc">Keine Tags.</div>`}
                </div>
                <div class="history-meta">Kurz</div>
                <div class="tile-desc">${escapeHTML(entry.sections.kurz || "–")}</div>
                <div class="history-meta">Specs</div>
                <div class="tile-desc">${escapeHTML(entry.sections.specs || "–")}</div>
                <div class="history-meta">FAQ</div>
                <div class="tile-desc">${escapeHTML(entry.sections.faq || "–")}</div>
                <div class="btn-group">
                    <button class="btn btn-secondary" type="button" data-wiki-edit="${entry.id}">Bearbeiten</button>
                    <button class="btn btn-danger" type="button" data-wiki-delete="${entry.id}">Löschen</button>
                </div>
            `;
        }

        function renderWikiFilters() {
            const categories = new Set(appState.wiki.products.map(p => p.category).filter(Boolean));
            const brands = new Set(appState.wiki.products.map(p => p.brand).filter(Boolean));
            const features = new Set(appState.wiki.products.flatMap(p => p.tags || []));
            const chips = [
                { type: "category", value: "all", label: "Kategorie" },
                ...Array.from(categories).map(value => ({ type: "category", value, label: value })),
                { type: "brand", value: "all", label: "Brand" },
                ...Array.from(brands).map(value => ({ type: "brand", value, label: value })),
                { type: "feature", value: "all", label: "Feature" },
                ...Array.from(features).map(value => ({ type: "feature", value, label: value }))
            ];
            elements.wikiFilterChips.innerHTML = chips.map(chip => {
                const active = appState.wiki.filters[chip.type] === chip.value;
                return `
                    <button class="chip" type="button" data-filter="${chip.type}" data-value="${chip.value}" aria-pressed="${active}">
                        ${escapeHTML(chip.label)}
                    </button>
                `;
            }).join("");
        }

        function renderWikiDetail() {
            const product = appState.wiki.products.find(item => item.id === appState.wiki.selectedProductId);
            if (!product) {
                elements.wikiDetail.innerHTML = `<div class="tile-desc">Kein Produkt ausgewählt.</div>`;
                return;
            }
            const faq = appState.wiki.faq.filter(item => item.productId === product.id);
            const notes = appState.wiki.notes.filter(item => item.productId === product.id);
            const specs = Object.entries(product.specs || {});
            elements.wikiDetail.innerHTML = `
                <div class="wiki-detail-grid">
                    <div class="diag-row">
                        <span class="diag-key">Produkt</span>
                        <span class="diag-value">${escapeHTML(product.name)}</span>
                    </div>
                    <div class="diag-row">
                        <span class="diag-key">Brand</span>
                        <span class="diag-value">${escapeHTML(product.brand)}</span>
                    </div>
                    <div class="diag-row">
                        <span class="diag-key">Kategorie</span>
                        <span class="diag-value">${escapeHTML(product.category)}</span>
                    </div>
                    <div class="history-meta">Specs</div>
                    <div class="spec-grid">
                        ${specs.map(([field, value]) => `<div class="spec-item">${escapeHTML(field)}: ${escapeHTML(String(value))}</div>`).join("") || `<div class="tile-desc">Keine Specs hinterlegt.</div>`}
                    </div>
                    <div class="history-meta">FAQ</div>
                    <div class="pattern-list">
                        ${faq.map(item => `<div class="pattern-item">${escapeHTML(item.question)} – ${escapeHTML(item.answer)}</div>`).join("") || `<div class="tile-desc">Keine FAQ.</div>`}
                    </div>
                    <div class="history-meta">Zubehör</div>
                    <div class="tag-row">
                        ${product.accessories.map(item => `<div class="tag-item">${escapeHTML(item)}</div>`).join("") || `<div class="tile-desc">Keine Zubehörliste.</div>`}
                    </div>
                    <div class="history-meta">Warnungen</div>
                    <div class="tag-row">
                        ${product.warnings.map(item => `<div class="tag-item">${escapeHTML(item)}</div>`).join("") || `<div class="tile-desc">Keine Warnungen.</div>`}
                    </div>
                    <div class="history-meta">Notizen</div>
                    <div class="pattern-list">
                        ${notes.map(item => `<div class="pattern-item">${escapeHTML(item.note)}</div>`).join("") || `<div class="tile-desc">Keine Notizen.</div>`}
                    </div>
                    <button class="btn btn-secondary" type="button" data-compare="${product.id}">Zum Vergleich</button>
                </div>
            `;
        }

        function renderWikiAnswer() {
            const answer = appState.wiki.answer;
            if (!answer) {
                elements.wikiAnswerStatus.textContent = "–";
                elements.wikiAnswerText.textContent = "";
                elements.wikiCitations.innerHTML = "";
                return;
            }
            elements.wikiAnswerStatus.textContent = `${answer.status} • ${answer.source}`;
            elements.wikiAnswerText.textContent = `${answer.answer} Nächster Schritt: ${answer.nextAction}`;
            elements.wikiCitations.innerHTML = answer.citations.map(item => `
                <div class="pattern-item">
                    <div>${escapeHTML(item.field)}</div>
                    <div class="pattern-meta">${escapeHTML(item.value)} (${item.origin})</div>
                </div>
            `).join("") || `<div class="tile-desc">Keine Zitate.</div>`;
        }

        function renderWikiCompare() {
            const compareItems = appState.wiki.comparisons.map(id => appState.wiki.products.find(p => p.id === id)).filter(Boolean);
            elements.wikiCompareList.innerHTML = compareItems.map(item => `
                <div class="history-item">
                    <div>${escapeHTML(item.name)}</div>
                    <div class="history-meta">${escapeHTML(item.brand)}</div>
                </div>
            `).join("") || `<div class="tile-desc">Kein Vergleich aktiv.</div>`;
        }

        function getIcon(iconName) {
            const map = {
                shield: '<path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/>',
                clock: '<circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/>',
                tag: '<path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/>',
                info: '<circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/>'
            };
            return map[iconName] || map.info;
        }

        function render() {
            elements.deptBadge.textContent = appState.settings.department;
            if (elements.hudSubtitle) {
                elements.hudSubtitle.textContent = appState.loading ? "Analyse läuft" : "Bereit";
            }
            updateContextStatus();
            updateTrustStatus();
            updatePolicyTile();
            updateDiagnostics();
            renderSalesFrame();
            renderTrainingFrame();
            renderWikiFrame();
        }

        function copyToClipboard(text) {
            const value = text.trim();
            if (!value) return;
            const fallbackCopy = () => {
                try {
                    const textarea = document.createElement("textarea");
                    textarea.value = value;
                    textarea.setAttribute("readonly", "true");
                    textarea.style.position = "absolute";
                    textarea.style.left = "-9999px";
                    document.body.appendChild(textarea);
                    textarea.select();
                    const ok = document.execCommand("copy");
                    document.body.removeChild(textarea);
                    return ok;
                } catch {
                    return false;
                }
            };
            const handleSuccess = () => {
                showToast("Kopiert");
                haptic([50]);
            };
            const handleFail = () => showToast("Kopieren fehlgeschlagen");
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(value).then(handleSuccess).catch(() => {
                    const ok = fallbackCopy();
                    if (ok) handleSuccess();
                    else handleFail();
                });
                return;
            }
            const ok = fallbackCopy();
            if (ok) handleSuccess();
            else handleFail();
        }

        function openWikiEditor(entry = null) {
            if (!elements.wikiEditorModal) return;
            elements.wikiEditorId.value = entry ? entry.id : "";
            elements.wikiTitle.value = entry ? entry.title : "";
            elements.wikiCategory.value = entry ? entry.category : "";
            elements.wikiBrand.value = entry ? entry.brand : "";
            elements.wikiTags.value = entry && entry.tags ? entry.tags.join(", ") : "";
            elements.wikiKurz.value = entry ? entry.sections.kurz : "";
            elements.wikiSpecs.value = entry ? entry.sections.specs : "";
            elements.wikiFaq.value = entry ? entry.sections.faq : "";
            openModal(elements.wikiEditorModal);
        }

        function closeWikiEditor() {
            if (!elements.wikiEditorModal) return;
            closeModal(elements.wikiEditorModal);
        }

        async function handleWikiEditorSave() {
            const title = sanitizeString(elements.wikiTitle.value, 120);
            const category = sanitizeString(elements.wikiCategory.value, 80);
            if (!title || !category) {
                showToast("Titel und Kategorie erforderlich");
                return;
            }
            const entry = normalizeWikiEntry({
                id: sanitizeString(elements.wikiEditorId.value, 80) || `wiki_${Date.now()}`,
                title,
                category,
                brand: sanitizeString(elements.wikiBrand.value, 80),
                tags: elements.wikiTags.value,
                sections: {
                    kurz: sanitizeString(elements.wikiKurz.value, 600),
                    specs: sanitizeString(elements.wikiSpecs.value, 800),
                    faq: sanitizeString(elements.wikiFaq.value, 800)
                },
                updatedAt: new Date().toISOString()
            });
            await saveWikiEntry(entry);
            const index = appState.wiki.entries.findIndex(item => item.id === entry.id);
            if (index > -1) {
                appState.wiki.entries[index] = entry;
            } else {
                appState.wiki.entries.unshift(entry);
            }
            appState.wiki.selectedEntryId = entry.id;
            renderWikiEntries();
            closeWikiEditor();
            showToast("Wiki Eintrag gespeichert");
        }

        async function handleWikiReset() {
            const confirmed = await confirmAction({
                title: "Wiki zurücksetzen?",
                message: "Alle lokalen Wiki Einträge werden entfernt.",
                confirmLabel: "Zurücksetzen"
            });
            if (!confirmed) return;
            await resetWikiEntries();
            appState.wiki.entries = (await getAllWikiEntries()).map(normalizeWikiEntry).filter(Boolean);
            appState.wiki.selectedEntryId = appState.wiki.entries[0]?.id || null;
            renderWikiEntries();
            showToast("Wiki zurückgesetzt");
        }

        function setupSpeechRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                elements.micBtn.disabled = true;
                elements.micBtn.setAttribute("aria-disabled", "true");
                return;
            }
            recognition = new SpeechRecognition();
            recognition.lang = "de-AT";
            recognition.interimResults = false;
            recognition.continuous = false;

            recognition.onresult = (event) => {
                const text = event.results[0][0].transcript;
                appState.objection = text;
                elements.objectionInput.value = text;
                handleObjectionSubmit();
            };

            recognition.onend = () => {
                elements.micBtn.classList.remove("recording");
                elements.micBtn.setAttribute("aria-pressed", "false");
            };

            recognition.onerror = () => {
                elements.micBtn.classList.remove("recording");
                elements.micBtn.classList.remove("processing");
                elements.micBtn.setAttribute("aria-pressed", "false");
                showToast("Spracheingabe fehlgeschlagen");
            };
        }

        async function encryptSecret(secret, passphrase) {
            if (!window.crypto || !window.crypto.subtle) throw new Error("Crypto not supported");
            const enc = new TextEncoder();
            const salt = window.crypto.getRandomValues(new Uint8Array(16));
            const iv = window.crypto.getRandomValues(new Uint8Array(12));
            const keyMaterial = await window.crypto.subtle.importKey("raw", enc.encode(passphrase), "PBKDF2", false, ["deriveKey"]);
            const key = await window.crypto.subtle.deriveKey(
                { name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" },
                keyMaterial,
                { name: "AES-GCM", length: 256 },
                false,
                ["encrypt"]
            );
            const cipher = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, enc.encode(secret));
            return {
                cipher: btoa(String.fromCharCode(...new Uint8Array(cipher))),
                iv: btoa(String.fromCharCode(...iv)),
                salt: btoa(String.fromCharCode(...salt))
            };
        }

        async function decryptSecret(encrypted, passphrase, iv, salt) {
            if (!window.crypto || !window.crypto.subtle) throw new Error("Crypto not supported");
            const enc = new TextEncoder();
            const data = Uint8Array.from(atob(encrypted), c => c.charCodeAt(0));
            const ivBytes = Uint8Array.from(atob(iv), c => c.charCodeAt(0));
            const saltBytes = Uint8Array.from(atob(salt), c => c.charCodeAt(0));
            const keyMaterial = await window.crypto.subtle.importKey("raw", enc.encode(passphrase), "PBKDF2", false, ["deriveKey"]);
            const key = await window.crypto.subtle.deriveKey(
                { name: "PBKDF2", salt: saltBytes, iterations: 100000, hash: "SHA-256" },
                keyMaterial,
                { name: "AES-GCM", length: 256 },
                false,
                ["decrypt"]
            );
            const plain = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: ivBytes }, key, data);
            return new TextDecoder().decode(plain);
        }

        async function handleLockToggle() {
            const isLocked = appState.settings.apiKeyLocked;
            if (!isLocked) {
                const passphrase = elements.passphraseInput.value.trim();
                const keyValue = elements.apiKey.value.trim();
                if (!passphrase) return showToast("Passphrase fehlt");
                if (!keyValue) return showToast("API Key fehlt");
                try {
                    const encrypted = await encryptSecret(keyValue, passphrase);
                    appState.settings.apiKeyEncrypted = encrypted.cipher;
                    appState.settings.apiKeyIv = encrypted.iv;
                    appState.settings.apiKeySalt = encrypted.salt;
                    appState.settings.apiKeyLocked = true;
                    appState.settings.apiKey = "";
                    elements.apiKey.value = "";
                    elements.lockStatus.textContent = "Lock aktiv";
                    elements.lockToggleBtn.textContent = "Passphrase-Lock deaktivieren";
                    showToast("Key gesperrt");
                    await saveSettings(buildPersistedSettings());
                    updateTrustStatus();
                } catch {
                    showToast("Passphrase-Lock fehlgeschlagen");
                }
            } else {
                appState.settings.apiKeyLocked = false;
                appState.settings.apiKeyEncrypted = "";
                appState.settings.apiKeyIv = "";
                appState.settings.apiKeySalt = "";
                elements.lockStatus.textContent = "Lock deaktiviert";
                elements.lockToggleBtn.textContent = "Passphrase-Lock aktivieren";
                showToast("Lock deaktiviert");
                await saveSettings(buildPersistedSettings());
                updateTrustStatus();
            }
        }

        async function handleUnlock() {
            if (!appState.settings.apiKeyLocked) return showToast("Key ist nicht gesperrt");
            const passphrase = elements.passphraseInput.value.trim();
            if (!passphrase) return showToast("Passphrase fehlt");
            try {
                const decrypted = await decryptSecret(
                    appState.settings.apiKeyEncrypted,
                    passphrase,
                    appState.settings.apiKeyIv,
                    appState.settings.apiKeySalt
                );
                appState.settings.apiKey = decrypted;
                elements.lockStatus.textContent = "Key entsperrt (Session)";
                showToast("Key entsperrt");
                updateTrustStatus();
            } catch {
                showToast("Passphrase falsch");
            }
        }

        async function exportData() {
            const settings = buildPersistedSettings();
            const cases = await getAllCases();
            const logs = await getAllLogs();
            const products = await getAllProducts();
            const faq = await getAllFaq();
            const notes = await getAllNotes();
            const comparisons = await getAllComparisons();
            const seller = await loadSellerState();
            return {
                version: APP_VERSION,
                exportDate: new Date().toISOString(),
                settings,
                cases,
                logs,
                products,
                faq,
                notes,
                comparisons,
                seller,
                wikiEntries: await getAllWikiEntries()
            };
        }

        async function exportLibraryData() {
            const library = (await getAllLibraryItems()).map(normalizeLibraryItem).filter(Boolean);
            return {
                schemaVersion: 1,
                exportVersion: 1,
                library
            };
        }

        async function importData(file) {
            const raw = await file.text();
            const parsed = JSON.parse(raw);
            if (!parsed || typeof parsed !== "object") throw new Error("Invalid import");

            const settings = sanitizeImportSettings(parsed.settings);
            if (settings) {
                appState.settings = { ...appState.settings, ...settings };
                applyTheme(appState.settings.themeMode, false);
                if (appState.settings.densityMode) {
                    applyDensity(appState.settings.densityMode, appState.settings.densityUserSet, false);
                }
                setFrame(appState.settings.frameMode || "sales", false);
                await saveSettings(buildPersistedSettings());
            }

            const cases = Array.isArray(parsed.cases) ? parsed.cases.map(normalizeCaseCard) : [];
            const logs = Array.isArray(parsed.logs) ? parsed.logs : [];
            const products = Array.isArray(parsed.products) ? parsed.products.map(normalizeProduct).filter(Boolean) : [];
            const faq = Array.isArray(parsed.faq) ? parsed.faq.map(normalizeFaq).filter(Boolean) : [];
            const notes = Array.isArray(parsed.notes) ? parsed.notes.map(normalizeNote).filter(Boolean) : [];
            const comparisons = Array.isArray(parsed.comparisons)
                ? parsed.comparisons.map(item => (typeof item === "string" ? { id: item } : item)).filter(Boolean)
                : [];
            const seller = parsed.seller || null;
            const wikiEntries = Array.isArray(parsed.wikiEntries) ? parsed.wikiEntries.map(normalizeWikiEntry).filter(Boolean) : [];

            await saveAllToStore("cases", "msos_cases", cases);
            await saveAllToStore("logs", "msos_logs", logs);
            await saveAllToStore("products", "msos_products", products);
            await saveAllToStore("productFaq", "msos_product_faq", faq);
            await saveAllToStore("productNotes", "msos_product_notes", notes);
            await saveAllToStore("comparisons", "msos_comparisons", comparisons);
            await saveAllToStore("wiki", "msos_wiki", wikiEntries);

            if (seller) {
                appState.history = seller.history || [];
                appState.favorites = seller.favorites || [];
                appState.training = { ...appState.training, ...seller.training };
                await saveSellerState();
            }
            await refreshWikiData();
            await updateStats();
        }

        async function importLibraryData(file) {
            if (file.size > 2 * 1024 * 1024) throw new Error("Datei zu groß");
            const raw = await file.text();
            const parsed = JSON.parse(raw);
            if (!parsed || typeof parsed !== "object") throw new Error("Invalid import");
            const keys = Object.keys(parsed);
            const allowed = ["schemaVersion", "exportVersion", "library"];
            if (keys.length !== allowed.length || !allowed.every(key => keys.includes(key))) {
                throw new Error("Schema ungültig");
            }
            if (!Array.isArray(parsed.library)) throw new Error("Library fehlt");
            if (parsed.library.length > 10000) throw new Error("Zu viele Einträge");
            const normalized = parsed.library.map(normalizeLibraryItem).filter(Boolean);
            await saveAllToStore("objection_library", "msos_objection_library", normalized);
            await refreshLibraryItems();
        }

        async function verifyLibraryHash(buffer) {
            if (!window.crypto || !window.crypto.subtle) return false;
            const hashBuffer = await window.crypto.subtle.digest("SHA-256", buffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashBase64 = btoa(String.fromCharCode(...hashArray));
            return hashBase64 === LIBRARY_SHA256;
        }

        async function syncLibrary(manual = false) {
            if (!navigator.onLine) {
                setSyncStatus("offline", "Offline");
                if (manual) showToast("Offline – Sync pausiert");
                return;
            }
            setSyncStatus("syncing", "Syncing");
            try {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 10000);
                const response = await fetch(MASTER_LIBRARY_URL, {
                    cache: "no-store",
                    credentials: "omit",
                    referrerPolicy: "no-referrer",
                    signal: controller.signal
                });
                clearTimeout(timeout);
                if (!response.ok) throw new Error("Sync failed");
                const buffer = await response.arrayBuffer();
                const hashOk = await verifyLibraryHash(buffer);
                if (!hashOk) throw new Error("Integrity failed");
                const text = new TextDecoder().decode(buffer);
                const data = JSON.parse(text);
                if (!Array.isArray(data)) throw new Error("Format invalid");
                const normalized = data.map(normalizeCaseCard);
                await saveAllToStore("cases", "msos_cases", normalized);
                appState.ui.lastSync = new Date().toISOString();
                appState.settings.lastSyncAt = appState.ui.lastSync;
                await saveSettings(buildPersistedSettings());
                setSyncStatus("ok", "Sync OK");
                updateSyncTime();
                await updateStats();
                if (manual) showToast("Sync abgeschlossen");
            } catch {
                setSyncStatus("error", "Sync Fehler");
                if (manual) showToast("Sync fehlgeschlagen");
            }
        }

        async function syncWiki(manual = false) {
            const url = appState.settings.wikiSourceUrl;
            if (!url) {
                if (manual) showToast("Keine Wiki URL gesetzt");
                return;
            }
            if (!navigator.onLine) {
                if (manual) showToast("Offline – Wiki Sync pausiert");
                return;
            }
            setSyncStatus("syncing", "Syncing");
            try {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 10000);
                const response = await fetch(url, { cache: "no-store", credentials: "omit", signal: controller.signal });
                clearTimeout(timeout);
                if (!response.ok) throw new Error("Wiki Sync failed");
                const data = await response.json();
                const products = Array.isArray(data.products) ? data.products.map(normalizeProduct).filter(Boolean) : (Array.isArray(data) ? data.map(normalizeProduct).filter(Boolean) : []);
                const faq = Array.isArray(data.faq) ? data.faq.map(normalizeFaq).filter(Boolean) : [];
                const notes = Array.isArray(data.notes) ? data.notes.map(normalizeNote).filter(Boolean) : [];
                await saveAllToStore("products", "msos_products", products);
                await saveAllToStore("productFaq", "msos_product_faq", faq);
                await saveAllToStore("productNotes", "msos_product_notes", notes);
                appState.ui.lastWikiSync = new Date().toISOString();
                appState.settings.lastWikiSyncAt = appState.ui.lastWikiSync;
                await saveSettings(buildPersistedSettings());
                await refreshWikiData();
                setSyncStatus("ok", "Sync OK");
                if (manual) showToast("Wiki Sync abgeschlossen");
            } catch {
                setSyncStatus("error", "Sync Fehler");
                if (manual) showToast("Wiki Sync fehlgeschlagen");
            }
        }

        async function refreshWikiData() {
            appState.wiki.products = (await getAllProducts()).map(normalizeProduct).filter(Boolean);
            appState.wiki.faq = (await getAllFaq()).map(normalizeFaq).filter(Boolean);
            appState.wiki.notes = (await getAllNotes()).map(normalizeNote).filter(Boolean);
            const comparisons = await getAllComparisons();
            appState.wiki.comparisons = comparisons.map(item => item.id || item);
            await ensureWikiSeeds();
            appState.wiki.entries = (await getAllWikiEntries()).map(normalizeWikiEntry).filter(Boolean);
            if (appState.wiki.selectedEntryId && !appState.wiki.entries.find(entry => entry.id === appState.wiki.selectedEntryId)) {
                appState.wiki.selectedEntryId = appState.wiki.entries[0]?.id || null;
            }
            if (!appState.wiki.selectedEntryId && appState.wiki.entries.length) {
                appState.wiki.selectedEntryId = appState.wiki.entries[0].id;
            }
            renderWikiFrame();
        }

        function setupViewportHandling() {
            if (!window.visualViewport) return;
            const update = () => {
                const offset = Math.max(0, window.innerHeight - window.visualViewport.height - window.visualViewport.offsetTop);
                document.documentElement.style.setProperty("--keyboard-offset", `${Math.round(offset)}px`);
            };
            window.visualViewport.addEventListener("resize", update, { passive: true });
            window.visualViewport.addEventListener("scroll", update, { passive: true });
            update();
        }

        function setupControlBarObserver() {
            if (!elements.controlBar) return;
            const update = () => {
                document.documentElement.style.setProperty("--control-bar-height", `${elements.controlBar.offsetHeight}px`);
            };
            update();
            if ("ResizeObserver" in window) {
                controlBarObserver = new ResizeObserver(update);
                controlBarObserver.observe(elements.controlBar);
            }
        }

        function setupEvents() {
            elements.settingsBtn.addEventListener("click", () => {
                if (panelOpen && !panelDocked) {
                    closeQuickPanel();
                    return;
                }
                openSettings();
            });
            elements.closeSettingsBtn.addEventListener("click", () => closeQuickPanel());
            elements.settingsModal.addEventListener("click", (event) => {
                if (event.target === elements.settingsModal && !panelDocked) {
                    closeQuickPanel();
                }
            });
            elements.confirmModal.addEventListener("click", (event) => {
                if (event.target === elements.confirmModal) closeModal(elements.confirmModal);
            });

            elements.frameSalesBtn.addEventListener("click", () => {
                setFrame("sales");
                if (!panelDocked) closeQuickPanel();
            });
            elements.frameTrainingBtn.addEventListener("click", () => {
                setFrame("training");
                if (!panelDocked) closeQuickPanel();
            });
            elements.frameWikiBtn.addEventListener("click", () => {
                setFrame("wiki");
                if (!panelDocked) closeQuickPanel();
            });

            if (elements.syncBtn) {
                elements.syncBtn.addEventListener("click", () => syncLibrary(true));
            }
            elements.wikiSyncBtn.addEventListener("click", () => syncWiki(true));
            elements.wikiClearBtn.addEventListener("click", () => {
                appState.wiki.filters = { category: "all", brand: "all", feature: "all" };
                appState.wiki.searchQuery = "";
                elements.wikiSearchInput.value = "";
                renderWikiFrame();
            });

            elements.contextChips.addEventListener("click", (event) => {
                const chip = event.target.closest(".chip");
                if (!chip) return;
                const context = chip.dataset.context;
                if (!context) return;
                const index = appState.contexts.indexOf(context);
                if (index > -1) {
                    appState.contexts.splice(index, 1);
                    chip.setAttribute("aria-pressed", "false");
                } else {
                    appState.contexts.push(context);
                    chip.setAttribute("aria-pressed", "true");
                }
                updateContextStatus();
            });

            if (elements.techQuestionToggle) {
                elements.techQuestionToggle.addEventListener("click", () => {
                    const isActive = elements.techQuestionToggle.getAttribute("aria-pressed") === "true";
                    const next = !isActive;
                    elements.techQuestionToggle.setAttribute("aria-pressed", String(next));
                    appState.ui.techQuestion = next;
                    showToast(next ? "Technische Frage aktiv" : "Technische Frage aus");
                });
            }

            elements.objectionInput.addEventListener("input", (event) => {
                appState.objection = event.target.value;
            });
            elements.objectionInput.addEventListener("keydown", (event) => {
                if (event.key === "Enter" && !event.isComposing) {
                    event.preventDefault();
                    handleObjectionSubmit();
                }
            });
            elements.submitBtn.addEventListener("click", () => handleObjectionSubmit());
            elements.micBtn.addEventListener("click", () => {
                if (!recognition) return showToast("Spracheingabe nicht unterstützt");
                if (elements.micBtn.classList.contains("recording")) {
                    recognition.stop();
                    return;
                }
                elements.micBtn.classList.add("recording");
                elements.micBtn.setAttribute("aria-pressed", "true");
                recognition.start();
            });

            elements.salesCardContainer.addEventListener("click", (event) => {
                const trigger = event.target.closest(".expand-trigger");
                if (trigger) {
                    const targetId = trigger.dataset.target;
                    const content = document.getElementById(targetId);
                    const icon = trigger.querySelector(".expand-icon");
                    const isOpen = trigger.getAttribute("aria-expanded") === "true";
                    trigger.setAttribute("aria-expanded", String(!isOpen));
                    content.classList.toggle("open", !isOpen);
                    content.hidden = isOpen;
                    icon.classList.toggle("open", !isOpen);
                }

                const feedbackBtn = event.target.closest("[data-feedback]");
                if (feedbackBtn) {
                    const feedback = feedbackBtn.dataset.feedback;
                    const cardId = feedbackBtn.dataset.card;
                    updateHistoryResult(cardId, feedback);
                    logEvent("feedback", { cardId, feedback });
                    showToast(feedback === "success" ? "Feedback gespeichert" : "Danke für Ihr Feedback");
                    haptic(feedback === "success" ? [30] : [70]);
                    renderTrainingStats();
                }

                const libraryVote = event.target.closest("[data-library-vote]");
                if (libraryVote) {
                    const card = getActiveCard();
                    if (!card) return;
                    await recordLibraryVote(card, libraryVote.dataset.libraryVote);
                    showToast("Learning Loop gespeichert");
                }

                const favoriteBtn = event.target.closest(".favorite-btn");
                if (favoriteBtn) {
                    toggleFavorite(favoriteBtn.dataset.favorite);
                }

                const copyBtn = event.target.closest(".copy-btn");
                if (copyBtn) {
                    const card = getActiveCard();
                    if (!card) return;
                    const field = copyBtn.dataset.copy;
                    const variant = copyBtn.dataset.variant || "neutral";
                    const quick = card.content.quick[variant] || card.content.quick.neutral;
                    if (field === "full") {
                        copyToClipboard([quick.entry, quick.anchor, quick.question, quick.bridge, quick.close].join(" "));
                    } else {
                        copyToClipboard(quick[field] || "");
                    }
                }

                const trainBtn = event.target.closest("[data-train]");
                if (trainBtn) {
                    setFrame("training");
                    renderTrainingFrame();
                }
            });

            if (elements.salesPlaybook) {
                elements.salesPlaybook.addEventListener("click", (event) => {
                    const copyBtn = event.target.closest(".copy-btn");
                    if (copyBtn && copyBtn.dataset.playbookCopy) {
                        copyToClipboard(copyBtn.dataset.playbookCopy.replace(/\s*\|\s*/g, " "));
                        return;
                    }
                    const playbookChip = event.target.closest("[data-playbook-text]");
                    if (playbookChip) {
                        const text = playbookChip.dataset.playbookText;
                        const current = elements.objectionInput.value.trim();
                        const next = current ? `${current} ${text}` : text;
                        elements.objectionInput.value = next;
                        appState.objection = next;
                        trackPlaybookRef(text);
                        elements.objectionInput.focus();
                    }
                });
            }

            elements.trainingCardContainer.addEventListener("click", (event) => {
                const copyBtn = event.target.closest(".copy-btn");
                if (!copyBtn) return;
                const card = getActiveCard();
                if (!card) return;
                const field = copyBtn.dataset.copy;
                const variant = copyBtn.dataset.variant || "neutral";
                const quick = card.content.quick[variant] || card.content.quick.neutral;
                if (field === "full") {
                    copyToClipboard([quick.entry, quick.anchor, quick.question, quick.bridge, quick.close].join(" "));
                } else {
                    copyToClipboard(quick[field] || "");
                }
            });

            elements.historyList.addEventListener("click", (event) => {
                const item = event.target.closest("[data-history]");
                if (!item) return;
                const entry = appState.history.find(h => h.id === item.dataset.history);
                if (entry && entry.card) {
                    setActiveCard(normalizeCaseCard(entry.card), { addToHistory: false });
                    render();
                }
            });

            elements.favoriteList.addEventListener("click", (event) => {
                const item = event.target.closest("[data-favorite-item]");
                if (!item) return;
                const entry = appState.history.find(h => h.cardId === item.dataset.favoriteItem);
                if (entry && entry.card) {
                    setActiveCard(normalizeCaseCard(entry.card), { addToHistory: false });
                    render();
                }
            });

            [elements.variantSoftBtn, elements.variantNeutralBtn, elements.variantChallengerBtn].forEach(btn => {
                btn.addEventListener("click", () => {
                    appState.training.variant = btn.dataset.variant;
                    renderTrainingFrame();
                });
            });

            elements.roleplayBtn.addEventListener("click", () => {
                const card = getActiveCard();
                if (!card) return;
                elements.roleplayPrompt.textContent = `Kunde sagt: "${card.content.quick.neutral.question}"`;
                elements.roleplayResponse.textContent = "Antwort wählen.";
            });

            [elements.roleplaySoftBtn, elements.roleplayNeutralBtn, elements.roleplayChallengerBtn].forEach(btn => {
                btn.addEventListener("click", () => {
                    const card = getActiveCard();
                    if (!card) return;
                    const variant = btn.dataset.variant;
                    const quick = card.content.quick[variant];
                    elements.roleplayResponse.textContent = `${quick.entry} ${quick.anchor} ${quick.question} ${quick.bridge} ${quick.close}`;
                    logEvent("roleplay_response", { variant, cardId: card.id });
                });
            });

            elements.nextDrillBtn.addEventListener("click", () => {
                appState.training.drillIndex += 1;
                renderTrainingFrame();
            });

            elements.drillDoneBtn.addEventListener("click", () => {
                const today = new Date().toISOString().slice(0, 10);
                if (appState.training.lastSessionDate === today) {
                    appState.training.streak += 1;
                } else {
                    appState.training.streak = 1;
                    appState.training.lastSessionDate = today;
                }
                appState.training.sessions += 1;
                saveSellerState();
                renderTrainingStats();
                showToast("Drill Session gespeichert");
            });

            elements.ratingButtons.addEventListener("click", (event) => {
                const button = event.target.closest(".rating-btn");
                if (!button) return;
                const rating = Number(button.dataset.rating);
                appState.training.ratingSum += rating;
                appState.training.ratingCount += 1;
                saveSellerState();
                showToast("Rating gespeichert");
            });

            elements.patternFilter.addEventListener("change", (event) => {
                appState.training.selectedPattern = event.target.value;
                renderPatternLibrary();
            });

            elements.wikiSearchInput.addEventListener("input", (event) => {
                appState.wiki.searchQuery = event.target.value;
                renderWikiFrame();
            });

            elements.wikiFilterChips.addEventListener("click", (event) => {
                const chip = event.target.closest(".chip");
                if (!chip) return;
                const type = chip.dataset.filter;
                const value = chip.dataset.value;
                appState.wiki.filters[type] = value;
                renderWikiFrame();
            });

            elements.wikiResults.addEventListener("click", (event) => {
                const item = event.target.closest("[data-product]");
                if (!item) return;
                appState.wiki.selectedProductId = item.dataset.product;
                renderWikiDetail();
            });

            if (elements.wikiNewBtn) {
                elements.wikiNewBtn.addEventListener("click", () => {
                    openWikiEditor();
                });
            }

            if (elements.wikiEntryList) {
                elements.wikiEntryList.addEventListener("click", (event) => {
                    const item = event.target.closest("[data-wiki-entry]");
                    if (!item) return;
                    appState.wiki.selectedEntryId = item.dataset.wikiEntry;
                    renderWikiEntryDetail();
                });
            }

            if (elements.wikiEntryDetail) {
                elements.wikiEntryDetail.addEventListener("click", async (event) => {
                    const editBtn = event.target.closest("[data-wiki-edit]");
                    if (editBtn) {
                        const entry = appState.wiki.entries.find(item => item.id === editBtn.dataset.wikiEdit);
                        if (entry) openWikiEditor(entry);
                        return;
                    }
                    const deleteBtn = event.target.closest("[data-wiki-delete]");
                    if (deleteBtn) {
                        const confirmed = await confirmAction({
                            title: "Wiki Eintrag löschen?",
                            message: "Der Eintrag wird lokal entfernt.",
                            confirmLabel: "Löschen"
                        });
                        if (!confirmed) return;
                        const id = deleteBtn.dataset.wikiDelete;
                        await deleteWikiEntry(id);
                        appState.wiki.entries = appState.wiki.entries.filter(item => item.id !== id);
                        if (appState.wiki.selectedEntryId === id) {
                            appState.wiki.selectedEntryId = appState.wiki.entries[0]?.id || null;
                        }
                        renderWikiEntries();
                        showToast("Wiki Eintrag gelöscht");
                    }
                });
            }

            if (elements.wikiEditorSaveBtn) {
                elements.wikiEditorSaveBtn.addEventListener("click", () => handleWikiEditorSave());
            }
            if (elements.wikiEditorCancelBtn) {
                elements.wikiEditorCancelBtn.addEventListener("click", () => closeWikiEditor());
            }
            if (elements.wikiEditorCloseBtn) {
                elements.wikiEditorCloseBtn.addEventListener("click", () => closeWikiEditor());
            }
            if (elements.wikiEditorModal) {
                elements.wikiEditorModal.addEventListener("cancel", (event) => {
                    event.preventDefault();
                    closeWikiEditor();
                });
                elements.wikiEditorModal.addEventListener("click", (event) => {
                    if (event.target === elements.wikiEditorModal) {
                        closeWikiEditor();
                    }
                });
            }

            elements.wikiDetail.addEventListener("click", (event) => {
                const btn = event.target.closest("[data-compare]");
                if (!btn) return;
                const id = btn.dataset.compare;
                const index = appState.wiki.comparisons.indexOf(id);
                if (index > -1) {
                    appState.wiki.comparisons.splice(index, 1);
                } else {
                    appState.wiki.comparisons.push(id);
                }
                saveAllToStore("comparisons", "msos_comparisons", appState.wiki.comparisons.map(idValue => ({ id: idValue })));
                renderWikiCompare();
            });

            elements.wikiQuestionInput.addEventListener("keydown", (event) => {
                if (event.key === "Enter") {
                    event.preventDefault();
                    handleWikiQuestion();
                }
            });
            elements.wikiQuestionBtn.addEventListener("click", () => handleWikiQuestion());

            elements.apiProvider.addEventListener("change", () => {
                const previous = appState.settings.apiProvider;
                const next = elements.apiProvider.value;
                const previousDefault = MODEL_DEFAULTS[previous];
                const currentModel = elements.modelName.value.trim();
                if (!currentModel || currentModel === previousDefault) {
                    elements.modelName.value = MODEL_DEFAULTS[next];
                }
            });

            elements.lockToggleBtn.addEventListener("click", () => handleLockToggle());
            elements.unlockBtn.addEventListener("click", () => handleUnlock());

            elements.exportBtn.addEventListener("click", async () => {
                const confirmed = await confirmAction({
                    title: "Export starten?",
                    message: "Export enthält Settings, Cases, Logs und Wiki.",
                    confirmLabel: "Exportieren"
                });
                if (!confirmed) return;
                const data = await exportData();
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const anchor = document.createElement("a");
                anchor.href = url;
                anchor.download = `mehic_sales_os_export_${Date.now()}.json`;
                anchor.click();
                URL.revokeObjectURL(url);
                showToast("Export abgeschlossen");
            });

            elements.importBtn.addEventListener("click", () => {
                elements.importFile.value = "";
                elements.importFile.click();
            });

            elements.importFile.addEventListener("change", async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const confirmed = await confirmAction({
                    title: "Import starten?",
                    message: "Settings werden überschrieben, Daten hinzugefügt.",
                    confirmLabel: "Importieren"
                });
                if (!confirmed) return;
                try {
                    await importData(file);
                    showToast("Import abgeschlossen");
                    render();
                } catch {
                    showToast("Import fehlgeschlagen");
                }
            });

            if (elements.libraryExportBtn) {
                elements.libraryExportBtn.addEventListener("click", async () => {
                    const confirmed = await confirmAction({
                        title: "Library exportieren?",
                        message: "Export enthält lokale Learning-Loop Einträge.",
                        confirmLabel: "Exportieren"
                    });
                    if (!confirmed) return;
                    const data = await exportLibraryData();
                    const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
                    const url = URL.createObjectURL(blob);
                    const anchor = document.createElement("a");
                    anchor.href = url;
                    anchor.download = `mehic_library_export_${Date.now()}.json`;
                    anchor.click();
                    URL.revokeObjectURL(url);
                    showToast("Library Export abgeschlossen");
                });
            }

            if (elements.libraryImportBtn) {
                elements.libraryImportBtn.addEventListener("click", () => {
                    elements.libraryImportFile.value = "";
                    elements.libraryImportFile.click();
                });
            }

            if (elements.libraryImportFile) {
                elements.libraryImportFile.addEventListener("change", async (event) => {
                    const file = event.target.files[0];
                    if (!file) return;
                    const confirmed = await confirmAction({
                        title: "Library importieren?",
                        message: "Lokale Learning-Loop Einträge werden ersetzt.",
                        confirmLabel: "Importieren"
                    });
                    if (!confirmed) return;
                    try {
                        await importLibraryData(file);
                        showToast("Library Import abgeschlossen");
                    } catch {
                        showToast("Library Import fehlgeschlagen");
                    }
                });
            }

            if (elements.wikiResetBtn) {
                elements.wikiResetBtn.addEventListener("click", () => handleWikiReset());
            }

            elements.clearBtn.addEventListener("click", async () => {
                const confirmed = await confirmAction({
                    title: "Reset bestätigen",
                    message: "Dieser Schritt löscht lokale Daten unwiderruflich.",
                    confirmLabel: "Ich bestätige",
                    requireText: "Ich bestätige",
                    holdMs: 800
                });
                if (!confirmed) return;
                await clearDataStores();
                appState.history = [];
                appState.favorites = [];
                appState.training = { ...DEFAULT_TRAINING_STATE };
                appState.library = [];
                appState.playbookRefs = [];
                await saveSellerState();
                await refreshLibraryItems();
                resetApp();
                await updateStats();
                showToast("Daten gelöscht");
                haptic([90]);
            });

            elements.saveSettingsBtn.addEventListener("click", async () => {
                appState.settings.apiProvider = elements.apiProvider.value;
                appState.settings.modelName = sanitizeString(elements.modelName.value, 80) || MODEL_DEFAULTS[appState.settings.apiProvider];
                const proxyValue = elements.proxyUrl.value.trim();
                const proxyCheck = validateProxyUrl(proxyValue);
                if (proxyValue && !proxyCheck.ok) {
                    showToast("Proxy nicht erlaubt");
                    appState.settings.proxyUrl = "";
                    elements.proxyUrl.value = "";
                } else {
                    appState.settings.proxyUrl = proxyValue;
                }
                appState.settings.department = elements.department.value;
                appState.settings.storePolicy = sanitizeString(elements.storePolicy.value, 400);
                appState.settings.sessionOnlyKey = elements.sessionOnlyKey.checked;
                if (!appState.settings.apiKeyLocked) {
                    appState.settings.apiKey = sanitizeString(elements.apiKey.value, 200);
                }
                appState.settings.wikiSourceUrl = sanitizeString(elements.wikiSourceUrl.value, 200);
                const themeMode = document.querySelector("input[name='themeMode']:checked");
                const densityMode = document.querySelector("input[name='densityMode']:checked");
                if (themeMode) applyTheme(themeMode.value, false);
                if (densityMode) applyDensity(densityMode.value, true, false);
                await saveSettings(buildPersistedSettings());
                updatePolicyTile();
                updateTrustStatus();
                render();
                showToast("Einstellungen gespeichert");
                haptic([30]);
                closeQuickPanel();
            });

            elements.themeAuto.addEventListener("change", () => applyTheme("auto"));
            elements.themeLight.addEventListener("change", () => applyTheme("light"));
            elements.themeDark.addEventListener("change", () => applyTheme("dark"));
            elements.densityCompact.addEventListener("change", () => applyDensity("compact", true));
            elements.densityComfortable.addEventListener("change", () => applyDensity("comfortable", true));

            window.addEventListener("online", updateOnlineStatus, { passive: true });
            window.addEventListener("offline", updateOnlineStatus, { passive: true });

            document.addEventListener("keydown", (event) => {
                if (event.key === "Escape") {
                    if (elements.confirmModal.classList.contains("open")) {
                        closeModal(elements.confirmModal);
                        return;
                    }
                    if (elements.settingsModal.classList.contains("open")) {
                        closeQuickPanel();
                        return;
                    }
                    if (appState.stealthMode) setStealthMode(false);
                }

                if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === "k") {
                    event.preventDefault();
                    elements.objectionInput.focus();
                }
                if (event.ctrlKey && event.shiftKey && event.key.toLowerCase() === "i") {
                    event.preventDefault();
                    setDebugMode(!appState.ui.debug);
                }
                if (event.ctrlKey && event.shiftKey && event.key.toLowerCase() === "t") {
                    event.preventDefault();
                    cycleTheme();
                }
                if (event.ctrlKey && event.shiftKey && event.key.toLowerCase() === "d") {
                    event.preventDefault();
                    toggleDensity();
                }
                if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === "s") {
                    event.preventDefault();
                    openSettings();
                }
                if (event.altKey && event.key === "1") {
                    event.preventDefault();
                    setFrame("sales");
                }
                if (event.altKey && event.key === "2") {
                    event.preventDefault();
                    setFrame("training");
                }
                if (event.altKey && event.key === "3") {
                    event.preventDefault();
                    setFrame("wiki");
                }
            });

            window.addEventListener("popstate", () => {
                if (ignoreNextPop) {
                    ignoreNextPop = false;
                    return;
                }
                const activeModalId = modalStack[modalStack.length - 1];
                if (activeModalId) {
                    if (activeModalId === "settingsModal") {
                        closeQuickPanel(true);
                        return;
                    }
                    const activeModal = document.getElementById(activeModalId);
                    if (activeModal) closeModal(activeModal, true);
                }
            });

            const themeListener = () => {
                if (appState.settings.themeMode === "auto") applyTheme("auto", false);
            };
            if (themeMedia.addEventListener) {
                themeMedia.addEventListener("change", themeListener);
            } else if (themeMedia.addListener) {
                themeMedia.addListener(themeListener);
            }

            const motionListener = () => updateTrustStatus();
            if (reduceMotionMedia.addEventListener) {
                reduceMotionMedia.addEventListener("change", motionListener);
            } else if (reduceMotionMedia.addListener) {
                reduceMotionMedia.addListener(motionListener);
            }

            window.addEventListener("resize", () => {
                if (densityResizeRaf) cancelAnimationFrame(densityResizeRaf);
                densityResizeRaf = requestAnimationFrame(() => {
                    if (!appState.settings.densityUserSet) {
                        const nextDensity = computeDensity(window.innerWidth);
                        if (nextDensity !== appState.settings.densityMode) {
                            applyDensity(nextDensity, false);
                        }
                    }
                    updatePanelDockedState();
                    densityResizeRaf = null;
                });
            });
        }

        function openSettings() {
            elements.apiProvider.value = appState.settings.apiProvider;
            elements.apiKey.value = appState.settings.apiKeyLocked ? "" : appState.settings.apiKey;
            elements.modelName.value = appState.settings.modelName;
            elements.proxyUrl.value = appState.settings.proxyUrl;
            elements.department.value = appState.settings.department;
            elements.storePolicy.value = appState.settings.storePolicy;
            elements.sessionOnlyKey.checked = appState.settings.sessionOnlyKey;
            elements.wikiSourceUrl.value = appState.settings.wikiSourceUrl;
            elements.lockStatus.textContent = appState.settings.apiKeyLocked ? "Lock aktiv" : "Lock deaktiviert";
            elements.lockToggleBtn.textContent = appState.settings.apiKeyLocked ? "Passphrase-Lock deaktivieren" : "Passphrase-Lock aktivieren";
            elements.themeAuto.checked = appState.settings.themeMode === "auto";
            elements.themeLight.checked = appState.settings.themeMode === "light";
            elements.themeDark.checked = appState.settings.themeMode === "dark";
            elements.densityCompact.checked = appState.settings.densityMode === "compact";
            elements.densityComfortable.checked = appState.settings.densityMode === "comfortable";
            openQuickPanel();
        }

        async function handleWikiQuestion() {
            const question = elements.wikiQuestionInput.value;
            appState.wiki.answer = await answerProductQuestion(question);
            renderWikiAnswer();
        }

        function setupWakeLockReacquisition() {
            document.addEventListener("visibilitychange", async () => {
                if (document.visibilityState === "visible") {
                    await requestWakeLock();
                }
            });
        }

        let wakeLock = null;

        async function requestWakeLock() {
            if (!("wakeLock" in navigator)) return;
            try {
                wakeLock = await navigator.wakeLock.request("screen");
            } catch {
                wakeLock = null;
            }
        }

        async function init() {
            cacheElements();
            setDebugMode(false);
            await initDB();
            const savedSettings = await loadSettings();
            if (savedSettings) {
                appState.settings = { ...appState.settings, ...savedSettings };
            }
            if (appState.settings.lastSyncAt) {
                appState.ui.lastSync = appState.settings.lastSyncAt;
                updateSyncTime();
            }
            if (appState.settings.lastWikiSyncAt) {
                appState.ui.lastWikiSync = appState.settings.lastWikiSyncAt;
            }
            const seller = await loadSellerState();
            if (seller) {
                appState.history = seller.history || [];
                appState.favorites = seller.favorites || [];
                appState.training = { ...appState.training, ...seller.training };
            }

            const preferredDensity = appState.settings.densityMode || computeDensity(window.innerWidth);
            applyDensity(preferredDensity, appState.settings.densityUserSet, false);
            applyTheme(appState.settings.themeMode, false);
            const initialFrame = appState.settings.frameMode || "sales";
            setFrame(initialFrame, false);

            setupEvents();
            setupSpeechRecognition();
            setupViewportHandling();
            setupStealthOverlay();
            setupPanelSwipe();
            setupWakeLockReacquisition();
            updatePanelDockedState();
            updateOnlineStatus();
            updatePolicyTile();
            updateTrustStatus();
            await refreshWikiData();
            await refreshLibraryItems();
            render();
            await updateStats();
            requestWakeLock();

            elements.buildInfo.textContent = `Build: ${BUILD_SIGNATURE}`;
            syncLibrary(false);
        }

        init();

        // QA GATES:
        // Device Matrix: iOS Safari 17+, Android Chrome/Samsung Internet, Desktop Chrome/Edge/Firefox/Safari.
        // Test Cases: Theme toggle, Density, Frame switch, Offline, DB denied mode, AI parse fail, Product lookup, Back button modal, Keyboard shortcuts, Reduce-motion.
    </script>
</body>
</html>
